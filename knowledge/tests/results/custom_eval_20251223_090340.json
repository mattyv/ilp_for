{
  "timestamp": "2025-12-23T09:03:40.284941",
  "test_count": 12,
  "average_score": 0.875,
  "pass_rate": 1.0,
  "perfect_rate": 0.75,
  "results": [
    {
      "id": "basic_001",
      "category": "when_to_use",
      "difficulty": "easy",
      "question": "When should I use ILP_FOR instead of a regular for loop?",
      "score": 0.5,
      "details": {
        "rating": "partial",
        "overall_score": 0.75,
        "category_score": 0.5,
        "symbol_score": 1.0,
        "retrieved_categories": [
          "antipatterns",
          "performance",
          "gotchas",
          "api_signatures"
        ],
        "expected_categories": [
          "antipatterns",
          "usage_patterns"
        ],
        "retrieved_symbols": [
          "ILP_FOR",
          "SIMD",
          "ILP_CONTINUE",
          "ILP_BREAK",
          "auto-vectorization"
        ],
        "expected_symbols": [
          "ILP_FOR"
        ],
        "category_overlap": 1,
        "symbol_overlap": 1
      },
      "top_retrieved": [
        {
          "category": "antipatterns",
          "content": "Do NOT use ILP_FOR for simple loops without early exit. Standard loops with #pragma unroll or auto-v...",
          "distance": 0.21542461216449738
        },
        {
          "category": "api_signatures",
          "content": "Macro: #define ILP_FOR(loop_var_decl, start, end, N)",
          "distance": 0.29822713136672974
        },
        {
          "category": "performance",
          "content": "For loops WITHOUT early exit, all approaches (simple loop, #pragma unroll, ILP_FOR) produce identica...",
          "distance": 0.3309122920036316
        }
      ]
    },
    {
      "id": "basic_002",
      "category": "syntax",
      "difficulty": "easy",
      "question": "Do I need a semicolon after ILP_END?",
      "score": 0.5,
      "details": {
        "rating": "partial",
        "overall_score": 0.75,
        "category_score": 0.5,
        "symbol_score": 1.0,
        "retrieved_categories": [
          "usage_patterns",
          "api_signatures"
        ],
        "expected_categories": [
          "gotchas",
          "api_signatures"
        ],
        "retrieved_symbols": [
          "ILP_END_RETURN",
          "ILP_END",
          "ILP_FOR",
          "ILP_CONTINUE"
        ],
        "expected_symbols": [
          "ILP_END"
        ],
        "category_overlap": 1,
        "symbol_overlap": 1
      },
      "top_retrieved": [
        {
          "category": "usage_patterns",
          "content": "ILP_FOR syntax: ILP_FOR(var, start, end, N) { body } ILP_END; - the semicolon goes after ILP_END. Wh...",
          "distance": 0.2660538852214813
        },
        {
          "category": "api_signatures",
          "content": "Macro: #define ILP_END",
          "distance": 0.36313238739967346
        },
        {
          "category": "api_signatures",
          "content": "Macro: #define ILP_END_RETURN",
          "distance": 0.42054784297943115
        }
      ]
    },
    {
      "id": "basic_003",
      "category": "control_flow",
      "difficulty": "medium",
      "question": "What's the difference between ILP_BREAK and ILP_RETURN?",
      "score": 1.0,
      "details": {
        "rating": "perfect",
        "overall_score": 1.0,
        "category_score": 1.0,
        "symbol_score": 1.0,
        "retrieved_categories": [
          "gotchas",
          "api_signatures",
          "semantics"
        ],
        "expected_categories": [
          "semantics",
          "gotchas"
        ],
        "retrieved_symbols": [
          "ILP_RETURN",
          "ILP_END",
          "ILP_END_RETURN",
          "ILP_CONTINUE",
          "ILP_BREAK"
        ],
        "expected_symbols": [
          "ILP_BREAK",
          "ILP_RETURN",
          "ILP_END_RETURN"
        ],
        "category_overlap": 2,
        "symbol_overlap": 3
      },
      "top_retrieved": [
        {
          "category": "semantics",
          "content": "ILP_BREAK exits the loop, ILP_RETURN(x) exits the enclosing function and returns x. Common mistake: ...",
          "distance": 0.260162889957428
        },
        {
          "category": "gotchas",
          "content": "ILP_END_RETURN must be used instead of ILP_END when ILP_RETURN appears in the loop body. Using ILP_E...",
          "distance": 0.2747296690940857
        },
        {
          "category": "semantics",
          "content": "ILP_BREAK and ILP_CONTINUE use 'return' from the body lambda, not actual break/continue or goto. ILP...",
          "distance": 0.2807583808898926
        }
      ]
    },
    {
      "id": "intermediate_001",
      "category": "debugging",
      "difficulty": "medium",
      "question": "How do I debug my ILP_FOR loop with gdb?",
      "score": 0.5,
      "details": {
        "rating": "partial",
        "overall_score": 0.75,
        "category_score": 0.5,
        "symbol_score": 1.0,
        "retrieved_categories": [
          "usage_patterns",
          "api_signatures"
        ],
        "expected_categories": [
          "usage_patterns",
          "compiler"
        ],
        "retrieved_symbols": [
          "ILP_FOR_RANGE",
          "ILP_FOR",
          "ILP_FOR_T",
          "ILP_MODE_SIMPLE",
          "ILP_FOR_AUTO"
        ],
        "expected_symbols": [
          "ILP_MODE_SIMPLE"
        ],
        "category_overlap": 1,
        "symbol_overlap": 1
      },
      "top_retrieved": [
        {
          "category": "api_signatures",
          "content": "Macro: #define ILP_FOR(loop_var_decl, start, end, N)",
          "distance": 0.3415226340293884
        },
        {
          "category": "api_signatures",
          "content": "Macro: #define ILP_FOR_T(type, loop_var_decl, start, end, N)",
          "distance": 0.38003379106521606
        },
        {
          "category": "api_signatures",
          "content": "Macro: #define ILP_FOR_RANGE(loop_var_decl, range, N)",
          "distance": 0.3937359154224396
        }
      ]
    },
    {
      "id": "intermediate_002",
      "category": "ranges",
      "difficulty": "medium",
      "question": "What type should I use for the loop variable in ILP_FOR_RANGE?",
      "score": 1.0,
      "details": {
        "rating": "perfect",
        "overall_score": 1.0,
        "category_score": 1.0,
        "symbol_score": 1.0,
        "retrieved_categories": [
          "usage_patterns",
          "api_signatures"
        ],
        "expected_categories": [
          "usage_patterns"
        ],
        "retrieved_symbols": [
          "ILP_FOR_RANGE",
          "ILP_FOR",
          "ILP_FOR_RANGE_T_AUTO",
          "ILP_FOR_RANGE_T",
          "ILP_FOR_RANGE_AUTO"
        ],
        "expected_symbols": [
          "ILP_FOR_RANGE"
        ],
        "category_overlap": 1,
        "symbol_overlap": 1
      },
      "top_retrieved": [
        {
          "category": "api_signatures",
          "content": "Macro: #define ILP_FOR_RANGE_T(type, loop_var_decl, range, N)",
          "distance": 0.19156242907047272
        },
        {
          "category": "api_signatures",
          "content": "Macro: #define ILP_FOR_RANGE(loop_var_decl, range, N)",
          "distance": 0.20134609937667847
        },
        {
          "category": "api_signatures",
          "content": "Macro: #define ILP_FOR_RANGE_AUTO(loop_var_decl, range, loop_type, element_type)",
          "distance": 0.215444415807724
        }
      ]
    },
    {
      "id": "intermediate_003",
      "category": "iteration_semantics",
      "difficulty": "medium",
      "question": "If my range is 0 to 10, does ILP_FOR iterate 10 or 11 times?",
      "score": 1.0,
      "details": {
        "rating": "perfect",
        "overall_score": 1.0,
        "category_score": 1.0,
        "symbol_score": 1.0,
        "retrieved_categories": [
          "usage_patterns",
          "gotchas",
          "api_signatures",
          "semantics"
        ],
        "expected_categories": [
          "gotchas",
          "semantics"
        ],
        "retrieved_symbols": [
          "ILP_FOR_RANGE_T",
          "ILP_FOR_RANGE",
          "ILP_FOR"
        ],
        "expected_symbols": [
          "ILP_FOR"
        ],
        "category_overlap": 2,
        "symbol_overlap": 1
      },
      "top_retrieved": [
        {
          "category": "gotchas",
          "content": "ILP_FOR uses exclusive end like Python range(): ILP_FOR(auto i, 0, 10, 4) iterates i=0,1,...,9 (10 i...",
          "distance": 0.27862170338630676
        },
        {
          "category": "api_signatures",
          "content": "Macro: #define ILP_FOR_RANGE(loop_var_decl, range, N)",
          "distance": 0.3285643458366394
        },
        {
          "category": "usage_patterns",
          "content": "Negative ranges work correctly: ILP_FOR(auto i, -5, 5, 4) iterates through -5,-4,-3,-2,-1,0,1,2,3,4....",
          "distance": 0.33147093653678894
        }
      ]
    },
    {
      "id": "advanced_001",
      "category": "performance",
      "difficulty": "hard",
      "question": "Why doesn't #pragma unroll work well for loops with break?",
      "score": 1.0,
      "details": {
        "rating": "perfect",
        "overall_score": 1.0,
        "category_score": 1.0,
        "symbol_score": 1.0,
        "retrieved_categories": [
          "antipatterns",
          "performance",
          "semantics"
        ],
        "expected_categories": [
          "performance"
        ],
        "retrieved_symbols": [
          "SCEV",
          "pragma_unroll",
          "ILP_FOR",
          "assembly"
        ],
        "expected_symbols": [
          "pragma_unroll",
          "SCEV"
        ],
        "category_overlap": 1,
        "symbol_overlap": 2
      },
      "top_retrieved": [
        {
          "category": "performance",
          "content": "#pragma unroll is insufficient for early exit loops because SCEV (Scalar Evolution) cannot determine...",
          "distance": 0.37909135222435
        },
        {
          "category": "performance",
          "content": "Assembly analysis: #pragma unroll generates ~6 instructions per element (load, compare, bounds check...",
          "distance": 0.44333770871162415
        },
        {
          "category": "performance",
          "content": "ILP_FOR provides ~1.5x speedup over #pragma unroll for early exit loops by avoiding per-iteration bo...",
          "distance": 0.45044365525245667
        }
      ]
    },
    {
      "id": "advanced_002",
      "category": "looptype_selection",
      "difficulty": "hard",
      "question": "My loop has break and also does acc += data[i] * weight[i]. Which LoopType should I use?",
      "score": 1.0,
      "details": {
        "rating": "perfect",
        "overall_score": 0.8333333333333333,
        "category_score": 1.0,
        "symbol_score": 0.6666666666666666,
        "retrieved_categories": [
          "usage_patterns",
          "gotchas"
        ],
        "expected_categories": [
          "usage_patterns"
        ],
        "retrieved_symbols": [
          "Sum",
          "ILP_FOR_RANGE",
          "ILP_FOR",
          "LoopType",
          "ILP_CONTINUE",
          "ILP_BREAK",
          "DotProduct",
          "Multiply",
          "ILP_FOR_AUTO"
        ],
        "expected_symbols": [
          "LoopType",
          "Search",
          "DotProduct"
        ],
        "category_overlap": 1,
        "symbol_overlap": 2
      },
      "top_retrieved": [
        {
          "category": "usage_patterns",
          "content": "Empty loop body is valid and doesn't crash. ILP_FOR(auto i, 0, 100, 4) { (void)i; } ILP_END; - this ...",
          "distance": 0.48797476291656494
        },
        {
          "category": "usage_patterns",
          "content": "For index-based loops (ILP_FOR), use 'auto' for the loop variable since indices are just integers. F...",
          "distance": 0.49541735649108887
        },
        {
          "category": "usage_patterns",
          "content": "Mixed operations in loop: pick LoopType for the bottleneck operation (slowest one on the critical pa...",
          "distance": 0.5036198496818542
        }
      ]
    },
    {
      "id": "advanced_003",
      "category": "nested_restrictions",
      "difficulty": "hard",
      "question": "Can I use ILP_BREAK inside a nested for loop within my ILP_FOR body?",
      "score": 1.0,
      "details": {
        "rating": "perfect",
        "overall_score": 1.0,
        "category_score": 1.0,
        "symbol_score": 1.0,
        "retrieved_categories": [
          "usage_patterns",
          "gotchas",
          "api_signatures",
          "semantics"
        ],
        "expected_categories": [
          "gotchas"
        ],
        "retrieved_symbols": [
          "ILP_END",
          "ILP_FOR",
          "ILP_CONTINUE",
          "ILP_BREAK"
        ],
        "expected_symbols": [
          "ILP_BREAK",
          "ILP_CONTINUE"
        ],
        "category_overlap": 1,
        "symbol_overlap": 2
      },
      "top_retrieved": [
        {
          "category": "gotchas",
          "content": "ILP_BREAK and ILP_CONTINUE cannot be used inside nested for/while loops within the ILP_FOR body. The...",
          "distance": 0.1557067334651947
        },
        {
          "category": "usage_patterns",
          "content": "Nested ILP_FOR loops are fully supported up to 6+ levels deep. Each nested loop needs its own ILP_EN...",
          "distance": 0.3047860860824585
        },
        {
          "category": "api_signatures",
          "content": "Macro: #define ILP_BREAK",
          "distance": 0.31512194871902466
        }
      ]
    },
    {
      "id": "edge_001",
      "category": "edge_cases",
      "difficulty": "medium",
      "question": "What happens if I do ILP_FOR(auto i, 10, 0, 4)?",
      "score": 1.0,
      "details": {
        "rating": "perfect",
        "overall_score": 1.0,
        "category_score": 1.0,
        "symbol_score": 1.0,
        "retrieved_categories": [
          "usage_patterns",
          "gotchas",
          "semantics"
        ],
        "expected_categories": [
          "semantics"
        ],
        "retrieved_symbols": [
          "ILP_FOR"
        ],
        "expected_symbols": [
          "ILP_FOR"
        ],
        "category_overlap": 1,
        "symbol_overlap": 1
      },
      "top_retrieved": [
        {
          "category": "usage_patterns",
          "content": "Negative ranges work correctly: ILP_FOR(auto i, -5, 5, 4) iterates through -5,-4,-3,-2,-1,0,1,2,3,4....",
          "distance": 0.3163698613643646
        },
        {
          "category": "gotchas",
          "content": "ILP_FOR uses exclusive end like Python range(): ILP_FOR(auto i, 0, 10, 4) iterates i=0,1,...,9 (10 i...",
          "distance": 0.3617386221885681
        },
        {
          "category": "semantics",
          "content": "Inverted range (start > end) produces zero iterations safely. ILP_FOR(auto i, 10, 0, 4) executes 0 t...",
          "distance": 0.36764755845069885
        }
      ]
    },
    {
      "id": "compiler_001",
      "category": "cpu_targeting",
      "difficulty": "easy",
      "question": "How do I target Zen5 architecture?",
      "score": 1.0,
      "details": {
        "rating": "perfect",
        "overall_score": 1.0,
        "category_score": 1.0,
        "symbol_score": 1.0,
        "retrieved_categories": [
          "compiler",
          "performance",
          "usage_patterns",
          "gotchas"
        ],
        "expected_categories": [
          "compiler"
        ],
        "retrieved_symbols": [
          "ILP_CPU_APPLE_M1",
          "optimal_N",
          "ILP_FOR",
          "Godbolt",
          "TPC",
          "ilp_for.hpp",
          "assembly",
          "cpu_profiles",
          "Latency",
          "ILP_CPU_ZEN5",
          "ILP_CPU_SKYLAKE"
        ],
        "expected_symbols": [
          "ILP_CPU_ZEN5"
        ],
        "category_overlap": 1,
        "symbol_overlap": 1
      },
      "top_retrieved": [
        {
          "category": "compiler",
          "content": "Target specific CPU architectures with -DILP_CPU_SKYLAKE, -DILP_CPU_ALDERLAKE, -DILP_CPU_APPLE_M1, o...",
          "distance": 0.6646304130554199
        },
        {
          "category": "gotchas",
          "content": "C++20 is required. ILP_FOR is header-only - just #include <ilp_for.hpp>. No linking required.",
          "distance": 0.7427681684494019
        },
        {
          "category": "gotchas",
          "content": "Unroll factor N > 16 triggers a deprecation warning at compile time: 'N > 16 is likely counterproduc...",
          "distance": 0.7815566062927246
        }
      ]
    },
    {
      "id": "assembly_001",
      "category": "assembly_understanding",
      "difficulty": "hard",
      "question": "How many instructions per element does ILP_FOR generate compared to pragma unroll?",
      "score": 1.0,
      "details": {
        "rating": "perfect",
        "overall_score": 1.0,
        "category_score": 1.0,
        "symbol_score": 1.0,
        "retrieved_categories": [
          "antipatterns",
          "performance",
          "semantics"
        ],
        "expected_categories": [
          "performance"
        ],
        "retrieved_symbols": [
          "SCEV",
          "pragma_unroll",
          "ILP_FOR",
          "assembly"
        ],
        "expected_symbols": [
          "pragma_unroll",
          "assembly"
        ],
        "category_overlap": 1,
        "symbol_overlap": 2
      },
      "top_retrieved": [
        {
          "category": "performance",
          "content": "Assembly analysis: #pragma unroll generates ~6 instructions per element (load, compare, bounds check...",
          "distance": 0.12454649806022644
        },
        {
          "category": "performance",
          "content": "ILP_FOR provides ~1.5x speedup over #pragma unroll for early exit loops by avoiding per-iteration bo...",
          "distance": 0.2333730161190033
        },
        {
          "category": "semantics",
          "content": "ILP_FOR expands to a main loop processing N elements at a time with a single bounds check, plus a re...",
          "distance": 0.29190537333488464
        }
      ]
    }
  ]
}