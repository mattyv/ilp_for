{
  "version": "1.0",
  "description": "Code generation evaluation test suite for ilp_for RAG knowledge base",
  "test_cases": [
    {
      "id": "codegen_001",
      "category": "early_exit_break",
      "difficulty": "easy",
      "task_description": "Write a function 'count_until_error' that takes a vector<int> and counts elements until encountering a negative number. Use ILP_FOR with early exit. Return the count of valid elements processed.",
      "function_signature": "int count_until_error(const std::vector<int>& data)",
      "test_cases": [
        {"input": {"data": [5, 10, 15, -1, 20, 25]}, "expected": 3},
        {"input": {"data": [1, 2, 3, 4, 5]}, "expected": 5},
        {"input": {"data": [-1, 5, 10]}, "expected": 0},
        {"input": {"data": []}, "expected": 0}
      ],
      "required_knowledge": [
        "ILP_BREAK exits the loop",
        "ILP_BREAK requires ILP_END not ILP_END_RETURN",
        "Accumulator pattern with early exit"
      ],
      "common_mistakes": [
        "Using ILP_END_RETURN instead of ILP_END",
        "Using regular break instead of ILP_BREAK",
        "Not initializing accumulator"
      ],
      "evaluation_checks": {
        "must_contain": ["ILP_FOR", "ILP_BREAK", "ILP_END;"],
        "must_not_contain": ["ILP_END_RETURN", "ILP_RETURN"],
        "compilation_flags": ["-std=c++20", "-O3", "-I.."]
      }
    },
    {
      "id": "codegen_002",
      "category": "debug_mode",
      "difficulty": "easy",
      "task_description": "Write a function 'sum_values' that sums all elements in a vector<int> using ILP_FOR. Include a comment explaining how to compile this for debugging with gdb.",
      "function_signature": "int sum_values(const std::vector<int>& data)",
      "test_cases": [
        {"input": {"data": [1, 2, 3, 4, 5]}, "expected": 15},
        {"input": {"data": [10, 20, 30]}, "expected": 60},
        {"input": {"data": []}, "expected": 0}
      ],
      "required_knowledge": [
        "ILP_FOR basic usage",
        "Compile with -DILP_MODE_SIMPLE -O0 -g for debugging"
      ],
      "common_mistakes": [
        "Not mentioning -DILP_MODE_SIMPLE flag",
        "Not understanding debug mode purpose"
      ],
      "evaluation_checks": {
        "must_contain": ["ILP_FOR", "ILP_END;"],
        "must_not_contain": ["ILP_BREAK", "ILP_RETURN"],
        "comment_must_mention": ["DILP_MODE_SIMPLE", "debug"],
        "compilation_flags": ["-std=c++20", "-O3", "-I.."]
      }
    },
    {
      "id": "codegen_003",
      "category": "early_exit_return",
      "difficulty": "medium",
      "task_description": "Write a function 'find_index' that takes a vector<int> and target int, returns the index of the first occurrence using ILP_FOR, or -1 if not found.",
      "function_signature": "int find_index(const std::vector<int>& data, int target)",
      "test_cases": [
        {"input": {"data": [10, 20, 30, 40], "target": 30}, "expected": 2},
        {"input": {"data": [10, 20, 30, 40], "target": 99}, "expected": -1},
        {"input": {"data": [], "target": 5}, "expected": -1},
        {"input": {"data": [5, 5, 5], "target": 5}, "expected": 0}
      ],
      "required_knowledge": [
        "ILP_RETURN(x) exits function with return value",
        "Must use ILP_END_RETURN not ILP_END when ILP_RETURN in body"
      ],
      "common_mistakes": [
        "Using ILP_END instead of ILP_END_RETURN (won't compile)",
        "Using ILP_BREAK instead of ILP_RETURN (wrong semantics)",
        "Forgetting to return -1 after loop"
      ],
      "evaluation_checks": {
        "must_contain": ["ILP_RETURN", "ILP_END_RETURN"],
        "must_not_contain": ["ILP_END;"],
        "compilation_flags": ["-std=c++20", "-O3", "-I.."]
      }
    },
    {
      "id": "codegen_004",
      "category": "nested_loops",
      "difficulty": "medium",
      "task_description": "Write a function 'count_pairs_below_sum' that counts pairs (i,j) where i < j and data[i] + data[j] < threshold. Use nested ILP_FOR loops with triangular iteration (inner loop depends on outer variable).",
      "function_signature": "int count_pairs_below_sum(const std::vector<int>& data, int threshold)",
      "test_cases": [
        {"input": {"data": [1, 2, 3, 4], "threshold": 5}, "expected": 3},
        {"input": {"data": [10, 20, 30], "threshold": 25}, "expected": 0},
        {"input": {"data": [1, 1, 1, 1], "threshold": 3}, "expected": 6}
      ],
      "required_knowledge": [
        "Nested ILP_FOR loops each need own ILP_END",
        "Inner loop can depend on outer loop variable",
        "Triangular iteration pattern"
      ],
      "common_mistakes": [
        "Only one ILP_END for both loops",
        "Not understanding i < j constraint",
        "Wrong loop bounds for inner loop"
      ],
      "evaluation_checks": {
        "must_contain": ["ILP_FOR", "ILP_END;"],
        "must_contain_count": {"ILP_FOR": 2, "ILP_END;": 2},
        "compilation_flags": ["-std=c++20", "-O3", "-I.."]
      }
    },
    {
      "id": "codegen_005",
      "category": "range_loop",
      "difficulty": "medium",
      "task_description": "Write a function 'uppercase_strings' that takes a vector<string>& and converts all strings to uppercase in-place using ILP_FOR_RANGE. Must avoid copying strings.",
      "function_signature": "void uppercase_strings(std::vector<std::string>& data)",
      "test_cases": [
        {"input": {"data": ["hello", "world"]}, "expected": ["HELLO", "WORLD"]},
        {"input": {"data": ["abc", "def", "ghi"]}, "expected": ["ABC", "DEF", "GHI"]},
        {"input": {"data": []}, "expected": []}
      ],
      "required_knowledge": [
        "ILP_FOR_RANGE syntax",
        "Use auto&& to avoid copying elements",
        "Reference semantics for in-place modification"
      ],
      "common_mistakes": [
        "Using auto instead of auto&& (copies strings)",
        "Using ILP_FOR instead of ILP_FOR_RANGE",
        "Not modifying in-place"
      ],
      "evaluation_checks": {
        "must_contain": ["ILP_FOR_RANGE", "auto&&", "ILP_END;"],
        "must_not_contain": ["ILP_FOR("],
        "compilation_flags": ["-std=c++20", "-O3", "-I.."]
      }
    },
    {
      "id": "codegen_006",
      "category": "looptype_selection",
      "difficulty": "hard",
      "task_description": "Write a function 'find_weighted_sum' that computes sum of data[i] * weights[i] but stops early if any weight is negative. Must use ILP_FOR_AUTO with the correct LoopType. Return the partial sum.",
      "function_signature": "double find_weighted_sum(const std::vector<double>& data, const std::vector<double>& weights)",
      "test_cases": [
        {"input": {"data": [1.0, 2.0, 3.0, 4.0], "weights": [2.0, 3.0, -1.0, 5.0]}, "expected": 8.0},
        {"input": {"data": [1.0, 2.0, 3.0], "weights": [1.0, 1.0, 1.0]}, "expected": 6.0},
        {"input": {"data": [], "weights": []}, "expected": 0.0}
      ],
      "required_knowledge": [
        "Early exit always dominates - use LoopType::Search regardless of other operations",
        "ILP_FOR_AUTO syntax with LoopType",
        "Loop with break AND accumulation uses Search not DotProduct"
      ],
      "common_mistakes": [
        "Using LoopType::DotProduct because of multiplication (wrong - early exit dominates)",
        "Using manual N instead of _AUTO",
        "Not understanding Search is for early exit"
      ],
      "evaluation_checks": {
        "must_contain": ["ILP_FOR_AUTO", "Search", "ILP_BREAK", "ILP_END;"],
        "must_not_contain": ["DotProduct", "Sum"],
        "compilation_flags": ["-std=c++20", "-O3", "-I.."]
      }
    },
    {
      "id": "codegen_007",
      "category": "range_semantics",
      "difficulty": "medium",
      "task_description": "Write a function 'count_in_range' that counts how many elements are in range [min_val, max_val] inclusive. The loop should iterate from start=0 to end=10 using ILP_FOR. Return the count.",
      "function_signature": "int count_in_range(const std::vector<int>& data, int min_val, int max_val)",
      "test_cases": [
        {"input": {"data": [1, 5, 3, 8, 12, 7, 2, 15, 9, 4], "min_val": 5, "max_val": 10}, "expected": 4},
        {"input": {"data": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], "min_val": 0, "max_val": 5}, "expected": 5}
      ],
      "required_knowledge": [
        "ILP_FOR uses exclusive end like Python range()",
        "ILP_FOR(auto i, 0, 10, 4) iterates 0-9 (10 times), not 11 times"
      ],
      "common_mistakes": [
        "Thinking end is inclusive (expecting 11 iterations for 0 to 10)",
        "Off-by-one errors in loop bounds"
      ],
      "evaluation_checks": {
        "must_contain": ["ILP_FOR", "0", "10", "ILP_END;"],
        "must_not_contain": ["11"],
        "compilation_flags": ["-std=c++20", "-O3", "-I.."]
      }
    },
    {
      "id": "codegen_008",
      "category": "continue_pattern",
      "difficulty": "medium",
      "task_description": "Write a function 'sum_positive' that sums all positive integers in a vector, skipping zeros and negative numbers using ILP_CONTINUE. Use ILP_FOR.",
      "function_signature": "int sum_positive(const std::vector<int>& data)",
      "test_cases": [
        {"input": {"data": [1, -5, 0, 10, -2, 15]}, "expected": 26},
        {"input": {"data": [5, 10, 15]}, "expected": 30},
        {"input": {"data": [-1, -2, -3, 0]}, "expected": 0}
      ],
      "required_knowledge": [
        "ILP_CONTINUE skips to next iteration",
        "ILP_CONTINUE uses ILP_END not ILP_END_RETURN",
        "Continue pattern for conditional processing"
      ],
      "common_mistakes": [
        "Using regular continue instead of ILP_CONTINUE",
        "Using ILP_BREAK instead of ILP_CONTINUE",
        "Wrong ILP_END variant"
      ],
      "evaluation_checks": {
        "must_contain": ["ILP_FOR", "ILP_CONTINUE", "ILP_END;"],
        "must_not_contain": ["ILP_END_RETURN", "ILP_BREAK"],
        "compilation_flags": ["-std=c++20", "-O3", "-I.."]
      }
    }
  ]
}
