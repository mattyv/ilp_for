{
  "version": "1.0",
  "description": "RAG evaluation test suite for ilp_for knowledge base",
  "test_cases": [
    {
      "id": "basic_001",
      "category": "when_to_use",
      "question": "When should I use ILP_FOR instead of a regular for loop?",
      "expected_answer": "Only when your loop has early exit (break, continue, or return). For simple loops without early exit, regular loops with auto-vectorization are often equivalent or better.",
      "expected_rag_categories": ["antipatterns", "usage_patterns"],
      "expected_symbols": ["ILP_FOR"],
      "difficulty": "easy"
    },
    {
      "id": "basic_002",
      "category": "syntax",
      "question": "Do I need a semicolon after ILP_END?",
      "expected_answer": "Yes, you must put a semicolon after ILP_END. The syntax is: ILP_FOR(...) { body } ILP_END;",
      "expected_rag_categories": ["gotchas", "api_signatures"],
      "expected_symbols": ["ILP_END"],
      "difficulty": "easy"
    },
    {
      "id": "basic_003",
      "category": "control_flow",
      "question": "What's the difference between ILP_BREAK and ILP_RETURN?",
      "expected_answer": "ILP_BREAK exits the loop only. ILP_RETURN(x) exits the enclosing function and returns x. If you use ILP_RETURN, you must use ILP_END_RETURN instead of ILP_END.",
      "expected_rag_categories": ["semantics", "gotchas"],
      "expected_symbols": ["ILP_BREAK", "ILP_RETURN", "ILP_END_RETURN"],
      "difficulty": "medium"
    },
    {
      "id": "intermediate_001",
      "category": "debugging",
      "question": "How do I debug my ILP_FOR loop with gdb?",
      "expected_answer": "Compile with -DILP_MODE_SIMPLE -O0 -g to turn ILP macros into simple for loops. This makes the code debuggable while preserving loop semantics.",
      "expected_rag_categories": ["usage_patterns", "compiler"],
      "expected_symbols": ["ILP_MODE_SIMPLE"],
      "difficulty": "medium"
    },
    {
      "id": "intermediate_002",
      "category": "ranges",
      "question": "What type should I use for the loop variable in ILP_FOR_RANGE?",
      "expected_answer": "Use auto&& to avoid copying elements. Example: ILP_FOR_RANGE(auto&& val, container, 4)",
      "expected_rag_categories": ["usage_patterns"],
      "expected_symbols": ["ILP_FOR_RANGE"],
      "difficulty": "medium"
    },
    {
      "id": "intermediate_003",
      "category": "iteration_semantics",
      "question": "If my range is 0 to 10, does ILP_FOR iterate 10 or 11 times?",
      "expected_answer": "10 times. ILP_FOR uses exclusive end like Python range(). ILP_FOR(auto i, 0, 10, 4) iterates i=0,1,...,9.",
      "expected_rag_categories": ["gotchas", "semantics"],
      "expected_symbols": ["ILP_FOR"],
      "difficulty": "medium"
    },
    {
      "id": "advanced_001",
      "category": "performance",
      "question": "Why doesn't #pragma unroll work well for loops with break?",
      "expected_answer": "SCEV (Scalar Evolution) cannot determine trip count for loops with break. Compilers insert bounds checks after EACH unrolled element, negating the unroll benefit. ILP_FOR uses a main loop + remainder pattern that checks bounds only once per block.",
      "expected_rag_categories": ["performance"],
      "expected_symbols": ["pragma_unroll", "SCEV"],
      "difficulty": "hard"
    },
    {
      "id": "advanced_002",
      "category": "looptype_selection",
      "question": "My loop has break and also does acc += data[i] * weight[i]. Which LoopType should I use?",
      "expected_answer": "Use Search. Early exit always dominates - use Search regardless of other operations if the loop has ILP_BREAK or ILP_RETURN.",
      "expected_rag_categories": ["usage_patterns"],
      "expected_symbols": ["LoopType", "Search", "DotProduct"],
      "difficulty": "hard"
    },
    {
      "id": "advanced_003",
      "category": "nested_restrictions",
      "question": "Can I use ILP_BREAK inside a nested for loop within my ILP_FOR body?",
      "expected_answer": "No. ILP_BREAK uses return from the body lambda, so it would break from the wrong scope. Only use ILP_BREAK/ILP_CONTINUE at the ILP_FOR body level, not inside inner loops.",
      "expected_rag_categories": ["gotchas"],
      "expected_symbols": ["ILP_BREAK", "ILP_CONTINUE"],
      "difficulty": "hard"
    },
    {
      "id": "edge_001",
      "category": "edge_cases",
      "question": "What happens if I do ILP_FOR(auto i, 10, 0, 4)?",
      "expected_answer": "Inverted range (start > end) produces zero iterations safely. No undefined behavior, no crash, just zero iterations.",
      "expected_rag_categories": ["semantics"],
      "expected_symbols": ["ILP_FOR"],
      "difficulty": "medium"
    },
    {
      "id": "compiler_001",
      "category": "cpu_targeting",
      "question": "How do I target Zen5 architecture?",
      "expected_answer": "Compile with -DILP_CPU_ZEN5 flag. This uses architecture-specific optimal N values from cpu_profiles/.",
      "expected_rag_categories": ["compiler"],
      "expected_symbols": ["ILP_CPU_ZEN5"],
      "difficulty": "easy"
    },
    {
      "id": "assembly_001",
      "category": "assembly_understanding",
      "question": "How many instructions per element does ILP_FOR generate compared to pragma unroll?",
      "expected_answer": "ILP_FOR generates ~4 instructions per element (load, compare, conditional branch). Pragma unroll generates ~6 instructions per element (load, compare, bounds check, conditional branch Ã— 2).",
      "expected_rag_categories": ["performance"],
      "expected_symbols": ["pragma_unroll", "assembly"],
      "difficulty": "hard"
    }
  ],
  "evaluation_metrics": {
    "context_retrieval": {
      "description": "Did the RAG retrieve relevant knowledge?",
      "scoring": {
        "perfect": "Retrieved all expected categories",
        "partial": "Retrieved some expected categories",
        "miss": "Retrieved no expected categories"
      }
    },
    "answer_correctness": {
      "description": "Did the LLM give a correct answer with the retrieved context?",
      "scoring": {
        "correct": "Answer matches expected_answer semantically",
        "partial": "Answer is partially correct",
        "incorrect": "Answer is wrong or incomplete"
      }
    },
    "answer_faithfulness": {
      "description": "Is the answer grounded in retrieved context?",
      "scoring": {
        "faithful": "All claims traceable to retrieved knowledge",
        "hallucination": "Contains claims not in retrieved knowledge"
      }
    }
  }
}
