version = "1.0"
source = "unknown"
extracted_at = "2025-12-30T05:54:50.401204+00:00"

[[axioms]]
id = "ilp_for_macro_precondition_loop_var_type"
content = '''The loop_var_decl parameter must be a valid variable declaration without initializer (e.g., 'int i' or 'size_t idx') that can be used as a lambda parameter'''
formal_spec = '''isValidParameterDecl(loop_var_decl) && !hasInitializer(loop_var_decl)'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "ILP_FOR"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_FOR(loop_var_decl, start, end, N)'''
axiom_type = "precondition"
on_violation = '''Compilation error due to invalid lambda parameter syntax'''
depends_on = ['cpp20_basic_life_vacuous_initialization_def_7c4e5d6a', 'cpp20_dcl_init_list_no_applicable_rule_a4b5c6d7']
reviewed = true

[[axioms]]
id = "ilp_for_macro_precondition_n_template_constant"
content = '''The N parameter must be a compile-time constant expression suitable for template argument, representing the unroll factor'''
formal_spec = '''isConstexpr(N) && N > 0'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "ILP_FOR"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_FOR(loop_var_decl, start, end, N)'''
axiom_type = "precondition"
on_violation = '''Compilation error in template instantiation of ::ilp::for_loop<N>'''
depends_on = ['cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2', 'cpp20_temp_expl_spec_unspecialized_enclosing_template_param_a7b8c9d0', 'for_loop_range_typed_precond_n_valid_offset_b3c4d5e6']
reviewed = true

[[axioms]]
id = "ilp_for_macro_precondition_range_validity"
content = '''The start and end parameters must be valid integral or iterator-like values where start <= end, defining a valid loop range'''
formal_spec = '''typeof(start) == typeof(end) && start <= end'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "ILP_FOR"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_FOR(loop_var_decl, start, end, N)'''
axiom_type = "precondition"
on_violation = '''Undefined behavior or incorrect loop behavior if range is invalid'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4', 'for_loop_range_typed_impl_precond_iterator_random_access_e5f6a7b8', 'for_loop_range_untyped_impl_precond_iterator_random_access_b2c3d4e5', 'for_loop_range_impl_anti_pattern_non_random_access_e5f6a7b8']
reviewed = true

[[axioms]]
id = "ilp_for_macro_effect_single_evaluation"
content = '''The start and end arguments are captured by reference in the lambda and evaluated exactly once when ::ilp::for_loop is called, protecting against multiple evaluation side effects'''
formal_spec = '''eval_count(start) == 1 && eval_count(end) == 1 && capture_mode(start) == by_reference && capture_mode(end) == by_reference'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "ILP_FOR"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_FOR(loop_var_decl, start, end, N)'''
axiom_type = "effect"
on_violation = '''N/A - this is the guaranteed behavior'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "ilp_for_macro_effect_lambda_body_deferred"
content = '''The macro expansion creates an immediately-invoked lambda expression (IIFE) that returns ::ilp::ForResult, with the actual loop body provided after macro invocation'''
formal_spec = '''expansionPattern(ILP_FOR) == IIFE && returnType == ::ilp::ForResult'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_FOR"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_FOR(loop_var_decl, start, end, N)'''
axiom_type = "effect"
on_violation = '''N/A - this is the guaranteed behavior'''
depends_on = ['cpp20_expr_prim_lambda_capture_scope_restriction_d2e6f8a9']
reviewed = true

[[axioms]]
id = "ilp_for_macro_constraint_incomplete_expansion"
content = '''This macro must be used with a companion macro or syntax that closes the lambda body and completes the if statement, as the expansion ends with an open lambda parameter list'''
formal_spec = '''requires_completion(ILP_FOR) && companion_macro_required'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_FOR"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_FOR(loop_var_decl, start, end, N)'''
axiom_type = "constraint"
on_violation = '''Compilation error due to incomplete lambda and if-statement syntax'''
depends_on = ['cpp20_expr_prim_lambda_capture_scope_restriction_d2e6f8a9']
reviewed = true

[[axioms]]
id = "ilp_for_macro_postcondition_context_available"
content = '''After macro expansion, the identifiers __ilp_ctx, __ilp_ctrl, and the loop variable are available in the scope following the macro, with __ilp_ctrl providing loop control operations'''
formal_spec = '''in_scope(__ilp_ctx) && in_scope(__ilp_ctrl) && typeof(__ilp_ctrl) == ::ilp::ForCtrl&'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "ILP_FOR"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_FOR(loop_var_decl, start, end, N)'''
axiom_type = "postcondition"
on_violation = '''N/A - this is the guaranteed behavior'''
depends_on = ['cpp20_expr_prim_lambda_capture_scope_restriction_d2e6f8a9']
reviewed = true

[[axioms]]
id = "ilp_for_macro_postcondition_return_value"
content = '''The complete macro expansion produces an if-statement condition that evaluates to a ::ilp::ForResult object stored in __ilp_ret, which must be contextually convertible to bool for the if-statement'''
formal_spec = '''typeof(__ilp_ret) == ::ilp::ForResult && isContextuallyConvertibleToBool(::ilp::ForResult)'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "ILP_FOR"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_FOR(loop_var_decl, start, end, N)'''
axiom_type = "postcondition"
on_violation = '''Compilation error if ::ilp::ForResult is not contextually convertible to bool'''
reviewed = true

[[axioms]]
id = "ilp_for_macro_constraint_reference_capture"
content = '''All external variables used in the loop body are captured by reference ([&]) in both the outer and inner lambdas, allowing modifications to affect the outer scope'''
formal_spec = '''capture_mode(outer_lambda) == by_reference && capture_mode(inner_lambda) == by_reference'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_FOR"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_FOR(loop_var_decl, start, end, N)'''
axiom_type = "constraint"
on_violation = '''N/A - this is the guaranteed behavior, but users must ensure captured variables have valid lifetime'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "ilp_for_macro_anti_pattern_dangling_reference"
content = '''Passing temporary objects as start or end arguments can lead to dangling references since they are captured by reference in the lambda'''
formal_spec = '''∀ arg ∈ {start, end}: isTemporary(arg) → undefined_behavior'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "ILP_FOR"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_FOR(loop_var_decl, start, end, N)'''
axiom_type = "anti_pattern"
on_violation = '''Undefined behavior due to dangling references to destroyed temporaries'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "ilp_for_macro_complexity_template_instantiation"
content = '''Each unique value of N causes a separate template instantiation of ::ilp::for_loop<N>, potentially increasing compile time and code size with multiple different N values'''
formal_spec = '''compile_time_cost(ILP_FOR) ∝ |{distinct N values}| && code_size ∝ |{distinct N values}|'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "ILP_FOR"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_FOR(loop_var_decl, start, end, N)'''
axiom_type = "complexity"
on_violation = '''N/A - this is expected template instantiation behavior'''
depends_on = ['cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2', 'cpp20_temp_expl_spec_unspecialized_enclosing_template_param_a7b8c9d0', 'for_loop_range_typed_precond_n_valid_offset_b3c4d5e6']
reviewed = true

[[axioms]]
id = "ilp_for_macro_effect_no_preprocessing_side_effects"
content = '''Macro expansion performs textual substitution with no side effects at preprocessing time; all evaluation occurs at runtime within the lambda expressions'''
formal_spec = '''preprocessing_side_effects(ILP_FOR) == ∅ && evaluation_time(arguments) == runtime'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_FOR"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_FOR(loop_var_decl, start, end, N)'''
axiom_type = "effect"
on_violation = '''N/A - this is the guaranteed behavior'''
depends_on = ['ilp_cpu_profile_macro_context_independence', 'ilp_n_transform_8_effect_no_side_effects', 'ilp_cpu_profile_macro_no_side_effects', 'ilp_n_divide_4f_macro_effect_no_side_effects']
reviewed = true

[[axioms]]
id = "ilp_for_range_macro_param_eval_multiple"
content = '''The range argument is captured by reference and passed to for_loop_range, which may evaluate it multiple times during iteration; the loop_var_decl is only used once in the lambda parameter declaration'''
formal_spec = '''eval_count(range) >= 1 && eval_count(loop_var_decl) == 1 && eval_count(N) == 1'''
layer = "library"
confidence = 0.85
source_file = ""
source_module = ""
function = "ILP_FOR_RANGE"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_FOR_RANGE(loop_var_decl, range, N)'''
axiom_type = "effect"
on_violation = '''If range has side effects (e.g., i++), behavior may be unexpected as it could be evaluated multiple times during iteration'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "ilp_for_range_macro_lambda_capture"
content = '''All variables from the surrounding scope are captured by reference ([&]) in the outer lambda, making them accessible but potentially causing lifetime issues if the lambda outlives the scope'''
formal_spec = '''∀v ∈ enclosing_scope: accessible(v) && lifetime(__ilp_ret) ⊆ lifetime(v)'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "ILP_FOR_RANGE"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_FOR_RANGE(loop_var_decl, range, N)'''
axiom_type = "effect"
on_violation = '''Dangling references if __ilp_ret is used after the enclosing scope ends'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "ilp_for_range_macro_incomplete_syntax"
content = '''This macro expands to incomplete syntax requiring a user-supplied lambda body followed by ILP_END or similar closing macro; the expansion produces 'if ([[maybe_unused]] auto __ilp_ret = [&]() { ... [&](loop_var_decl, ::ilp::ForCtrl& __ilp_ctrl)' without closing braces'''
formal_spec = '''requires_completion(ILP_FOR_RANGE) && must_follow_by('}); }()) { ... }')'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "ILP_FOR_RANGE"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_FOR_RANGE(loop_var_decl, range, N)'''
axiom_type = "constraint"
on_violation = '''Compilation error due to incomplete syntax if not properly closed'''
depends_on = ['ilp_cpu_profile_macro_context_independence']
reviewed = true

[[axioms]]
id = "ilp_for_range_macro_n_constraint"
content = '''The N parameter must be a compile-time constant integral value suitable as a template argument for for_loop_range<N>'''
formal_spec = '''is_integral_constant_expression(N) && N > 0'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "ILP_FOR_RANGE"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_FOR_RANGE(loop_var_decl, range, N)'''
axiom_type = "constraint"
on_violation = '''Compilation error if N is not a constant expression or template instantiation fails'''
depends_on = ['cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2', 'cpp20_temp_expl_spec_unspecialized_enclosing_template_param_a7b8c9d0', 'for_loop_range_typed_precond_n_valid_offset_b3c4d5e6']
reviewed = true

[[axioms]]
id = "ilp_for_range_macro_range_type_constraint"
content = '''The range argument must be a valid range-like object compatible with ::ilp::for_loop_range<N>, typically supporting iteration or having begin/end'''
formal_spec = '''is_valid_range(range) && compatible_with(range, for_loop_range<N>)'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "ILP_FOR_RANGE"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_FOR_RANGE(loop_var_decl, range, N)'''
axiom_type = "constraint"
on_violation = '''Compilation error if range type is incompatible with for_loop_range template'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4']
reviewed = true

[[axioms]]
id = "ilp_for_range_macro_loop_var_decl_constraint"
content = '''The loop_var_decl must be a valid lambda parameter declaration (e.g., 'int i', 'auto& x', 'const auto& elem') compatible with the iteration variable type produced by for_loop_range'''
formal_spec = '''is_valid_lambda_param_decl(loop_var_decl) && compatible_type(loop_var_decl, iteration_value_type(range))'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "ILP_FOR_RANGE"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_FOR_RANGE(loop_var_decl, range, N)'''
axiom_type = "constraint"
on_violation = '''Compilation error if loop_var_decl syntax is invalid or type is incompatible'''
reviewed = true

[[axioms]]
id = "ilp_for_range_macro_name_collision"
content = '''The macro introduces internal variables __ilp_ret, __ilp_ctx, and __ilp_ctrl into the scope; user code should not define variables with these names to avoid collisions'''
formal_spec = '''∀v ∈ user_scope: v ∉ {__ilp_ret, __ilp_ctx, __ilp_ctrl}'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "ILP_FOR_RANGE"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_FOR_RANGE(loop_var_decl, range, N)'''
axiom_type = "anti_pattern"
on_violation = '''Name collision causing compilation error or shadowing'''
depends_on = ['ilp_cpu_profile_macro_context_independence']
reviewed = true

[[axioms]]
id = "ilp_for_range_macro_if_statement_context"
content = '''The macro expands to an if statement with init-statement, creating a scope where __ilp_ret is valid; the condition is the result of the lambda execution'''
formal_spec = '''expansion_pattern(ILP_FOR_RANGE) == 'if (auto __ilp_ret = lambda()) { ... }' && scope(__ilp_ret) == if_statement_scope'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "ILP_FOR_RANGE"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_FOR_RANGE(loop_var_decl, range, N)'''
axiom_type = "effect"
on_violation = '''N/A - defines the control flow structure'''
depends_on = ['ilp_cpu_profile_macro_context_independence']
reviewed = true

[[axioms]]
id = "ilp_for_range_macro_no_preprocessing_side_effects"
content = '''Macro expansion performs textual substitution with no side effects at preprocessing time; all effects occur at runtime when the expanded code executes'''
formal_spec = '''noSideEffects(preprocessing(ILP_FOR_RANGE)) && allEffects(ILP_FOR_RANGE) occur_at runtime'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_FOR_RANGE"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_FOR_RANGE(loop_var_decl, range, N)'''
axiom_type = "effect"
on_violation = '''N/A - fundamental property of macro expansion'''
depends_on = ['ilp_cpu_profile_macro_context_independence', 'ilp_n_transform_8_effect_no_side_effects', 'ilp_cpu_profile_macro_no_side_effects', 'ilp_n_divide_4f_macro_effect_no_side_effects']
reviewed = true

[[axioms]]
id = "ilp_for_auto_macro_precond_types_9c4a2b1f"
content = '''element_type must be a valid type name; loop_type must be a valid enumerator name in ::ilp::LoopType; loop_var_decl must be a valid variable declaration (type and name or auto name)'''
formal_spec = '''isValidType(element_type) && isEnumerator(::ilp::LoopType::loop_type) && isValidVarDecl(loop_var_decl)'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "ILP_FOR_AUTO"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_FOR_AUTO(loop_var_decl, start, end, loop_type, element_type)'''
axiom_type = "precondition"
on_violation = '''compilation error due to invalid template argument or invalid enumerator access'''
reviewed = true

[[axioms]]
id = "ilp_for_auto_macro_precond_range_8d5e3a2c"
content = '''start and end must be valid expressions compatible with the template parameter requirements of ::ilp::for_loop_auto<element_type, ::ilp::LoopType::loop_type>'''
formal_spec = '''isValidExpr(start) && isValidExpr(end) && compatibleWith(typeof(start), for_loop_auto_param_type) && compatibleWith(typeof(end), for_loop_auto_param_type)'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "ILP_FOR_AUTO"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_FOR_AUTO(loop_var_decl, start, end, loop_type, element_type)'''
axiom_type = "precondition"
on_violation = '''compilation error or incorrect loop behavior'''
depends_on = ['for_loop_typed_constraint_return_type_r_b1c2d3e4', 'cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2', 'cpp20_temp_expl_spec_unspecialized_enclosing_template_param_a7b8c9d0', 'for_loop_range_typed_precond_n_valid_offset_b3c4d5e6']
reviewed = true

[[axioms]]
id = "ilp_for_auto_macro_effect_single_eval_a1b2c3d4"
content = '''start and end arguments are evaluated exactly once due to parenthesization when passed to for_loop_auto; loop_var_decl and the implicit loop body are evaluated per iteration'''
formal_spec = '''eval_count(start) == 1 && eval_count(end) == 1 && eval_count(loop_body) == iteration_count'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "ILP_FOR_AUTO"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_FOR_AUTO(loop_var_decl, start, end, loop_type, element_type)'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by macro structure'''
depends_on = ['ilp_for_auto_macro_param_eval_multiple_a7f3d2e1']
reviewed = true

[[axioms]]
id = "ilp_for_auto_macro_effect_no_expansion_side_effects_5f6e7d8c"
content = '''Macro expansion performs textual substitution with no side effects at preprocessing time; all evaluation occurs at runtime within the expanded code'''
formal_spec = '''sideEffects(macro_expansion(ILP_FOR_AUTO)) == ∅ && evaluationTime(ILP_FOR_AUTO) == runtime'''
layer = "library"
confidence = 0.98
source_file = ""
source_module = ""
function = "ILP_FOR_AUTO"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_FOR_AUTO(loop_var_decl, start, end, loop_type, element_type)'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by preprocessing semantics'''
depends_on = ['ilp_n_transform_8_effect_no_side_effects', 'ilp_cpu_profile_macro_no_side_effects', 'ilp_n_divide_4f_macro_effect_no_side_effects']
reviewed = true

[[axioms]]
id = "ilp_for_auto_macro_postcond_incomplete_statement_2e3f4a5b"
content = '''The macro expansion is an incomplete if-statement that expects a trailing lambda body and closing brace; usage must follow the pattern: ILP_FOR_AUTO(...) { body } ILP_END'''
formal_spec = '''isIncompleteStatement(expand(ILP_FOR_AUTO)) && requiresTrailingLambdaBody() && requiresClosingMacro(ILP_END)'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "ILP_FOR_AUTO"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_FOR_AUTO(loop_var_decl, start, end, loop_type, element_type)'''
axiom_type = "postcondition"
on_violation = '''compilation error due to incomplete if-statement or malformed lambda expression'''
reviewed = true

[[axioms]]
id = "ilp_for_auto_macro_constraint_lambda_capture_7a8b9c0d"
content = '''The macro creates nested lambdas with [&] capture; all variables referenced in start, end, and the loop body must be capturable by reference and must remain valid for the loop duration'''
formal_spec = '''∀v ∈ referenced_vars(start, end, loop_body): isCapturable(v) && lifetime(v) ⊇ lifetime(loop_execution)'''
layer = "library"
confidence = 0.92
source_file = ""
source_module = ""
function = "ILP_FOR_AUTO"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_FOR_AUTO(loop_var_decl, start, end, loop_type, element_type)'''
axiom_type = "constraint"
on_violation = '''undefined behavior if captured references become invalid; compilation error if variables are not capturable'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "ilp_for_auto_macro_constraint_loop_var_shadowing_3c4d5e6f"
content = '''The macro introduces names __ilp_ret, __ilp_ctx, and __ilp_ctrl in the enclosing scope; these names must not conflict with user code'''
formal_spec = '''∀n ∈ {__ilp_ret, __ilp_ctx, __ilp_ctrl}: ¬isDeclared(n, enclosing_scope)'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "ILP_FOR_AUTO"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_FOR_AUTO(loop_var_decl, start, end, loop_type, element_type)'''
axiom_type = "constraint"
on_violation = '''compilation error due to redeclaration or shadowing issues'''
reviewed = true

[[axioms]]
id = "ilp_for_auto_macro_anti_pattern_semicolon_after_brace_1d2e3f4a"
content = '''Do not place a semicolon after the closing brace or after ILP_END; the macro expands to an if-statement that expects the lambda body to complete the statement'''
formal_spec = '''¬hasSemicolon(after(ILP_FOR_AUTO_usage))'''
layer = "library"
confidence = 0.88
source_file = ""
source_module = ""
function = "ILP_FOR_AUTO"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_FOR_AUTO(loop_var_decl, start, end, loop_type, element_type)'''
axiom_type = "anti_pattern"
on_violation = '''compilation error or unexpected control flow due to semicolon creating null statement'''
reviewed = true

[[axioms]]
id = "ilp_for_auto_macro_anti_pattern_side_effects_in_params_5b6c7d8e"
content = '''While start and end are evaluated only once, placing complex expressions with side effects in loop_type or element_type parameters is error-prone as these are used in template contexts'''
formal_spec = '''hasSideEffects(loop_type) ⟹ antipattern && hasSideEffects(element_type) ⟹ antipattern'''
layer = "library"
confidence = 0.85
source_file = ""
source_module = ""
function = "ILP_FOR_AUTO"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_FOR_AUTO(loop_var_decl, start, end, loop_type, element_type)'''
axiom_type = "anti_pattern"
on_violation = '''potential compilation errors or unexpected behavior; loop_type and element_type should be simple type/enum names'''
depends_on = ['cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2', 'cpp20_temp_expl_spec_unspecialized_enclosing_template_param_a7b8c9d0', 'for_loop_range_typed_precond_n_valid_offset_b3c4d5e6']
reviewed = true

[[axioms]]
id = "ilp_for_auto_macro_complexity_lambda_overhead_9e0f1a2b"
content = '''The macro introduces nested lambda expressions which may incur overhead if not inlined; modern compilers typically optimize these away with inlining'''
formal_spec = '''overhead(ILP_FOR_AUTO) = O(1) when inlined, O(call_overhead) otherwise'''
layer = "library"
confidence = 0.8
source_file = ""
source_module = ""
function = "ILP_FOR_AUTO"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_FOR_AUTO(loop_var_decl, start, end, loop_type, element_type)'''
axiom_type = "complexity"
on_violation = '''N/A - performance consideration only'''
reviewed = true

[[axioms]]
id = "ilp_for_range_auto_macro_precond_range_valid"
content = '''The range parameter must be a valid range-like object that can be passed to for_loop_range_auto, with valid begin/end iterators or compatible interface'''
formal_spec = '''requires(range) { ::ilp::for_loop_range_auto<element_type, loop_type>(range, f); }'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "ILP_FOR_RANGE_AUTO"
header = "ilp_for.hpp"
signature = '''ILP_FOR_RANGE_AUTO(loop_var_decl, range, loop_type, element_type)'''
axiom_type = "precondition"
on_violation = '''Compilation error if range is not compatible with for_loop_range_auto template requirements'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4']
reviewed = true

[[axioms]]
id = "ilp_for_range_auto_macro_precond_element_type_valid"
content = '''The element_type parameter must be a valid type name that matches the element type of the range'''
formal_spec = '''is_type(element_type) && compatible(element_type, decltype(*begin(range)))'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "ILP_FOR_RANGE_AUTO"
header = "ilp_for.hpp"
signature = '''ILP_FOR_RANGE_AUTO(loop_var_decl, range, loop_type, element_type)'''
axiom_type = "precondition"
on_violation = '''Compilation error or type mismatch in for_loop_range_auto instantiation'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4']
reviewed = true

[[axioms]]
id = "ilp_for_range_auto_macro_precond_loop_type_valid"
content = '''The loop_type parameter must be a valid enumerator name from ::ilp::LoopType without the enum scope qualifier'''
formal_spec = '''exists(::ilp::LoopType::loop_type)'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "ILP_FOR_RANGE_AUTO"
header = "ilp_for.hpp"
signature = '''ILP_FOR_RANGE_AUTO(loop_var_decl, range, loop_type, element_type)'''
axiom_type = "precondition"
on_violation = '''Compilation error due to invalid scoped enum access'''
reviewed = true

[[axioms]]
id = "ilp_for_range_auto_macro_effect_range_eval_once"
content = '''The range argument is evaluated exactly once when the macro expands, as it is passed directly to the for_loop_range_auto function call within the lambda'''
formal_spec = '''eval_count(range) == 1'''
layer = "library"
confidence = 0.98
source_file = ""
source_module = ""
function = "ILP_FOR_RANGE_AUTO"
header = "ilp_for.hpp"
signature = '''ILP_FOR_RANGE_AUTO(loop_var_decl, range, loop_type, element_type)'''
axiom_type = "effect"
on_violation = '''N/A - single evaluation is guaranteed by macro structure'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4']
reviewed = true

[[axioms]]
id = "ilp_for_range_auto_macro_effect_lambda_capture"
content = '''All variables from the surrounding scope are captured by reference ([&]) in both the outer and inner lambda, allowing the loop body to modify external state'''
formal_spec = '''capture_mode(outer_lambda) == by_reference && capture_mode(inner_lambda) == by_reference'''
layer = "library"
confidence = 0.99
source_file = ""
source_module = ""
function = "ILP_FOR_RANGE_AUTO"
header = "ilp_for.hpp"
signature = '''ILP_FOR_RANGE_AUTO(loop_var_decl, range, loop_type, element_type)'''
axiom_type = "effect"
on_violation = '''N/A - capture is guaranteed by macro definition'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "ilp_for_range_auto_macro_constraint_incomplete_syntax"
content = '''This macro must be followed by a lambda body (braced statement) and terminated with ILP_END macro, as it opens an if statement and lambda parameter list without closing them'''
formal_spec = '''syntax(ILP_FOR_RANGE_AUTO(...)) := ILP_FOR_RANGE_AUTO(...) { body } ILP_END'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_FOR_RANGE_AUTO"
header = "ilp_for.hpp"
signature = '''ILP_FOR_RANGE_AUTO(loop_var_decl, range, loop_type, element_type)'''
axiom_type = "constraint"
on_violation = '''Compilation error due to incomplete syntax - missing lambda body and closing constructs'''
reviewed = true

[[axioms]]
id = "ilp_for_range_auto_macro_constraint_loop_var_decl_syntax"
content = '''The loop_var_decl parameter must be a valid variable declaration including type and name (e.g., 'int i' or 'auto& x'), as it becomes a lambda parameter'''
formal_spec = '''is_valid_parameter_declaration(loop_var_decl)'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "ILP_FOR_RANGE_AUTO"
header = "ilp_for.hpp"
signature = '''ILP_FOR_RANGE_AUTO(loop_var_decl, range, loop_type, element_type)'''
axiom_type = "constraint"
on_violation = '''Compilation error due to invalid lambda parameter syntax'''
reviewed = true

[[axioms]]
id = "ilp_for_range_auto_macro_postcond_ilp_ctrl_available"
content = '''Within the loop body, __ilp_ctrl variable of type ::ilp::ForCtrl& is available and marked [[maybe_unused]] for loop control operations'''
formal_spec = '''in_scope(loop_body, __ilp_ctrl) && type(__ilp_ctrl) == ::ilp::ForCtrl&'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_FOR_RANGE_AUTO"
header = "ilp_for.hpp"
signature = '''ILP_FOR_RANGE_AUTO(loop_var_decl, range, loop_type, element_type)'''
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed by macro expansion'''
reviewed = true

[[axioms]]
id = "ilp_for_range_auto_macro_postcond_ilp_ctx_available"
content = '''The __ilp_ctx variable of type ::ilp::detail::For_Context_USE_ILP_END is created in the outer lambda scope and marked [[maybe_unused]]'''
formal_spec = '''in_scope(outer_lambda, __ilp_ctx) && type(__ilp_ctx) == ::ilp::detail::For_Context_USE_ILP_END'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_FOR_RANGE_AUTO"
header = "ilp_for.hpp"
signature = '''ILP_FOR_RANGE_AUTO(loop_var_decl, range, loop_type, element_type)'''
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed by macro expansion'''
reviewed = true

[[axioms]]
id = "ilp_for_range_auto_macro_postcond_ilp_ret_available"
content = '''The __ilp_ret variable of type ::ilp::ForResult is created from the outer lambda return value and marked [[maybe_unused]], available in the if statement scope'''
formal_spec = '''in_scope(if_body, __ilp_ret) && type(__ilp_ret) == auto && deduced_type(__ilp_ret) == ::ilp::ForResult'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_FOR_RANGE_AUTO"
header = "ilp_for.hpp"
signature = '''ILP_FOR_RANGE_AUTO(loop_var_decl, range, loop_type, element_type)'''
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed by macro expansion'''
reviewed = true

[[axioms]]
id = "ilp_for_range_auto_macro_anti_pattern_name_collision"
content = '''User code must not declare variables named __ilp_ret, __ilp_ctx, or __ilp_ctrl in the surrounding scope, as these are reserved by the macro expansion and will cause name collisions'''
formal_spec = '''not_in_scope(__ilp_ret) && not_in_scope(__ilp_ctx) && not_in_scope(__ilp_ctrl)'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "ILP_FOR_RANGE_AUTO"
header = "ilp_for.hpp"
signature = '''ILP_FOR_RANGE_AUTO(loop_var_decl, range, loop_type, element_type)'''
axiom_type = "anti_pattern"
on_violation = '''Compilation error or shadowing warnings due to name collision with macro-generated variables'''
reviewed = true

[[axioms]]
id = "ilp_for_range_auto_macro_effect_no_expansion_side_effects"
content = '''Macro expansion performs textual substitution with no side effects at preprocessing time; all evaluation occurs at runtime within the expanded code'''
formal_spec = '''noSideEffects(ILP_FOR_RANGE_AUTO) && evaluationTime(ILP_FOR_RANGE_AUTO) == runtime'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_FOR_RANGE_AUTO"
header = "ilp_for.hpp"
signature = '''ILP_FOR_RANGE_AUTO(loop_var_decl, range, loop_type, element_type)'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by preprocessor semantics'''
depends_on = ['ilp_n_transform_8_effect_no_side_effects', 'ilp_cpu_profile_macro_context_independence']
reviewed = true

[[axioms]]
id = "ilp_for_range_auto_macro_constraint_requires_ilp_end"
content = '''The For_Context_USE_ILP_END type is specifically designed to produce a compile-time error if ILP_END is not used to close the loop construct'''
formal_spec = '''requires_terminator(ILP_FOR_RANGE_AUTO) == ILP_END'''
layer = "library"
confidence = 0.98
source_file = ""
source_module = ""
function = "ILP_FOR_RANGE_AUTO"
header = "ilp_for.hpp"
signature = '''ILP_FOR_RANGE_AUTO(loop_var_decl, range, loop_type, element_type)'''
axiom_type = "constraint"
on_violation = '''Compilation error from For_Context_USE_ILP_END type if ILP_END is not used'''
depends_on = ['cpp20_dcl_init_list_copy_list_init_explicit_ctor_f2a3b4c5', 'cpp20_basic_life_vacuous_initialization_def_7c4e5d6a', 'cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8']
reviewed = true

[[axioms]]
id = "ilp_for_t_macro_precond_n_positive"
content = '''The template parameter N must be a positive integer compile-time constant representing the unroll factor for instruction-level parallelism'''
formal_spec = '''N > 0 && is_constant_expression(N) && is_integral(N)'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "ILP_FOR_T"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_FOR_T(type, loop_var_decl, start, end, N)'''
axiom_type = "precondition"
on_violation = '''Compilation error or incorrect loop behavior'''
depends_on = ['for_loop_typed_constraint_return_type_r_b1c2d3e4', 'cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2', 'cpp20_temp_expl_spec_unspecialized_enclosing_template_param_a7b8c9d0', 'for_loop_range_typed_precond_n_valid_offset_b3c4d5e6']
reviewed = true

[[axioms]]
id = "ilp_for_t_macro_precond_type_valid"
content = '''The type parameter must be a valid typename that can be used with ::ilp::ForResultTyped<type> and ::ilp::for_loop_typed<type, N>'''
formal_spec = '''is_valid_type(type) && is_instantiable(ForResultTyped<type>) && is_instantiable(for_loop_typed<type, N>)'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "ILP_FOR_T"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_FOR_T(type, loop_var_decl, start, end, N)'''
axiom_type = "precondition"
on_violation = '''Compilation error due to invalid template instantiation'''
reviewed = true

[[axioms]]
id = "ilp_for_t_macro_precond_range_valid"
content = '''The start and end parameters must form a valid range where start <= end and both are convertible to the loop index type'''
formal_spec = '''start <= end && is_convertible(decltype(start), index_type) && is_convertible(decltype(end), index_type)'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "ILP_FOR_T"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_FOR_T(type, loop_var_decl, start, end, N)'''
axiom_type = "precondition"
on_violation = '''Undefined behavior or empty loop execution'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4']
reviewed = true

[[axioms]]
id = "ilp_for_t_macro_effect_single_eval_start_end"
content = '''The start and end arguments are each evaluated exactly once when passed to for_loop_typed, protecting against multiple evaluation of side effects'''
formal_spec = '''eval_count(start) == 1 && eval_count(end) == 1'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "ILP_FOR_T"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_FOR_T(type, loop_var_decl, start, end, N)'''
axiom_type = "effect"
on_violation = '''N/A - side effects in start/end are safe'''
depends_on = ['ilp_for_auto_macro_param_eval_multiple_a7f3d2e1']
reviewed = true

[[axioms]]
id = "ilp_for_t_macro_effect_no_expansion_side_effects"
content = '''Macro expansion itself has no side effects at preprocessing time - it performs simple textual substitution'''
formal_spec = '''preprocessing_side_effects(ILP_FOR_T) == ∅'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_FOR_T"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_FOR_T(type, loop_var_decl, start, end, N)'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by preprocessor semantics'''
depends_on = ['ilp_n_transform_8_effect_no_side_effects', 'ilp_cpu_profile_macro_no_side_effects']
reviewed = true

[[axioms]]
id = "ilp_for_t_macro_constraint_lambda_context"
content = '''The macro must be used in a context where a lambda body can follow immediately, as the expansion creates an incomplete lambda expression that requires a body'''
formal_spec = '''requires_lambda_body_continuation(ILP_FOR_T) == true'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_FOR_T"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_FOR_T(type, loop_var_decl, start, end, N)'''
axiom_type = "constraint"
on_violation = '''Compilation error due to incomplete lambda expression'''
reviewed = true

[[axioms]]
id = "ilp_for_t_macro_constraint_scope_capture"
content = '''The macro uses capture-by-reference [&] for both lambdas, requiring that all captured variables outlive the lambda execution'''
formal_spec = '''∀ captured_var: lifetime(captured_var) >= lifetime(lambda_execution)'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "ILP_FOR_T"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_FOR_T(type, loop_var_decl, start, end, N)'''
axiom_type = "constraint"
on_violation = '''Undefined behavior due to dangling references if captured variables go out of scope'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "ilp_for_t_macro_postcond_ilp_ret_bound"
content = '''After macro expansion, the variable __ilp_ret is bound to the result of type ::ilp::ForResultTyped<type> and is available in the if-statement scope'''
formal_spec = '''typeof(__ilp_ret) == ::ilp::ForResultTyped<type> && in_scope(__ilp_ret)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_FOR_T"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_FOR_T(type, loop_var_decl, start, end, N)'''
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed by macro structure'''
reviewed = true

[[axioms]]
id = "ilp_for_t_macro_postcond_ctrl_param_available"
content = '''Within the lambda body following the macro, the loop control object __ilp_ctrl of type ::ilp::ForCtrlTyped<type>& is available for loop control operations'''
formal_spec = '''in_lambda_scope(__ilp_ctrl) && typeof(__ilp_ctrl) == ::ilp::ForCtrlTyped<type>&'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_FOR_T"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_FOR_T(type, loop_var_decl, start, end, N)'''
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed by macro structure'''
reviewed = true

[[axioms]]
id = "ilp_for_t_macro_anti_pattern_reuse_reserved_names"
content = '''Do not use the reserved names __ilp_ret, __ilp_ctx, or __ilp_ctrl in the surrounding code or lambda body, as they will conflict with the macro-generated names'''
formal_spec = '''¬∃ user_var ∈ {__ilp_ret, __ilp_ctx, __ilp_ctrl}: defined_by_user(user_var)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_FOR_T"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_FOR_T(type, loop_var_decl, start, end, N)'''
axiom_type = "anti_pattern"
on_violation = '''Compilation error due to name collision or shadowing'''
reviewed = true

[[axioms]]
id = "ilp_for_t_macro_complexity_unroll_factor"
content = '''The N parameter controls the instruction-level parallelism unroll factor, affecting code size and performance - larger N increases code size but may improve ILP'''
formal_spec = '''code_size_impact ∝ N && ILP_potential ∝ N'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "ILP_FOR_T"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_FOR_T(type, loop_var_decl, start, end, N)'''
axiom_type = "complexity"
on_violation = '''N/A - performance trade-off'''
reviewed = true

[[axioms]]
id = "ilp_for_t_macro_effect_context_independence"
content = '''The macro expansion is context-independent at preprocessing time - no side effects occur during expansion itself, only during runtime execution'''
formal_spec = '''∀ context: expand(ILP_FOR_T, context) has no observable preprocessing side effects'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_FOR_T"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_FOR_T(type, loop_var_decl, start, end, N)'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by preprocessor semantics'''
depends_on = ['ilp_cpu_profile_macro_context_independence', 'ilp_n_divide_4f_macro_effect_no_side_effects']
reviewed = true

[[axioms]]
id = "ilp_for_range_t_macro_type_constraint"
content = '''The 'type' parameter must be a valid C++ type that can be used as a template argument and is compatible with the return type of ForResultTyped and ForCtrlTyped'''
formal_spec = '''isValidType(type) && isTemplateCompatible(type, ForResultTyped) && isTemplateCompatible(type, ForCtrlTyped)'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "ILP_FOR_RANGE_T"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_FOR_RANGE_T(type, loop_var_decl, range, N)'''
axiom_type = "constraint"
on_violation = '''Compilation error due to template instantiation failure'''
depends_on = ['cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2', 'cpp20_temp_expl_spec_unspecialized_enclosing_template_param_a7b8c9d0', 'for_loop_range_typed_precond_n_valid_offset_b3c4d5e6']
reviewed = true

[[axioms]]
id = "ilp_for_range_t_macro_loop_var_decl_constraint"
content = '''The 'loop_var_decl' parameter must be a valid variable declaration that can be used as a lambda parameter'''
formal_spec = '''isValidVariableDeclaration(loop_var_decl) && canBeUsedAsLambdaParameter(loop_var_decl)'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "ILP_FOR_RANGE_T"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_FOR_RANGE_T(type, loop_var_decl, range, N)'''
axiom_type = "constraint"
on_violation = '''Compilation error due to invalid lambda parameter syntax'''
reviewed = true

[[axioms]]
id = "ilp_for_range_t_macro_n_constraint"
content = '''The 'N' parameter must be a compile-time constant integral value suitable as a template non-type parameter'''
formal_spec = '''isIntegralConstantExpression(N) && canBeNonTypeTemplateParameter(N)'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "ILP_FOR_RANGE_T"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_FOR_RANGE_T(type, loop_var_decl, range, N)'''
axiom_type = "constraint"
on_violation = '''Compilation error due to invalid template non-type parameter'''
depends_on = ['cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2', 'cpp20_temp_expl_spec_unspecialized_enclosing_template_param_a7b8c9d0', 'for_loop_range_typed_precond_n_valid_offset_b3c4d5e6']
reviewed = true

[[axioms]]
id = "ilp_for_range_t_macro_range_eval_once"
content = '''The 'range' argument is evaluated exactly once when passed to for_loop_range_typed, protecting against multiple evaluation side effects'''
formal_spec = '''eval_count(range) == 1'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "ILP_FOR_RANGE_T"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_FOR_RANGE_T(type, loop_var_decl, range, N)'''
axiom_type = "effect"
on_violation = '''N/A - single evaluation is guaranteed'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4']
reviewed = true

[[axioms]]
id = "ilp_for_range_t_macro_expansion_no_side_effects"
content = '''Macro expansion performs textual substitution with no side effects at preprocessing time; all side effects occur at runtime during lambda execution'''
formal_spec = '''noSideEffects(ILP_FOR_RANGE_T) && evaluationTime(ILP_FOR_RANGE_T) == runtime'''
layer = "library"
confidence = 0.98
source_file = ""
source_module = ""
function = "ILP_FOR_RANGE_T"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_FOR_RANGE_T(type, loop_var_decl, range, N)'''
axiom_type = "effect"
on_violation = '''N/A - preprocessing is side-effect-free by definition'''
depends_on = ['ilp_n_transform_8_effect_no_side_effects', 'ilp_cpu_profile_macro_no_side_effects']
reviewed = true

[[axioms]]
id = "ilp_for_range_t_macro_incomplete_statement"
content = '''This macro expands to an incomplete if statement with an open lambda body; it MUST be followed by a lambda body and closing braces, typically via a companion ILP_END macro'''
formal_spec = '''requiresCompletion(ILP_FOR_RANGE_T) && mustBeFollowedBy(lambdaBody)'''
layer = "library"
confidence = 0.98
source_file = ""
source_module = ""
function = "ILP_FOR_RANGE_T"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_FOR_RANGE_T(type, loop_var_decl, range, N)'''
axiom_type = "constraint"
on_violation = '''Compilation error due to incomplete if statement or lambda expression'''
reviewed = true

[[axioms]]
id = "ilp_for_range_t_macro_capture_by_reference"
content = '''The macro captures all surrounding variables by reference ([&]) in the outer lambda, making them available to the loop body but subject to lifetime and modification concerns'''
formal_spec = '''captureMode(outer_lambda) == by_reference && ∀v ∈ surroundingScope: accessible(v, loop_body)'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "ILP_FOR_RANGE_T"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_FOR_RANGE_T(type, loop_var_decl, range, N)'''
axiom_type = "effect"
on_violation = '''Dangling references if surrounding scope variables go out of scope before lambda execution completes'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "ilp_for_range_t_macro_return_type_constraint"
content = '''The for_loop_range_typed function must return a type compatible with ForResultTyped<type>, otherwise the explicit return type annotation will cause compilation failure'''
formal_spec = '''returnType(for_loop_range_typed<type, N>(range, lambda)) == ForResultTyped<type>'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "ILP_FOR_RANGE_T"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_FOR_RANGE_T(type, loop_var_decl, range, N)'''
axiom_type = "constraint"
on_violation = '''Compilation error due to type mismatch in lambda return type'''
reviewed = true

[[axioms]]
id = "ilp_for_range_t_macro_anti_pattern_missing_end"
content = '''Using this macro without a proper closing construct (like ILP_END) leaves an incomplete if statement and open lambda body, causing compilation failure'''
formal_spec = '''∀usage: requires(ILP_FOR_RANGE_T) ⟹ mustFollow(closingConstruct)'''
layer = "library"
confidence = 0.98
source_file = ""
source_module = ""
function = "ILP_FOR_RANGE_T"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_FOR_RANGE_T(type, loop_var_decl, range, N)'''
axiom_type = "anti_pattern"
on_violation = '''Compilation error with cryptic error messages about unexpected tokens or incomplete statements'''
depends_on = ['cpp20_dcl_init_list_copy_list_init_explicit_ctor_f2a3b4c5', 'cpp20_basic_life_vacuous_initialization_def_7c4e5d6a', 'cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8']
reviewed = true

[[axioms]]
id = "ilp_for_range_t_macro_context_variable_shadowing"
content = '''The macro introduces variables __ilp_ret, __ilp_ctx, and __ilp_ctrl in the expansion scope; code using this macro should avoid declaring variables with these names to prevent shadowing or conflicts'''
formal_spec = '''introduces(__ilp_ret) && introduces(__ilp_ctx) && introduces(__ilp_ctrl) && ∀v ∈ {__ilp_ret, __ilp_ctx, __ilp_ctrl}: shouldNotBeDeclared(v, user_code)'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "ILP_FOR_RANGE_T"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_FOR_RANGE_T(type, loop_var_decl, range, N)'''
axiom_type = "effect"
on_violation = '''Potential shadowing warnings or compilation errors if user code declares conflicting names'''
depends_on = ['cpp20_expr_prim_lambda_capture_shadows_param_f4a8b0c1']
reviewed = true

[[axioms]]
id = "ilp_for_range_t_macro_context_independence"
content = '''No side effects occur during macro expansion; the macro performs simple textual substitution without argument evaluation at preprocessing time'''
formal_spec = '''∀ context: expand(ILP_FOR_RANGE_T, context) has no observable side effects at preprocessing time'''
layer = "library"
confidence = 0.98
source_file = ""
source_module = ""
function = "ILP_FOR_RANGE_T"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_FOR_RANGE_T(type, loop_var_decl, range, N)'''
axiom_type = "effect"
on_violation = '''N/A - textual substitution is side-effect-free'''
depends_on = ['ilp_cpu_profile_macro_context_independence', 'ilp_cpu_profile_macro_no_side_effects']
reviewed = true

[[axioms]]
id = "ilp_for_t_auto_macro_effect_no_side_effects_expansion"
content = '''Macro expansion performs textual substitution with no side effects at preprocessing time'''
formal_spec = '''noSideEffects(ILP_FOR_T_AUTO) && evaluationTime(ILP_FOR_T_AUTO) == runtime'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_FOR_T_AUTO"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_FOR_T_AUTO(ret_type, loop_var_decl, start, end, loop_type, element_type)'''
axiom_type = "effect"
on_violation = '''N/A - preprocessing is deterministic'''
depends_on = ['ilp_cpu_profile_macro_context_independence', 'ilp_n_transform_8_effect_no_side_effects']
reviewed = true

[[axioms]]
id = "ilp_for_t_auto_macro_effect_lambda_capture"
content = '''The macro expands to a lambda with capture-by-reference [&], causing all variables referenced in loop_var_decl, start, end, and the loop body to be captured by reference'''
formal_spec = '''∀ v ∈ freeVars(loop_var_decl ∪ start ∪ end ∪ loop_body): captureMode(v) == reference'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_FOR_T_AUTO"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_FOR_T_AUTO(ret_type, loop_var_decl, start, end, loop_type, element_type)'''
axiom_type = "effect"
on_violation = '''Dangling references if captured variables go out of scope before lambda execution'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "ilp_for_t_auto_macro_effect_multiple_eval_start_end"
content = '''The start and end arguments are evaluated exactly once when the lambda is invoked, protected by function call semantics'''
formal_spec = '''eval_count(start) == 1 && eval_count(end) == 1'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_FOR_T_AUTO"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_FOR_T_AUTO(ret_type, loop_var_decl, start, end, loop_type, element_type)'''
axiom_type = "effect"
on_violation = '''N/A - single evaluation guaranteed'''
depends_on = ['ilp_for_auto_macro_param_eval_multiple_a7f3d2e1']
reviewed = true

[[axioms]]
id = "ilp_for_t_auto_macro_constraint_ret_type_complete"
content = '''ret_type must be a complete type at the point of macro expansion to instantiate ForResultTyped<ret_type>'''
formal_spec = '''isComplete(ret_type) == true'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_FOR_T_AUTO"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_FOR_T_AUTO(ret_type, loop_var_decl, start, end, loop_type, element_type)'''
axiom_type = "constraint"
on_violation = '''Compilation error - incomplete type in template instantiation'''
reviewed = true

[[axioms]]
id = "ilp_for_t_auto_macro_constraint_element_type_complete"
content = '''element_type must be a complete type at the point of macro expansion to instantiate for_loop_typed_auto<element_type, ...>'''
formal_spec = '''isComplete(element_type) == true'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_FOR_T_AUTO"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_FOR_T_AUTO(ret_type, loop_var_decl, start, end, loop_type, element_type)'''
axiom_type = "constraint"
on_violation = '''Compilation error - incomplete type in template instantiation'''
reviewed = true

[[axioms]]
id = "ilp_for_t_auto_macro_constraint_loop_type_enum"
content = '''loop_type must be a valid enumerator name in ::ilp::LoopType without the scope qualifier'''
formal_spec = '''∃ e ∈ ::ilp::LoopType: name(e) == loop_type'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_FOR_T_AUTO"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_FOR_T_AUTO(ret_type, loop_var_decl, start, end, loop_type, element_type)'''
axiom_type = "constraint"
on_violation = '''Compilation error - invalid qualified name'''
reviewed = true

[[axioms]]
id = "ilp_for_t_auto_macro_constraint_loop_var_decl_syntax"
content = '''loop_var_decl must be syntactically valid as a lambda parameter declaration (e.g., 'auto& i', 'const int& x')'''
formal_spec = '''isValidParamDecl(loop_var_decl) == true'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_FOR_T_AUTO"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_FOR_T_AUTO(ret_type, loop_var_decl, start, end, loop_type, element_type)'''
axiom_type = "constraint"
on_violation = '''Compilation error - malformed lambda parameter'''
reviewed = true

[[axioms]]
id = "ilp_for_t_auto_macro_constraint_start_end_convertible"
content = '''start and end must be convertible to types accepted by for_loop_typed_auto<element_type, ret_type, LoopType::loop_type>'''
formal_spec = '''isConvertible(typeof(start), AcceptedType1) && isConvertible(typeof(end), AcceptedType2)'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "ILP_FOR_T_AUTO"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_FOR_T_AUTO(ret_type, loop_var_decl, start, end, loop_type, element_type)'''
axiom_type = "constraint"
on_violation = '''Compilation error - type mismatch in function call'''
reviewed = true

[[axioms]]
id = "ilp_for_t_auto_macro_postcondition_if_condition"
content = '''The macro expands to an if statement where the condition is the auto-declared __ilp_ret variable, which is contextually convertible to bool'''
formal_spec = '''∃ conv: isContextuallyConvertibleToBool(::ilp::ForResultTyped<ret_type>) == true'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_FOR_T_AUTO"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_FOR_T_AUTO(ret_type, loop_var_decl, start, end, loop_type, element_type)'''
axiom_type = "postcondition"
on_violation = '''Compilation error - if condition not convertible to bool'''
reviewed = true

[[axioms]]
id = "ilp_for_t_auto_macro_anti_pattern_missing_ilp_end"
content = '''The macro opens an if statement and lambda but does not close them - user must provide closing braces and likely use ILP_END macro'''
formal_spec = '''requires_manual_closure(ILP_FOR_T_AUTO) == true'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_FOR_T_AUTO"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_FOR_T_AUTO(ret_type, loop_var_decl, start, end, loop_type, element_type)'''
axiom_type = "anti_pattern"
on_violation = '''Compilation error - unmatched braces, incomplete lambda'''
reviewed = true

[[axioms]]
id = "ilp_for_t_auto_macro_anti_pattern_scope_interaction"
content = '''Using this macro introduces hidden scopes (if statement scope and lambda scope) which can cause unexpected variable shadowing or lifetime issues'''
formal_spec = '''scopeDepth(after_expansion) == scopeDepth(before_expansion) + 2'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "ILP_FOR_T_AUTO"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_FOR_T_AUTO(ret_type, loop_var_decl, start, end, loop_type, element_type)'''
axiom_type = "anti_pattern"
on_violation = '''Unexpected shadowing, lifetime issues, or scope-related bugs'''
reviewed = true

[[axioms]]
id = "ilp_for_t_auto_macro_effect_context_variable"
content = '''The macro creates a [[maybe_unused]] variable __ilp_ctx of type ::ilp::detail::For_Context_USE_ILP_END which may be used for compile-time checks or RAII patterns'''
formal_spec = '''∃ __ilp_ctx: typeof(__ilp_ctx) == ::ilp::detail::For_Context_USE_ILP_END'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_FOR_T_AUTO"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_FOR_T_AUTO(ret_type, loop_var_decl, start, end, loop_type, element_type)'''
axiom_type = "effect"
on_violation = '''N/A - variable creation is guaranteed'''
reviewed = true

[[axioms]]
id = "ilp_for_t_auto_macro_complexity_lambda_overhead"
content = '''The macro creates a lambda which is immediately invoked, potentially incurring lambda creation and invocation overhead unless optimized away by the compiler'''
formal_spec = '''runtime_overhead(ILP_FOR_T_AUTO) >= lambda_creation_cost + lambda_invocation_cost (typically optimized to 0 with inline/constexpr)'''
layer = "library"
confidence = 0.85
source_file = ""
source_module = ""
function = "ILP_FOR_T_AUTO"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_FOR_T_AUTO(ret_type, loop_var_decl, start, end, loop_type, element_type)'''
axiom_type = "complexity"
on_violation = '''N/A - performance characteristic, not correctness'''
reviewed = true

[[axioms]]
id = "ilp_for_range_t_auto_macro_effect_no_side_effects"
content = '''Macro expansion performs textual substitution with no side effects at preprocessing time; all evaluation occurs at runtime'''
formal_spec = '''noSideEffects(ILP_FOR_RANGE_T_AUTO) && evaluationTime(ILP_FOR_RANGE_T_AUTO) == runtime'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_FOR_RANGE_T_AUTO"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_FOR_RANGE_T_AUTO(ret_type, loop_var_decl, range, loop_type, element_type)'''
axiom_type = "effect"
on_violation = '''N/A - preprocessing guarantees hold'''
depends_on = ['ilp_cpu_profile_macro_context_independence', 'ilp_n_transform_8_effect_no_side_effects']
reviewed = true

[[axioms]]
id = "ilp_for_range_t_auto_macro_lambda_capture_precondition"
content = '''All variables referenced in the loop_var_decl and range expressions must be in scope at the macro invocation point, as they will be captured by reference in the generated lambda'''
formal_spec = '''∀ var ∈ freeVars(loop_var_decl ∪ range): inScope(var, invocation_point)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_FOR_RANGE_T_AUTO"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_FOR_RANGE_T_AUTO(ret_type, loop_var_decl, range, loop_type, element_type)'''
axiom_type = "precondition"
on_violation = '''Compilation error due to undefined variables in lambda capture'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "ilp_for_range_t_auto_macro_range_eval_single"
content = '''The range argument is evaluated exactly once when passed to for_loop_range_typed_auto, protecting against multiple evaluation of side effects'''
formal_spec = '''eval_count(range) == 1'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_FOR_RANGE_T_AUTO"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_FOR_RANGE_T_AUTO(ret_type, loop_var_decl, range, loop_type, element_type)'''
axiom_type = "effect"
on_violation = '''N/A - single evaluation guaranteed by function call semantics'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4']
reviewed = true

[[axioms]]
id = "ilp_for_range_t_auto_macro_ret_type_constraint"
content = '''The ret_type parameter must be a valid type identifier that can be used as a template argument to ForResultTyped and ForCtrlTyped'''
formal_spec = '''isValidType(ret_type) && isInstantiable(ForResultTyped<ret_type>) && isInstantiable(ForCtrlTyped<ret_type>)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_FOR_RANGE_T_AUTO"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_FOR_RANGE_T_AUTO(ret_type, loop_var_decl, range, loop_type, element_type)'''
axiom_type = "constraint"
on_violation = '''Compilation error during template instantiation'''
depends_on = ['cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2', 'cpp20_temp_expl_spec_unspecialized_enclosing_template_param_a7b8c9d0', 'for_loop_range_typed_precond_n_valid_offset_b3c4d5e6']
reviewed = true

[[axioms]]
id = "ilp_for_range_t_auto_macro_loop_type_constraint"
content = '''The loop_type parameter must be a valid enumerator of ::ilp::LoopType without the scope prefix (e.g., Sequential, not LoopType::Sequential)'''
formal_spec = '''∃ e ∈ enumerators(::ilp::LoopType): e == loop_type'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_FOR_RANGE_T_AUTO"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_FOR_RANGE_T_AUTO(ret_type, loop_var_decl, range, loop_type, element_type)'''
axiom_type = "constraint"
on_violation = '''Compilation error: ::ilp::LoopType::loop_type does not name a valid enumerator'''
reviewed = true

[[axioms]]
id = "ilp_for_range_t_auto_macro_element_type_constraint"
content = '''The element_type parameter must be a valid type that can be used as a template argument and is compatible with the element type of range'''
formal_spec = '''isValidType(element_type) && isConvertible(deref(range.begin()), element_type)'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "ILP_FOR_RANGE_T_AUTO"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_FOR_RANGE_T_AUTO(ret_type, loop_var_decl, range, loop_type, element_type)'''
axiom_type = "constraint"
on_violation = '''Compilation error during template instantiation or type mismatch in loop body'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4', 'cpp20_temp_expl_spec_unspecialized_enclosing_template_param_a7b8c9d0', 'for_loop_range_typed_precond_n_valid_offset_b3c4d5e6', 'cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2']
reviewed = true

[[axioms]]
id = "ilp_for_range_t_auto_macro_loop_var_decl_constraint"
content = '''The loop_var_decl parameter must be a valid parameter declaration (e.g., 'auto& x' or 'const int i') that can appear in a lambda parameter list'''
formal_spec = '''isValidParamDecl(loop_var_decl)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_FOR_RANGE_T_AUTO"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_FOR_RANGE_T_AUTO(ret_type, loop_var_decl, range, loop_type, element_type)'''
axiom_type = "constraint"
on_violation = '''Compilation error: malformed lambda parameter'''
reviewed = true

[[axioms]]
id = "ilp_for_range_t_auto_macro_incomplete_statement"
content = '''This macro expands to an incomplete statement (if-statement with lambda that lacks the closing braces and body). It must be followed by the loop body in braces and terminated with ILP_END or similar macro'''
formal_spec = '''requiresCompletion(ILP_FOR_RANGE_T_AUTO) == true'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_FOR_RANGE_T_AUTO"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_FOR_RANGE_T_AUTO(ret_type, loop_var_decl, range, loop_type, element_type)'''
axiom_type = "anti_pattern"
on_violation = '''Compilation error: expected statement body after macro invocation'''
reviewed = true

[[axioms]]
id = "ilp_for_range_t_auto_macro_reserved_identifiers"
content = '''User code must not declare variables named __ilp_ret, __ilp_ctx, or __ilp_ctrl in the scope where this macro is used, as they will collide with the macro's internal identifiers'''
formal_spec = '''∀ var ∈ {__ilp_ret, __ilp_ctx, __ilp_ctrl}: var ∉ userDeclaredVars(scope)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_FOR_RANGE_T_AUTO"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_FOR_RANGE_T_AUTO(ret_type, loop_var_decl, range, loop_type, element_type)'''
axiom_type = "anti_pattern"
on_violation = '''Compilation error or undefined behavior due to name collision'''
reviewed = true

[[axioms]]
id = "ilp_for_range_t_auto_macro_postcondition_result_available"
content = '''After complete macro expansion and loop execution, the variable __ilp_ret of type ForResultTyped<ret_type> is available in the scope of the if-statement body'''
formal_spec = '''∃ __ilp_ret: type(__ilp_ret) == ForResultTyped<ret_type> && inScope(__ilp_ret, if_body)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_FOR_RANGE_T_AUTO"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_FOR_RANGE_T_AUTO(ret_type, loop_var_decl, range, loop_type, element_type)'''
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed by macro expansion'''
reviewed = true

[[axioms]]
id = "ilp_for_range_t_auto_macro_complexity_lambda_overhead"
content = '''The macro introduces lambda capture and function call overhead, though modern compilers typically inline the lambda eliminating most overhead'''
formal_spec = '''overhead(ILP_FOR_RANGE_T_AUTO) ≈ O(1) with optimization, O(lambda_call) without'''
layer = "library"
confidence = 0.8
source_file = ""
source_module = ""
function = "ILP_FOR_RANGE_T_AUTO"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_FOR_RANGE_T_AUTO(ret_type, loop_var_decl, range, loop_type, element_type)'''
axiom_type = "complexity"
on_violation = '''N/A - performance characteristic, not correctness'''
reviewed = true

[[axioms]]
id = "ilp_end_macro_precondition_context_matching_fc8e2a91"
content = '''ILP_END must be used in a context where it syntactically matches a preceding ILP_BEGIN or similar construct that sets up the expected code structure (lambda invocation, __ilp_ret variable, and if-else chain)'''
formal_spec = '''∃ ILP_BEGIN: precedes(ILP_BEGIN, ILP_END) ∧ establishes_context(ILP_BEGIN, __ilp_ret) ∧ valid_nesting(ILP_BEGIN, ILP_END)'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "ILP_END"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_END'''
axiom_type = "precondition"
on_violation = '''Compilation error due to unmatched braces, parentheses, or undefined __ilp_ret variable'''
depends_on = ['cpp20_dcl_init_list_copy_list_init_explicit_ctor_f2a3b4c5', 'cpp20_basic_life_vacuous_initialization_def_7c4e5d6a', 'cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8']
reviewed = true

[[axioms]]
id = "ilp_end_macro_precondition_ilp_ret_variable_a3d7f892"
content = '''Variable __ilp_ret must be defined and in scope, with a boolean member has_return accessible via member access operator'''
formal_spec = '''defined(__ilp_ret) ∧ has_member(__ilp_ret, has_return) ∧ type(__ilp_ret.has_return) == bool'''
layer = "library"
confidence = 0.98
source_file = ""
source_module = ""
function = "ILP_END"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_END'''
axiom_type = "precondition"
on_violation = '''Compilation error: undeclared identifier __ilp_ret or has_return'''
depends_on = ['c11_cpp_translation_name_syntax_operation_018c4422', 'cpp20_over_match_oper_fallback_builtin_comma_addr_arrow_b3c4d5e6', 'cpp20_over_match_oper_no_class_enum_builtin_f1a2b3c4']
reviewed = true

[[axioms]]
id = "ilp_end_macro_postcondition_control_flow_if_else_b2c9e3f4"
content = '''After expansion, ILP_END completes an if-else statement where the else branch evaluates to (void)0, ensuring the entire construct evaluates to void and has no effect when __ilp_ret.has_return is false'''
formal_spec = '''expansion(ILP_END) => (completes_if_else_chain() ∧ type(result) == void)'''
layer = "library"
confidence = 0.92
source_file = ""
source_module = ""
function = "ILP_END"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_END'''
axiom_type = "postcondition"
on_violation = '''Not applicable - structural guarantee'''
depends_on = ['cpp20_dcl_init_list_copy_list_init_explicit_ctor_f2a3b4c5', 'cpp20_basic_life_vacuous_initialization_def_7c4e5d6a', 'cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8']
reviewed = true

[[axioms]]
id = "ilp_end_macro_effect_conditional_error_call_d4e8a1b7"
content = '''If __ilp_ret.has_return evaluates to true, the function ilp::detail::ilp_end_with_return_error() is called (likely terminating the program or throwing an exception), otherwise no error function is called'''
formal_spec = '''__ilp_ret.has_return == true => calls(ilp::detail::ilp_end_with_return_error()) ∧ evaluates_before(ilp::detail::ilp_end_with_return_error(), false)'''
layer = "library"
confidence = 0.97
source_file = ""
source_module = ""
function = "ILP_END"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_END'''
axiom_type = "effect"
on_violation = '''Not applicable - effect description'''
depends_on = ['cpp20_except_throw_uncaught_after_init_before_activation_1c8e5a4b', 'cpp20_except_throw_destruction_after_handler_exit_c4a9f2e6', 'cpp20_except_throw_destruction_ordering_d5e1c7b9']
reviewed = true

[[axioms]]
id = "ilp_end_macro_effect_ilp_ret_evaluation_e7f2a8c3"
content = '''The member __ilp_ret.has_return is evaluated exactly once during the expansion of ILP_END (in the ternary conditional)'''
formal_spec = '''evaluation_count(__ilp_ret.has_return, ILP_END) == 1'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "ILP_END"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_END'''
axiom_type = "effect"
on_violation = '''Not applicable - effect description'''
reviewed = true

[[axioms]]
id = "ilp_end_macro_constraint_ilp_ret_bool_conversion_f9a3b2d1"
content = '''__ilp_ret.has_return must be contextually convertible to bool for use in the ternary conditional operator'''
formal_spec = '''contextually_convertible_to_bool(__ilp_ret.has_return) == true'''
layer = "library"
confidence = 0.96
source_file = ""
source_module = ""
function = "ILP_END"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_END'''
axiom_type = "constraint"
on_violation = '''Compilation error: value is not contextually convertible to bool'''
depends_on = ['c11_cpp_translation_name_syntax_operation_018c4422', 'cpp20_over_match_oper_fallback_builtin_comma_addr_arrow_b3c4d5e6', 'cpp20_over_match_oper_no_class_enum_builtin_f1a2b3c4']
reviewed = true

[[axioms]]
id = "ilp_end_macro_constraint_error_function_callable_a8c4e7f2"
content = '''The function ilp::detail::ilp_end_with_return_error must be callable with no arguments and accessible from the point of ILP_END expansion'''
formal_spec = '''callable(ilp::detail::ilp_end_with_return_error, 0) ∧ accessible(ilp::detail::ilp_end_with_return_error, use_site(ILP_END))'''
layer = "library"
confidence = 0.94
source_file = ""
source_module = ""
function = "ILP_END"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_END'''
axiom_type = "constraint"
on_violation = '''Compilation error: function not found or not accessible'''
reviewed = true

[[axioms]]
id = "ilp_end_macro_anti_pattern_unmatched_context_b7e9f1c4"
content = '''Using ILP_END without a corresponding ILP_BEGIN or in an unmatched syntactic context will result in compilation errors due to unbalanced braces, parentheses, or if-else statements'''
formal_spec = '''¬precedes(ILP_BEGIN, ILP_END) => compilation_error(unbalanced_delimiters)'''
layer = "library"
confidence = 0.93
source_file = ""
source_module = ""
function = "ILP_END"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_END'''
axiom_type = "anti_pattern"
on_violation = '''Compilation error: expected expression, unmatched braces or parentheses'''
depends_on = ['ilp_end_return_context_dependency']
reviewed = true

[[axioms]]
id = "ilp_end_macro_anti_pattern_missing_ilp_ret_c1f4a8e9"
content = '''Using ILP_END when __ilp_ret is not defined or out of scope will cause compilation failure'''
formal_spec = '''¬defined(__ilp_ret) ∨ ¬in_scope(__ilp_ret, use_site(ILP_END)) => compilation_error(undeclared_identifier)'''
layer = "library"
confidence = 0.97
source_file = ""
source_module = ""
function = "ILP_END"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_END'''
axiom_type = "anti_pattern"
on_violation = '''Compilation error: __ilp_ret was not declared in this scope'''
reviewed = true

[[axioms]]
id = "ilp_end_macro_postcondition_void_cast_d3a7e2f8"
content = '''The else branch contains an explicit cast to void of the literal 0, ensuring the result is discarded and the construct has no value in statement context'''
formal_spec = '''expansion(ILP_END) => contains_cast(void, 0) ∧ type(else_branch) == void'''
layer = "library"
confidence = 0.91
source_file = ""
source_module = ""
function = "ILP_END"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_END'''
axiom_type = "postcondition"
on_violation = '''Not applicable - structural guarantee'''
depends_on = ['cpp20_expr_cast_lvalue_result_d4e8a1c3', 'cpp20_dcl_init_list_copy_list_init_explicit_ctor_f2a3b4c5', 'cpp20_basic_life_vacuous_initialization_def_7c4e5d6a', 'cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8']
reviewed = true

[[axioms]]
id = "ilp_end_macro_effect_lambda_invocation_e8b3f9a2"
content = '''ILP_END closes a lambda definition with ); followed by immediate invocation with (); indicating that the preceding code is part of a lambda body that gets invoked'''
formal_spec = '''expansion(ILP_END) => (closes_lambda() ∧ invokes_lambda())'''
layer = "library"
confidence = 0.89
source_file = ""
source_module = ""
function = "ILP_END"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_END'''
axiom_type = "effect"
on_violation = '''Not applicable - structural effect'''
reviewed = true

[[axioms]]
id = "ilp_end_macro_postcondition_statement_termination_f2c8a4e1"
content = '''After ILP_END expansion, the construct syntactically completes as a valid statement (the if-else terminates properly) and no semicolon is needed after ILP_END'''
formal_spec = '''expansion(ILP_END) => forms_complete_statement() ∧ ¬requires_semicolon(ILP_END)'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "ILP_END"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_END'''
axiom_type = "postcondition"
on_violation = '''Not applicable - structural guarantee'''
depends_on = ['cpp20_dcl_init_list_copy_list_init_explicit_ctor_f2a3b4c5', 'cpp20_basic_life_vacuous_initialization_def_7c4e5d6a', 'cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8']
reviewed = true

[[axioms]]
id = "ilp_end_macro_effect_comma_operator_sequencing_a9f1e3c7"
content = '''The ternary operator uses comma operator to sequence ilp_end_with_return_error() before false, ensuring left-to-right evaluation and that the error function executes before the false result is produced'''
formal_spec = '''__ilp_ret.has_return == true => (evaluates(ilp_end_with_return_error()) before evaluates(false) ∧ result == false)'''
layer = "library"
confidence = 0.94
source_file = ""
source_module = ""
function = "ILP_END"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_END'''
axiom_type = "effect"
on_violation = '''Not applicable - guaranteed by comma operator semantics'''
depends_on = ['c11_cpp_translation_name_syntax_operation_018c4422', 'cpp20_over_match_oper_fallback_builtin_comma_addr_arrow_b3c4d5e6', 'cpp20_over_match_oper_no_class_enum_builtin_f1a2b3c4']
reviewed = true

[[axioms]]
id = "ilp_end_return_precond_ret_pointer_valid_a1b2c3d4"
content = '''The __ilp_ret variable must point to a valid object before dereferencing with *std::move(__ilp_ret)'''
formal_spec = '''points_to_object(__ilp_ret) && is_valid_object(*__ilp_ret)'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "ILP_END_RETURN"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_END_RETURN'''
axiom_type = "precondition"
on_violation = '''undefined behavior - dereferencing invalid pointer'''
depends_on = ['cpp20_basic_life_indirection_limited_use_7f8a9b0c', 'cpp20_expr_unary_op_indirection_ub_a7c3f2d1']
reviewed = true

[[axioms]]
id = "ilp_end_return_precond_ret_not_null_b2c3d4e5"
content = '''The __ilp_ret variable must be a valid pointer (not null or dangling) for safe dereferencing'''
formal_spec = '''__ilp_ret != nullptr && !is_dangling(__ilp_ret)'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "ILP_END_RETURN"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_END_RETURN'''
axiom_type = "precondition"
on_violation = '''undefined behavior - null or dangling pointer dereference'''
depends_on = ['c11_c_memory_reading_syntax_operation_bc1cd5d9', 'c11_cpp_expr_additive_operation_98819262', 'c11_cpp_translation_expr_new_operation_56ec7af1']
reviewed = true

[[axioms]]
id = "ilp_end_return_constraint_ret_pointer_type_c3d4e5f6"
content = '''__ilp_ret must be a pointer type for the dereference operation to be valid'''
formal_spec = '''is_pointer_type(type(__ilp_ret))'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_END_RETURN"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_END_RETURN'''
axiom_type = "constraint"
on_violation = '''compilation error - cannot dereference non-pointer type'''
depends_on = ['c11_c_memory_reading_syntax_operation_bc1cd5d9', 'c11_cpp_expr_additive_operation_98819262', 'c11_cpp_translation_expr_new_operation_56ec7af1']
reviewed = true

[[axioms]]
id = "ilp_end_return_constraint_ret_moveable_d4e5f6g7"
content = '''The object pointed to by __ilp_ret must be move-constructible for std::move to work properly'''
formal_spec = '''is_move_constructible(remove_pointer_t<decltype(__ilp_ret)>)'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "ILP_END_RETURN"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_END_RETURN'''
axiom_type = "constraint"
on_violation = '''compilation error - type is not move-constructible'''
depends_on = ['cpp20_dcl_init_list_copy_list_init_explicit_ctor_f2a3b4c5', 'cpp20_basic_life_vacuous_initialization_def_7c4e5d6a', 'cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8']
reviewed = true

[[axioms]]
id = "ilp_end_return_effect_moves_object_e5f6g7h8"
content = '''The macro moves the object pointed to by __ilp_ret, leaving it in a valid but unspecified state'''
formal_spec = '''after_expansion(*__ilp_ret) => is_moved_from(*__ilp_ret)'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "ILP_END_RETURN"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_END_RETURN'''
axiom_type = "effect"
on_violation = '''object is moved, subsequent use of __ilp_ret object may cause bugs'''
reviewed = true

[[axioms]]
id = "ilp_end_return_postcond_returns_value_f6g7h8i9"
content = '''If __ilp_ret evaluates to true in boolean context, the macro returns the moved value; otherwise executes (void)0'''
formal_spec = '''if(__ilp_ret) => returns(*std::move(__ilp_ret)) else => (void)0'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "ILP_END_RETURN"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_END_RETURN'''
axiom_type = "postcondition"
on_violation = '''N/A - postcondition always holds'''
depends_on = ['c11_c_typing_expr_syntax_elaboratePostponed_1acd5b74']
reviewed = true

[[axioms]]
id = "ilp_end_return_anti_pattern_context_dependent_g7h8i9j0"
content = '''This macro must be used in conjunction with matching ILP_BEGIN macro - using it standalone will cause syntax errors due to unmatched parentheses and braces'''
formal_spec = '''usage_context(ILP_END_RETURN) => preceded_by(ILP_BEGIN)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_END_RETURN"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_END_RETURN'''
axiom_type = "anti_pattern"
on_violation = '''compilation error - unmatched ), }, or malformed lambda/expression syntax'''
reviewed = true

[[axioms]]
id = "ilp_end_return_anti_pattern_ret_scope_h8i9j0k1"
content = '''The __ilp_ret variable must be in scope at the point of macro expansion (likely defined by a paired macro)'''
formal_spec = '''in_scope(__ilp_ret) at expansion point'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_END_RETURN"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_END_RETURN'''
axiom_type = "anti_pattern"
on_violation = '''compilation error - __ilp_ret undeclared identifier'''
reviewed = true

[[axioms]]
id = "ilp_end_return_effect_closes_lambda_i9j0k1l2"
content = '''The macro closes a lambda expression with ); } (); pattern, suggesting it completes an immediately-invoked lambda expression (IIILE)'''
formal_spec = '''macro_expansion closes lambda && invokes_immediately'''
layer = "library"
confidence = 0.85
source_file = ""
source_module = ""
function = "ILP_END_RETURN"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_END_RETURN'''
axiom_type = "effect"
on_violation = '''N/A - this is the intended behavior'''
reviewed = true

[[axioms]]
id = "ilp_end_return_constraint_boolean_context_j0k1l2m3"
content = '''__ilp_ret must be contextually convertible to bool for the implicit if-else pattern to work'''
formal_spec = '''is_contextually_convertible_to_bool(type(__ilp_ret))'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "ILP_END_RETURN"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_END_RETURN'''
axiom_type = "constraint"
on_violation = '''compilation error - cannot convert type to bool in conditional context'''
depends_on = ['c11_c_common_expr_assignment_assignment_b7ec7f96']
reviewed = true

[[axioms]]
id = "ilp_continue_precondition_in_void_function"
content = '''ILP_CONTINUE must be used within a function returning void, as it expands to a bare 'return' statement without a value'''
formal_spec = '''enclosing_function_return_type == void'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_CONTINUE"
header = "ilp_for.hpp"
signature = '''ILP_CONTINUE'''
axiom_type = "precondition"
on_violation = '''compilation error if used in non-void function context'''
depends_on = ['c11_c_typing_expr_syntax_elaboratePostponed_1acd5b74']
reviewed = true

[[axioms]]
id = "ilp_continue_effect_unconditional_return"
content = '''ILP_CONTINUE unconditionally returns from the enclosing function, terminating its execution immediately'''
formal_spec = '''ILP_CONTINUE → return; ∧ control_flow_exits_function'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_CONTINUE"
header = "ilp_for.hpp"
signature = '''ILP_CONTINUE'''
axiom_type = "effect"
on_violation = '''not applicable - effect is guaranteed by expansion'''
reviewed = true

[[axioms]]
id = "ilp_continue_postcondition_no_subsequent_execution"
content = '''After ILP_CONTINUE is invoked, no code following it in the same function scope will execute'''
formal_spec = '''after(ILP_CONTINUE) → ¬executes(subsequent_statements_in_scope)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_CONTINUE"
header = "ilp_for.hpp"
signature = '''ILP_CONTINUE'''
axiom_type = "postcondition"
on_violation = '''not applicable - guaranteed by control flow semantics'''
reviewed = true

[[axioms]]
id = "ilp_continue_effect_do_while_zero_idiom"
content = '''ILP_CONTINUE uses the do-while(0) idiom to create a statement that requires a semicolon and can be used safely in all contexts (if/else branches, etc.)'''
formal_spec = '''do { return; } while(0) → requires_semicolon ∧ safe_in_if_else ∧ single_statement'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_CONTINUE"
header = "ilp_for.hpp"
signature = '''ILP_CONTINUE'''
axiom_type = "effect"
on_violation = '''not applicable - idiomatic expansion guarantees safety'''
reviewed = true

[[axioms]]
id = "ilp_continue_anti_pattern_unreachable_code"
content = '''Placing any code after ILP_CONTINUE in the same scope creates unreachable code that will never execute'''
formal_spec = '''statement_after(ILP_CONTINUE) → unreachable_code ∧ likely_logic_error'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_CONTINUE"
header = "ilp_for.hpp"
signature = '''ILP_CONTINUE'''
axiom_type = "anti_pattern"
on_violation = '''compiler warning for unreachable code; logic error in program'''
reviewed = true

[[axioms]]
id = "ilp_continue_constraint_no_expression_context"
content = '''ILP_CONTINUE cannot be used in expression contexts as it expands to a statement (do-while block), not an expression'''
formal_spec = '''¬can_use_in(expression_context) ∧ only_valid_in(statement_context)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_CONTINUE"
header = "ilp_for.hpp"
signature = '''ILP_CONTINUE'''
axiom_type = "constraint"
on_violation = '''compilation error if used where an expression is expected'''
reviewed = true

[[axioms]]
id = "ilp_continue_complexity_zero_runtime_cost"
content = '''ILP_CONTINUE has zero runtime overhead; the do-while(0) wrapper is eliminated by any optimizer and reduces to a simple return instruction'''
formal_spec = '''runtime_cost(ILP_CONTINUE) = O(1) ∧ optimized_to(return)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_CONTINUE"
header = "ilp_for.hpp"
signature = '''ILP_CONTINUE'''
axiom_type = "complexity"
on_violation = '''not applicable - guaranteed by compiler optimization'''
reviewed = true

[[axioms]]
id = "ilp_break_precond_lambda_context"
content = '''ILP_BREAK must be used within a lambda or function context where 'return' is valid'''
formal_spec = '''∃ enclosing_scope: enclosing_scope.kind ∈ {function, lambda} ∧ return_statement.is_valid(enclosing_scope)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_BREAK"
header = "ilp_for.hpp"
signature = '''ILP_BREAK'''
axiom_type = "precondition"
on_violation = '''compilation error: 'return' statement not in function body'''
reviewed = true

[[axioms]]
id = "ilp_break_precond_ilp_ctrl_exists"
content = '''Variable '__ilp_ctrl' must be accessible in the current scope and have a member 'ok''''
formal_spec = '''∃ __ilp_ctrl ∈ scope: has_member(__ilp_ctrl, 'ok') ∧ is_assignable(__ilp_ctrl.ok, false)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_BREAK"
header = "ilp_for.hpp"
signature = '''ILP_BREAK'''
axiom_type = "precondition"
on_violation = '''compilation error: '__ilp_ctrl' was not declared in this scope, or does not have member 'ok''''
reviewed = true

[[axioms]]
id = "ilp_break_effect_sets_ok_false"
content = '''ILP_BREAK sets __ilp_ctrl.ok to false before executing return'''
formal_spec = '''before(return): __ilp_ctrl.ok = false'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_BREAK"
header = "ilp_for.hpp"
signature = '''ILP_BREAK'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by macro expansion'''
reviewed = true

[[axioms]]
id = "ilp_break_effect_early_return"
content = '''ILP_BREAK causes immediate return from the enclosing function, preventing subsequent code execution'''
formal_spec = '''∀ statement S: position(S) > position(ILP_BREAK) ⟹ ¬executed(S)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_BREAK"
header = "ilp_for.hpp"
signature = '''ILP_BREAK'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by return statement semantics'''
reviewed = true

[[axioms]]
id = "ilp_break_postcond_no_return"
content = '''After ILP_BREAK, no postconditions can be asserted as control flow has exited the function'''
formal_spec = '''∀ postcondition P: ¬can_assert(P) after ILP_BREAK'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_BREAK"
header = "ilp_for.hpp"
signature = '''ILP_BREAK'''
axiom_type = "postcondition"
on_violation = '''N/A - unreachable code'''
reviewed = true

[[axioms]]
id = "ilp_break_constraint_void_return"
content = '''ILP_BREAK can only be used in functions with void return type (naked return statement)'''
formal_spec = '''return_type(enclosing_function) = void'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_BREAK"
header = "ilp_for.hpp"
signature = '''ILP_BREAK'''
axiom_type = "constraint"
on_violation = '''compilation error or incorrect return semantics if function expects a return value'''
depends_on = ['cpp20_except_ctor_return_obj_destroy_on_throw_c9e5f0d4']
reviewed = true

[[axioms]]
id = "ilp_break_anti_pattern_destructor_bypass"
content = '''Using ILP_BREAK bypasses destructors of objects constructed after the macro, potentially causing resource leaks if used before RAII cleanup'''
formal_spec = '''∀ object O: constructed(O) ∧ position(O.construction) < position(ILP_BREAK) ∧ position(O.destruction) > position(ILP_BREAK) ⟹ O.destructor_called_on_return'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "ILP_BREAK"
header = "ilp_for.hpp"
signature = '''ILP_BREAK'''
axiom_type = "anti_pattern"
on_violation = '''Resource leak if manual cleanup was expected after object construction'''
depends_on = ['cpp20_expr_prim_id_dtor_double_destroy_ub_c9d3e5f6', 'cpp20_basic_life_vacuous_initialization_def_7c4e5d6a', 'cpp20_class_dtor_member_destruction_order_a7e4c9d2', 'cpp20_class_dtor_defaulted_constexpr_b3e7f2c4', 'cpp20_dcl_init_list_copy_list_init_explicit_ctor_f2a3b4c5', 'cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8']
reviewed = true

[[axioms]]
id = "ilp_break_complexity_constant"
content = '''ILP_BREAK has O(1) time complexity - single assignment and return'''
formal_spec = '''time_complexity(ILP_BREAK) = O(1)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_BREAK"
header = "ilp_for.hpp"
signature = '''ILP_BREAK'''
axiom_type = "complexity"
on_violation = '''N/A - informational'''
reviewed = true

[[axioms]]
id = "ilp_break_effect_dowhile_safety"
content = '''The do-while(0) wrapper ensures ILP_BREAK can be used safely in single-statement contexts (if/else) and requires semicolon'''
formal_spec = '''∀ context C ∈ {if_then, else_branch, loop_body}: syntactically_safe(ILP_BREAK, C) ∧ requires_semicolon(ILP_BREAK)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_BREAK"
header = "ilp_for.hpp"
signature = '''ILP_BREAK'''
axiom_type = "effect"
on_violation = '''N/A - this is a design feature preventing misuse'''
reviewed = true

[[axioms]]
id = "ilp_return_macro_precond_storage_valid_a8f9d3e2"
content = '''The __ilp_ctrl object must be accessible in the current scope and its storage member must be a valid object'''
formal_spec = '''is_accessible(__ilp_ctrl) && is_valid(__ilp_ctrl.storage) && has_member(__ilp_ctrl.storage, set)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_RETURN"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_RETURN(x)'''
axiom_type = "precondition"
on_violation = '''compilation error if __ilp_ctrl is not in scope; undefined behavior if storage is invalid'''
reviewed = true

[[axioms]]
id = "ilp_return_macro_precond_void_context_b2c7e4f1"
content = '''The macro must be used within a void-returning function or lambda, as it contains a bare 'return' statement'''
formal_spec = '''enclosing_function_return_type() == void'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_RETURN"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_RETURN(x)'''
axiom_type = "precondition"
on_violation = '''compilation error if used in non-void function; incorrect return value in non-void context'''
depends_on = ['c11_c_typing_expr_syntax_elaboratePostponed_1acd5b74']
reviewed = true

[[axioms]]
id = "ilp_return_macro_constraint_x_type_c5d8f2a3"
content = '''The parameter x must be of a type compatible with the storage.set() method's parameter type'''
formal_spec = '''is_convertible(type(x), parameter_type(__ilp_ctrl.storage.set))'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "ILP_RETURN"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_RETURN(x)'''
axiom_type = "constraint"
on_violation = '''compilation error if types are incompatible'''
depends_on = ['cpp20_expr_cast_incomplete_class_ptr_operand_b4f2a7c1', 'cpp20_expr_cast_incomplete_class_ptr_dest_c6e9d2a3']
reviewed = true

[[axioms]]
id = "ilp_return_macro_effect_single_eval_d3e9a1b4"
content = '''The parameter x is evaluated exactly once during macro expansion, so side effects in x occur exactly once'''
formal_spec = '''eval_count(x) == 1'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_RETURN"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_RETURN(x)'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by macro structure'''
depends_on = ['ilp_for_auto_macro_param_eval_multiple_a7f3d2e1']
reviewed = true

[[axioms]]
id = "ilp_return_macro_postcond_state_modified_e4f1b2c5"
content = '''After macro expansion, __ilp_ctrl.storage contains x, return_set is true, ok is false, and control flow exits the enclosing function'''
formal_spec = '''__ilp_ctrl.storage == x && __ilp_ctrl.return_set == true && __ilp_ctrl.ok == false && control_flow == exited'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_RETURN"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_RETURN(x)'''
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed by macro expansion'''
reviewed = true

[[axioms]]
id = "ilp_return_macro_effect_no_preproc_side_effects_f5a2c3d6"
content = '''Macro expansion performs textual substitution with no side effects at preprocessing time; all effects occur at runtime'''
formal_spec = '''noSideEffects_at_preprocessing(ILP_RETURN) && evaluationTime(ILP_RETURN) == runtime'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_RETURN"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_RETURN(x)'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by preprocessor semantics'''
depends_on = ['ilp_cpu_profile_macro_no_side_effects', 'ilp_n_transform_8_effect_no_side_effects', 'ilp_cpu_profile_macro_context_independence']
reviewed = true

[[axioms]]
id = "ilp_return_macro_effect_control_flow_exit_a1b8c4d7"
content = '''The macro unconditionally exits the enclosing function via 'return', preventing any subsequent code in the function from executing'''
formal_spec = '''after_expansion(ILP_RETURN(x)) => control_flow_exits && unreachable(subsequent_statements)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_RETURN"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_RETURN(x)'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by return statement in macro'''
reviewed = true

[[axioms]]
id = "ilp_return_macro_anti_pattern_exception_unsafe_b9c2d5e8"
content = '''If storage.set(x) throws an exception, return_set and ok will not be updated, leading to inconsistent state; the macro does not provide exception safety'''
formal_spec = '''throws(storage.set(x)) => (__ilp_ctrl.return_set remains unchanged && __ilp_ctrl.ok remains unchanged)'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "ILP_RETURN"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_RETURN(x)'''
axiom_type = "anti_pattern"
on_violation = '''inconsistent state in __ilp_ctrl if set() throws'''
depends_on = ['cpp20_except_throw_uncaught_after_init_before_activation_1c8e5a4b', 'cpp20_except_throw_destruction_after_handler_exit_c4a9f2e6', 'cpp20_except_throw_destruction_ordering_d5e1c7b9']
reviewed = true

[[axioms]]
id = "ilp_return_macro_complexity_constant_c7d3e1f9"
content = '''The macro expansion has O(1) overhead beyond the cost of storage.set(x), consisting of two boolean assignments'''
formal_spec = '''time_complexity(ILP_RETURN(x)) = O(1) + time_complexity(storage.set(x))'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_RETURN"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_RETURN(x)'''
axiom_type = "complexity"
on_violation = '''N/A - performance characteristic'''
reviewed = true

[[axioms]]
id = "ilp_return_macro_constraint_do_while_safe_d8e4f2a1"
content = '''The macro uses do-while(0) idiom making it safe to use in single-statement contexts (if/else without braces) and requiring semicolon after invocation'''
formal_spec = '''safe_in_single_statement_context(ILP_RETURN) && requires_semicolon(ILP_RETURN)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_RETURN"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for.hpp"
signature = '''ILP_RETURN(x)'''
axiom_type = "constraint"
on_violation = '''compilation error if semicolon is omitted; correct behavior in all control flow contexts'''
reviewed = true

[[axioms]]
id = "ilp_cpu_profile_macro_purpose"
content = '''ILP_CPU_PROFILE expands to ilp::cpu::skylake, representing a CPU profile constant for the Skylake microarchitecture'''
formal_spec = '''ILP_CPU_PROFILE ≡ ilp::cpu::skylake'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_CPU_PROFILE"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_CPU_PROFILE'''
axiom_type = "postcondition"
on_violation = '''N/A - textual substitution always produces ilp::cpu::skylake'''
reviewed = true

[[axioms]]
id = "ilp_cpu_profile_macro_namespace_requirement"
content = '''The namespace ilp::cpu must be accessible and must contain the identifier skylake at the point of use'''
formal_spec = '''∃ ilp::cpu::skylake ∧ skylake is visible in scope'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_CPU_PROFILE"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_CPU_PROFILE'''
axiom_type = "precondition"
on_violation = '''Compilation error - undefined identifier ilp::cpu::skylake'''
reviewed = true

[[axioms]]
id = "ilp_cpu_profile_macro_type_constraint"
content = '''ilp::cpu::skylake must be a valid type, enumerator, or object that can be used in the context where ILP_CPU_PROFILE appears'''
formal_spec = '''typeof(ilp::cpu::skylake) is well-formed in usage context'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "ILP_CPU_PROFILE"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_CPU_PROFILE'''
axiom_type = "constraint"
on_violation = '''Compilation error if skylake cannot be used in the given context (e.g., type mismatch, inaccessible member)'''
reviewed = true

[[axioms]]
id = "ilp_cpu_profile_macro_no_side_effects"
content = '''Macro expansion has no side effects - it performs pure textual substitution to a qualified identifier'''
formal_spec = '''∀ usage: expansion(ILP_CPU_PROFILE) has no side effects'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_CPU_PROFILE"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_CPU_PROFILE'''
axiom_type = "effect"
on_violation = '''N/A - object-like macros expanding to identifiers have no side effects'''
reviewed = true

[[axioms]]
id = "ilp_cpu_profile.default_config"
content = '''Expands to ilp::cpu::alderlake, providing a default CPU profile configuration'''
formal_spec = '''ILP_CPU_PROFILE ≡ ilp::cpu::alderlake'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_CPU_PROFILE"
header = "ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_CPU_PROFILE'''
axiom_type = "postcondition"
on_violation = '''N/A - object-like macro with fixed expansion'''
reviewed = true

[[axioms]]
id = "ilp_cpu_profile.namespace_requirement"
content = '''The namespace ilp::cpu and the identifier alderlake must be declared and accessible in the scope where this macro is expanded'''
formal_spec = '''∃ ilp::cpu::alderlake ∧ alderlake is accessible in current scope'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_CPU_PROFILE"
header = "ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_CPU_PROFILE'''
axiom_type = "precondition"
on_violation = '''Compilation error - undeclared identifier'''
reviewed = true

[[axioms]]
id = "ilp_cpu_profile.no_side_effects"
content = '''Object-like macro performs simple textual substitution with no argument evaluation or side effects'''
formal_spec = '''ILP_CPU_PROFILE → ilp::cpu::alderlake (pure substitution, no evaluation)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_CPU_PROFILE"
header = "ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_CPU_PROFILE'''
axiom_type = "effect"
on_violation = '''N/A - no runtime behavior'''
reviewed = true

[[axioms]]
id = "ilp_cpu_profile.type_constraint"
content = '''The expanded identifier ilp::cpu::alderlake must be of a type compatible with the context where ILP_CPU_PROFILE is used'''
formal_spec = '''typeof(ilp::cpu::alderlake) must satisfy usage context requirements'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "ILP_CPU_PROFILE"
header = "ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_CPU_PROFILE'''
axiom_type = "constraint"
on_violation = '''Type error at compile time if used in incompatible context'''
reviewed = true

[[axioms]]
id = "ilp_cpu_profile_macro_postcondition_expands_to_qualified_name"
content = '''ILP_CPU_PROFILE expands to the fully qualified name ilp::cpu::zen5'''
formal_spec = '''expansion(ILP_CPU_PROFILE) == ilp::cpu::zen5'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_CPU_PROFILE"
header = "ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_CPU_PROFILE'''
axiom_type = "postcondition"
on_violation = '''Compilation error if ilp::cpu::zen5 is not defined or not accessible'''
reviewed = true

[[axioms]]
id = "ilp_cpu_profile_macro_constraint_requires_namespace_visible"
content = '''The namespace ilp::cpu and the identifier zen5 must be declared and accessible at the point of use'''
formal_spec = '''∃ ilp::cpu::zen5 ∧ accessible(ilp::cpu::zen5)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_CPU_PROFILE"
header = "ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_CPU_PROFILE'''
axiom_type = "precondition"
on_violation = '''Compilation error: 'zen5' is not a member of 'ilp::cpu' or namespace not found'''
reviewed = true

[[axioms]]
id = "ilp_cpu_profile_macro_effect_textual_substitution"
content = '''This is an object-like macro that performs textual substitution without argument evaluation, so no side effects occur during expansion'''
formal_spec = '''is_object_like(ILP_CPU_PROFILE) ∧ ¬has_side_effects(expansion(ILP_CPU_PROFILE))'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_CPU_PROFILE"
header = "ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_CPU_PROFILE'''
axiom_type = "effect"
on_violation = '''N/A - object-like macros do not evaluate expressions during expansion'''
reviewed = true

[[axioms]]
id = "ilp_cpu_profile_macro_constraint_type_determined_by_zen5"
content = '''The type of ILP_CPU_PROFILE is determined by the type of ilp::cpu::zen5, which is likely a type alias, class, or constexpr object representing a CPU profile configuration'''
formal_spec = '''typeof(ILP_CPU_PROFILE) == typeof(ilp::cpu::zen5)'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "ILP_CPU_PROFILE"
header = "ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_CPU_PROFILE'''
axiom_type = "constraint"
on_violation = '''Type mismatches if used in contexts expecting a different type'''
depends_on = ['cpp20_class_dtor_trivial_conditions_a9d6e5b8', 'cpp20_basic_life_end_without_destructor_9c0d1e2f', 'cpp20_class_dtor_implicit_declaration_inline_public_d5f9a7b3']
reviewed = true

[[axioms]]
id = "ilp_cpu_profile.type_alias"
content = '''ILP_CPU_PROFILE expands to ilp::cpu::apple_m1, serving as a type or constant alias'''
formal_spec = '''ILP_CPU_PROFILE ≡ ilp::cpu::apple_m1'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_CPU_PROFILE"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_CPU_PROFILE'''
axiom_type = "postcondition"
on_violation = '''N/A - textual substitution always succeeds'''
reviewed = true

[[axioms]]
id = "ilp_cpu_profile.scope_requirement"
content = '''The identifier ilp::cpu::apple_m1 must be declared and accessible in the scope where ILP_CPU_PROFILE is used'''
formal_spec = '''∃ ilp::cpu::apple_m1 ∈ visible_scope(use_site)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_CPU_PROFILE"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_CPU_PROFILE'''
axiom_type = "precondition"
on_violation = '''Compilation error - undefined identifier'''
reviewed = true

[[axioms]]
id = "ilp_cpu_profile.no_parentheses"
content = '''Do not invoke as ILP_CPU_PROFILE() - this is an object-like macro, not function-like'''
formal_spec = '''use_pattern ≠ ILP_CPU_PROFILE()'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_CPU_PROFILE"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_CPU_PROFILE'''
axiom_type = "anti_pattern"
on_violation = '''Compilation error or incorrect interpretation as function call on expanded type'''
reviewed = true

[[axioms]]
id = "ilp_cpu_profile_macro_type_requirement"
content = '''ILP_CPU_PROFILE expands to ilp::cpu::default_profile, which must be a valid type or object name. The identifier ilp::cpu::default_profile must be defined and accessible in the current scope.'''
formal_spec = '''exists(ilp::cpu::default_profile) ∧ accessible(ilp::cpu::default_profile)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_CPU_PROFILE"
header = "ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_CPU_PROFILE'''
axiom_type = "constraint"
on_violation = '''Compilation error: undefined identifier'''
reviewed = true

[[axioms]]
id = "ilp_cpu_profile_macro_namespace_requirement"
content = '''Before using ILP_CPU_PROFILE, the namespace ilp::cpu must be defined and default_profile must be declared within it. This typically requires including the appropriate header that defines ilp::cpu::default_profile.'''
formal_spec = '''namespace_exists(ilp::cpu) ∧ declared(ilp::cpu::default_profile)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_CPU_PROFILE"
header = "ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_CPU_PROFILE'''
axiom_type = "precondition"
on_violation = '''Compilation error: namespace or identifier not found'''
reviewed = true

[[axioms]]
id = "ilp_cpu_profile_macro_textual_substitution"
content = '''ILP_CPU_PROFILE performs pure textual substitution with no argument evaluation. Every occurrence of ILP_CPU_PROFILE is replaced with ilp::cpu::default_profile during preprocessing. No side effects occur during expansion since this is an object-like macro with no parameters.'''
formal_spec = '''∀ occurrence. preprocessor_replaces(ILP_CPU_PROFILE, ilp::cpu::default_profile) ∧ no_evaluation_during_expansion'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_CPU_PROFILE"
header = "ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_CPU_PROFILE'''
axiom_type = "effect"
on_violation = '''N/A - textual substitution is guaranteed by preprocessor'''
reviewed = true

[[axioms]]
id = "ilp_cpu_profile_macro_context_preservation"
content = '''After macro expansion, ILP_CPU_PROFILE in any expression context becomes ilp::cpu::default_profile in that same context. The replacement preserves the syntactic context (e.g., if used as a type, it must expand to a type; if used as a value, it must expand to a value).'''
formal_spec = '''context(ILP_CPU_PROFILE) = context(ilp::cpu::default_profile) after expansion'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_CPU_PROFILE"
header = "ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_CPU_PROFILE'''
axiom_type = "postcondition"
on_violation = '''Compilation error if ilp::cpu::default_profile is not valid in the usage context'''
reviewed = true

[[axioms]]
id = "ilp_cpu_profile_macro_type_constraint"
content = '''ILP_CPU_PROFILE expands to ilp::cpu::default_profile, which must be a valid identifier in scope. The type of default_profile must be compatible with contexts where ILP_CPU_PROFILE is used.'''
formal_spec = '''∃ ilp::cpu::default_profile ∧ typeof(ILP_CPU_PROFILE) = typeof(ilp::cpu::default_profile)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_CPU_PROFILE"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_CPU_PROFILE'''
axiom_type = "constraint"
on_violation = '''Compilation error if ilp::cpu::default_profile is not declared or not in scope'''
reviewed = true

[[axioms]]
id = "ilp_cpu_profile_macro_postcondition"
content = '''After macro expansion, every occurrence of ILP_CPU_PROFILE is textually replaced with ilp::cpu::default_profile'''
formal_spec = '''ILP_CPU_PROFILE → ilp::cpu::default_profile'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_CPU_PROFILE"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_CPU_PROFILE'''
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed by preprocessor'''
reviewed = true

[[axioms]]
id = "ilp_cpu_profile_macro_effect"
content = '''This is a simple object-like macro that performs textual substitution with no parameters. No multiple evaluation concerns, no operator precedence issues, and no side effects beyond the substitution itself.'''
formal_spec = '''pure_textual_substitution(ILP_CPU_PROFILE) ∧ ¬has_side_effects(ILP_CPU_PROFILE)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_CPU_PROFILE"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_CPU_PROFILE'''
axiom_type = "effect"
on_violation = '''N/A - no side effects possible'''
depends_on = ['c11_cpp_translation_name_syntax_operation_018c4422', 'cpp20_over_match_oper_fallback_builtin_comma_addr_arrow_b3c4d5e6', 'cpp20_over_match_oper_no_class_enum_builtin_f1a2b3c4']
reviewed = true

[[axioms]]
id = "ilp_cpu_profile_macro_precondition"
content = '''Before using ILP_CPU_PROFILE, the namespace ilp::cpu must be declared and default_profile must be a valid member accessible in the current scope'''
formal_spec = '''declared(ilp::cpu::default_profile) ∧ accessible(ilp::cpu::default_profile)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_CPU_PROFILE"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_CPU_PROFILE'''
axiom_type = "precondition"
on_violation = '''Compilation error: undefined identifier ilp::cpu::default_profile'''
reviewed = true

[[axioms]]
id = "ilp_n_sum_1_macro_precondition_dependency"
content = '''ILP_CPU_PROFILE must be defined and evaluate to an object with a member named sum_1 before using ILP_N_SUM_1'''
formal_spec = '''is_defined(ILP_CPU_PROFILE) ∧ has_member(expansion(ILP_CPU_PROFILE), 'sum_1')'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SUM_1"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SUM_1'''
axiom_type = "precondition"
on_violation = '''Compilation error: member access into incomplete or undefined type'''
depends_on = ['ilp_cpu_profile_macro_expansion', 'ilp_cpu_profile_macro_context_sensitivity']
reviewed = true

[[axioms]]
id = "ilp_n_sum_1_macro_expansion"
content = '''After macro expansion, ILP_N_SUM_1 is textually replaced with ILP_CPU_PROFILE.sum_1, which further expands to ilp::cpu::default_profile.sum_1'''
formal_spec = '''expansion(ILP_N_SUM_1) == 'ILP_CPU_PROFILE.sum_1' ∧ full_expansion(ILP_N_SUM_1) == 'ilp::cpu::default_profile.sum_1''''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SUM_1"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SUM_1'''
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed by preprocessor'''
depends_on = ['ilp_cpu_profile_macro_expansion']
reviewed = true

[[axioms]]
id = "ilp_n_sum_1_macro_effect_lvalue"
content = '''Any modification to ILP_N_SUM_1 directly modifies ILP_CPU_PROFILE.sum_1 (lvalue semantics preserved)'''
formal_spec = '''is_lvalue(ILP_N_SUM_1) == is_lvalue(ILP_CPU_PROFILE.sum_1) ∧ address_of(ILP_N_SUM_1) == address_of(ILP_CPU_PROFILE.sum_1)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SUM_1"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SUM_1'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by macro expansion semantics'''
depends_on = ['cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b', 'cpp20_expr_cast_lvalue_result_d4e8a1c3', 'cpp20_basic_lval_temp_materialization_b4e9f1c5']
reviewed = true

[[axioms]]
id = "ilp_n_sum_1_macro_effect_no_side_effects"
content = '''ILP_N_SUM_1 performs simple textual substitution with no arguments, no multiple evaluation, and no side effects'''
formal_spec = '''no_side_effects(ILP_N_SUM_1) ∧ evaluation_count(ILP_N_SUM_1) = 0 ∧ argument_count(ILP_N_SUM_1) = 0'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SUM_1"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SUM_1'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by object-like macro definition'''
depends_on = ['ilp_cpu_profile_macro_simple_substitution']
reviewed = true

[[axioms]]
id = "ilp_n_sum_1_macro_context_sensitivity"
content = '''The meaning of ILP_N_SUM_1 depends on the definition of ilp::cpu::default_profile at the point of use, not at the point of macro definition'''
formal_spec = '''semantic_binding(ILP_N_SUM_1) == binding_at_use_site(ilp::cpu::default_profile.sum_1)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SUM_1"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SUM_1'''
axiom_type = "effect"
on_violation = '''Unexpected behavior if default_profile changes between macro definition and use'''
depends_on = ['ilp_cpu_profile_macro_context_sensitivity']
reviewed = true

[[axioms]]
id = "ilp_n_sum_1_macro_anti_pattern_global_dependency"
content = '''Using this macro creates an implicit dependency on ILP_CPU_PROFILE being defined in scope; consider using the qualified name ilp::cpu::default_profile.sum_1 directly for clarity'''
formal_spec = '''implicit_dependency(ILP_N_SUM_1, ILP_CPU_PROFILE) ∧ better_alternative(ilp::cpu::default_profile.sum_1)'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "ILP_N_SUM_1"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SUM_1'''
axiom_type = "anti_pattern"
on_violation = '''Reduced code clarity and increased coupling to macro definitions'''
depends_on = ['ilp_n_shift_4_macro_anti_pattern_global_dependency']
reviewed = true

[[axioms]]
id = "ilp_n_sum_1_macro_complexity_zero_overhead"
content = '''ILP_N_SUM_1 has zero runtime overhead as it is purely a compile-time textual substitution with no additional operations'''
formal_spec = '''runtime_overhead(ILP_N_SUM_1) = O(1) ∧ compile_time_overhead(ILP_N_SUM_1) = O(1)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SUM_1"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SUM_1'''
axiom_type = "complexity"
on_violation = '''N/A - guaranteed by preprocessor implementation'''
depends_on = ['ilp_cpu_profile_macro_simple_substitution']
reviewed = true

[[axioms]]
id = "macro_ilp_n_sum_2_precondition_profile_defined"
content = '''ILP_CPU_PROFILE must be defined and in scope before ILP_N_SUM_2 is used'''
formal_spec = '''defined(ILP_CPU_PROFILE) ∧ in_scope(ILP_CPU_PROFILE)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SUM_2"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SUM_2'''
axiom_type = "precondition"
on_violation = '''Compilation error: undefined identifier'''
depends_on = ['ilp_cpu_profile_macro_context_sensitivity', 'ilp_cpu_profile_macro_expansion']
reviewed = true

[[axioms]]
id = "macro_ilp_n_sum_2_precondition_member_exists"
content = '''The object referenced by ILP_CPU_PROFILE must have a member named sum_2'''
formal_spec = '''has_member(typeof(ILP_CPU_PROFILE), 'sum_2')'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SUM_2"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SUM_2'''
axiom_type = "precondition"
on_violation = '''Compilation error: no member named 'sum_2''''
depends_on = ['ilp_cpu_profile_macro_expansion']
reviewed = true

[[axioms]]
id = "macro_ilp_n_sum_2_expansion"
content = '''After macro expansion, ILP_N_SUM_2 is textually replaced with ILP_CPU_PROFILE.sum_2'''
formal_spec = '''expansion(ILP_N_SUM_2) == 'ILP_CPU_PROFILE.sum_2''''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SUM_2"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SUM_2'''
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed by preprocessor'''
depends_on = ['ilp_cpu_profile_macro_simple_substitution']
reviewed = true

[[axioms]]
id = "macro_ilp_n_sum_2_effect_simple_substitution"
content = '''ILP_N_SUM_2 performs simple textual substitution with no arguments, no multiple evaluation, and no side effects'''
formal_spec = '''no_side_effects(ILP_N_SUM_2) ∧ evaluation_count(ILP_N_SUM_2) = 0'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SUM_2"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SUM_2'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by preprocessor'''
depends_on = ['ilp_cpu_profile_macro_simple_substitution']
reviewed = true

[[axioms]]
id = "macro_ilp_n_sum_2_effect_lvalue"
content = '''Any modification to ILP_N_SUM_2 directly modifies ILP_CPU_PROFILE.sum_2 (lvalue semantics preserved)'''
formal_spec = '''is_lvalue(ILP_N_SUM_2) == is_lvalue(ILP_CPU_PROFILE.sum_2) ∧ address_of(ILP_N_SUM_2) == address_of(ILP_CPU_PROFILE.sum_2)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SUM_2"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SUM_2'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by textual substitution'''
depends_on = ['cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b', 'cpp20_expr_cast_lvalue_result_d4e8a1c3', 'cpp20_basic_lval_temp_materialization_b4e9f1c5']
reviewed = true

[[axioms]]
id = "macro_ilp_n_sum_2_context_sensitivity"
content = '''The meaning of ILP_N_SUM_2 depends on the definition of ILP_CPU_PROFILE at the point of use, not at the point where ILP_N_SUM_2 is defined'''
formal_spec = '''semantic_binding(ILP_N_SUM_2) == binding_at_use_site(ILP_CPU_PROFILE.sum_2)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SUM_2"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SUM_2'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by preprocessor semantics'''
depends_on = ['ilp_cpu_profile_macro_context_sensitivity']
reviewed = true

[[axioms]]
id = "macro_ilp_n_sum_2_anti_pattern_global_dependency"
content = '''Using this macro creates an implicit dependency on ILP_CPU_PROFILE being defined in scope; consider using the qualified name directly for clarity'''
formal_spec = '''implicit_dependency(ILP_N_SUM_2, ILP_CPU_PROFILE)'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "ILP_N_SUM_2"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SUM_2'''
axiom_type = "anti_pattern"
on_violation = '''Reduced code clarity and maintainability'''
depends_on = ['ilp_n_shift_4_macro_anti_pattern_global_dependency']
reviewed = true

[[axioms]]
id = "macro_ilp_n_sum_2_complexity"
content = '''Macro expansion incurs zero runtime cost; it is purely a compile-time textual substitution'''
formal_spec = '''runtime_cost(ILP_N_SUM_2) = O(1) ∧ expansion_time(ILP_N_SUM_2) = O(1)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SUM_2"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SUM_2'''
axiom_type = "complexity"
on_violation = '''N/A - guaranteed by preprocessor'''
depends_on = ['ilp_cpu_profile_macro_simple_substitution']
reviewed = true

[[axioms]]
id = "macro_ilp_n_sum_4i_precondition_ilp_cpu_profile_defined"
content = '''ILP_CPU_PROFILE must be defined and in scope before using ILP_N_SUM_4I'''
formal_spec = '''defined(ILP_CPU_PROFILE) ∧ in_scope(ILP_CPU_PROFILE)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SUM_4I"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SUM_4I'''
axiom_type = "precondition"
on_violation = '''Compilation error: ILP_CPU_PROFILE not defined'''
depends_on = ['ilp_cpu_profile_macro_context_sensitivity', 'ilp_n_shift_4_macro_anti_pattern_global_dependency']
reviewed = true

[[axioms]]
id = "macro_ilp_n_sum_4i_precondition_sum_4i_member"
content = '''ILP_CPU_PROFILE must have a member named sum_4i accessible at the point of use'''
formal_spec = '''has_member(ILP_CPU_PROFILE, sum_4i) ∧ is_accessible(ILP_CPU_PROFILE.sum_4i)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SUM_4I"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SUM_4I'''
axiom_type = "precondition"
on_violation = '''Compilation error: no member named 'sum_4i' in ILP_CPU_PROFILE'''
depends_on = ['ilp_cpu_profile_macro_expansion']
reviewed = true

[[axioms]]
id = "macro_ilp_n_sum_4i_expansion"
content = '''After macro expansion, ILP_N_SUM_4I is textually replaced with ILP_CPU_PROFILE.sum_4i'''
formal_spec = '''expansion(ILP_N_SUM_4I) == 'ILP_CPU_PROFILE.sum_4i''''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SUM_4I"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SUM_4I'''
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed by preprocessor'''
depends_on = ['ilp_cpu_profile_macro_simple_substitution']
reviewed = true

[[axioms]]
id = "macro_ilp_n_sum_4i_effect_simple_substitution"
content = '''ILP_N_SUM_4I performs simple textual substitution with no arguments, no multiple evaluation, and no side effects'''
formal_spec = '''no_side_effects(ILP_N_SUM_4I) ∧ evaluation_count(ILP_N_SUM_4I) = 0'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SUM_4I"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SUM_4I'''
axiom_type = "effect"
on_violation = '''N/A - object-like macro'''
depends_on = ['ilp_cpu_profile_macro_simple_substitution']
reviewed = true

[[axioms]]
id = "macro_ilp_n_sum_4i_effect_lvalue"
content = '''Any modification to ILP_N_SUM_4I directly modifies ILP_CPU_PROFILE.sum_4i (lvalue semantics preserved)'''
formal_spec = '''is_lvalue(ILP_N_SUM_4I) == is_lvalue(ILP_CPU_PROFILE.sum_4i) ∧ address_of(ILP_N_SUM_4I) == address_of(ILP_CPU_PROFILE.sum_4i)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SUM_4I"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SUM_4I'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by macro expansion'''
depends_on = ['cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b', 'cpp20_expr_cast_lvalue_result_d4e8a1c3', 'cpp20_basic_lval_temp_materialization_b4e9f1c5']
reviewed = true

[[axioms]]
id = "macro_ilp_n_sum_4i_context_sensitivity"
content = '''The meaning of ILP_N_SUM_4I depends on the definition of ILP_CPU_PROFILE at the point of use, not at the point of macro definition'''
formal_spec = '''semantic_binding(ILP_N_SUM_4I) == binding_at_use_site(ILP_CPU_PROFILE.sum_4i)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SUM_4I"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SUM_4I'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by macro expansion semantics'''
depends_on = ['ilp_cpu_profile_macro_context_sensitivity']
reviewed = true

[[axioms]]
id = "macro_ilp_n_sum_4i_anti_pattern_global_dependency"
content = '''Using this macro creates an implicit dependency on ILP_CPU_PROFILE being defined in scope; consider using ILP_CPU_PROFILE.sum_4i directly for clarity'''
formal_spec = '''implicit_dependency(ILP_N_SUM_4I, ILP_CPU_PROFILE)'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "ILP_N_SUM_4I"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SUM_4I'''
axiom_type = "anti_pattern"
on_violation = '''Reduced code clarity and maintainability'''
depends_on = ['ilp_n_shift_4_macro_anti_pattern_global_dependency']
reviewed = true

[[axioms]]
id = "macro_ilp_n_sum_4i_complexity_zero_overhead"
content = '''ILP_N_SUM_4I has zero runtime overhead as it is resolved entirely at preprocessing time'''
formal_spec = '''runtime_cost(ILP_N_SUM_4I) = O(1) ∧ preprocessing_cost(ILP_N_SUM_4I) = O(1)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SUM_4I"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SUM_4I'''
axiom_type = "complexity"
on_violation = '''N/A - guaranteed by macro expansion'''
depends_on = ['ilp_cpu_profile_macro_simple_substitution']
reviewed = true

[[axioms]]
id = "macro_ilp_n_sum_8i_precondition_profile_defined"
content = '''ILP_CPU_PROFILE must be defined in scope before using ILP_N_SUM_8I'''
formal_spec = '''defined(ILP_CPU_PROFILE) == true at use_site(ILP_N_SUM_8I)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SUM_8I"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SUM_8I'''
axiom_type = "precondition"
on_violation = '''Compilation error: undefined macro ILP_CPU_PROFILE'''
depends_on = ['ilp_cpu_profile_macro_context_sensitivity', 'ilp_n_shift_4_macro_anti_pattern_global_dependency']
reviewed = true

[[axioms]]
id = "macro_ilp_n_sum_8i_precondition_member_exists"
content = '''ILP_CPU_PROFILE must expand to an object with a member named sum_8i'''
formal_spec = '''has_member(expansion(ILP_CPU_PROFILE), 'sum_8i') == true'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SUM_8I"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SUM_8I'''
axiom_type = "precondition"
on_violation = '''Compilation error: no member named 'sum_8i''''
depends_on = ['ilp_cpu_profile_macro_expansion']
reviewed = true

[[axioms]]
id = "macro_ilp_n_sum_8i_postcondition_expansion"
content = '''After macro expansion, ILP_N_SUM_8I is textually replaced with ILP_CPU_PROFILE.sum_8i'''
formal_spec = '''expansion(ILP_N_SUM_8I) == 'ILP_CPU_PROFILE.sum_8i''''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SUM_8I"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SUM_8I'''
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed by preprocessor'''
depends_on = ['ilp_cpu_profile_macro_simple_substitution']
reviewed = true

[[axioms]]
id = "macro_ilp_n_sum_8i_effect_no_side_effects"
content = '''ILP_N_SUM_8I performs simple textual substitution with no side effects and no argument evaluation (object-like macro)'''
formal_spec = '''no_side_effects(ILP_N_SUM_8I) ∧ evaluation_count(ILP_N_SUM_8I) = 0'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SUM_8I"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SUM_8I'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by macro design'''
depends_on = ['ilp_cpu_profile_macro_simple_substitution']
reviewed = true

[[axioms]]
id = "macro_ilp_n_sum_8i_effect_lvalue"
content = '''Any modification to ILP_N_SUM_8I directly modifies ILP_CPU_PROFILE.sum_8i (lvalue semantics preserved)'''
formal_spec = '''is_lvalue(ILP_N_SUM_8I) == is_lvalue(ILP_CPU_PROFILE.sum_8i) && address_of(ILP_N_SUM_8I) == address_of(ILP_CPU_PROFILE.sum_8i)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SUM_8I"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SUM_8I'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by textual substitution'''
depends_on = ['cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b', 'cpp20_expr_cast_lvalue_result_d4e8a1c3', 'cpp20_basic_lval_temp_materialization_b4e9f1c5']
reviewed = true

[[axioms]]
id = "macro_ilp_n_sum_8i_effect_context_sensitivity"
content = '''The meaning of ILP_N_SUM_8I depends on the definition of ILP_CPU_PROFILE at the point of use, not at the point of ILP_N_SUM_8I definition'''
formal_spec = '''semantic_binding(ILP_N_SUM_8I) == binding_at_use_site(ILP_CPU_PROFILE.sum_8i)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SUM_8I"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SUM_8I'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by macro expansion order'''
depends_on = ['ilp_cpu_profile_macro_context_sensitivity']
reviewed = true

[[axioms]]
id = "macro_ilp_n_sum_8i_anti_pattern_global_dependency"
content = '''Using this macro creates an implicit dependency on ILP_CPU_PROFILE being defined in scope; consider using ILP_CPU_PROFILE.sum_8i directly for clarity'''
formal_spec = '''implicit_dependency(ILP_N_SUM_8I, ILP_CPU_PROFILE)'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "ILP_N_SUM_8I"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SUM_8I'''
axiom_type = "anti_pattern"
on_violation = '''Reduced code clarity and maintainability'''
depends_on = ['ilp_n_shift_4_macro_anti_pattern_global_dependency']
reviewed = true

[[axioms]]
id = "macro_ilp_n_sum_8i_complexity_zero_overhead"
content = '''ILP_N_SUM_8I has zero runtime overhead as it is a compile-time textual substitution'''
formal_spec = '''runtime_cost(ILP_N_SUM_8I) = O(1) = cost(ILP_CPU_PROFILE.sum_8i)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SUM_8I"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SUM_8I'''
axiom_type = "complexity"
on_violation = '''N/A - guaranteed by preprocessor'''
depends_on = ['ilp_cpu_profile_macro_simple_substitution']
reviewed = true

[[axioms]]
id = "macro_ilp_n_sum_4f_precondition_profile_defined"
content = '''ILP_CPU_PROFILE must be defined and in scope before using ILP_N_SUM_4F'''
formal_spec = '''defined(ILP_CPU_PROFILE) at expansion_point(ILP_N_SUM_4F)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SUM_4F"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SUM_4F'''
axiom_type = "precondition"
on_violation = '''Compilation error: undefined identifier'''
depends_on = ['ilp_cpu_profile_macro_context_sensitivity', 'ilp_n_shift_4_macro_anti_pattern_global_dependency']
reviewed = true

[[axioms]]
id = "macro_ilp_n_sum_4f_precondition_member_exists"
content = '''ILP_CPU_PROFILE must have a member named sum_4f at the point of macro use'''
formal_spec = '''has_member(expansion(ILP_CPU_PROFILE), 'sum_4f') at expansion_point(ILP_N_SUM_4F)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SUM_4F"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SUM_4F'''
axiom_type = "precondition"
on_violation = '''Compilation error: no member named 'sum_4f''''
depends_on = ['ilp_cpu_profile_macro_expansion', 'ilp_cpu_profile_macro_context_sensitivity']
reviewed = true

[[axioms]]
id = "macro_ilp_n_sum_4f_postcondition_expansion"
content = '''After macro expansion, ILP_N_SUM_4F is textually replaced with ILP_CPU_PROFILE.sum_4f'''
formal_spec = '''expansion(ILP_N_SUM_4F) == concat(expansion(ILP_CPU_PROFILE), '.sum_4f')'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SUM_4F"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SUM_4F'''
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed by preprocessor'''
depends_on = ['ilp_cpu_profile_macro_expansion', 'ilp_cpu_profile_macro_simple_substitution']
reviewed = true

[[axioms]]
id = "macro_ilp_n_sum_4f_effect_no_side_effects"
content = '''ILP_N_SUM_4F performs simple textual substitution with no arguments, no multiple evaluation, and no side effects'''
formal_spec = '''no_side_effects(ILP_N_SUM_4F) ∧ evaluation_count(ILP_N_SUM_4F) = 0'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SUM_4F"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SUM_4F'''
axiom_type = "effect"
on_violation = '''N/A - no side effects possible'''
depends_on = ['ilp_cpu_profile_macro_simple_substitution']
reviewed = true

[[axioms]]
id = "macro_ilp_n_sum_4f_effect_lvalue"
content = '''Any modification to ILP_N_SUM_4F directly modifies ILP_CPU_PROFILE.sum_4f (lvalue semantics preserved)'''
formal_spec = '''is_lvalue(ILP_N_SUM_4F) == is_lvalue(ILP_CPU_PROFILE.sum_4f) && address_of(ILP_N_SUM_4F) == address_of(ILP_CPU_PROFILE.sum_4f)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SUM_4F"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SUM_4F'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by textual substitution'''
depends_on = ['cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b', 'cpp20_expr_cast_lvalue_result_d4e8a1c3', 'cpp20_basic_lval_temp_materialization_b4e9f1c5']
reviewed = true

[[axioms]]
id = "macro_ilp_n_sum_4f_anti_pattern_global_dependency"
content = '''Using this macro creates an implicit dependency on ILP_CPU_PROFILE being defined in scope; consider using the qualified name directly for clarity'''
formal_spec = '''implicit_dependency(ILP_N_SUM_4F, ILP_CPU_PROFILE)'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "ILP_N_SUM_4F"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SUM_4F'''
axiom_type = "anti_pattern"
on_violation = '''Reduced code clarity and maintainability'''
depends_on = ['ilp_n_shift_4_macro_anti_pattern_global_dependency', 'ilp_cpu_profile_macro_context_sensitivity']
reviewed = true

[[axioms]]
id = "macro_ilp_n_sum_4f_constraint_context_sensitivity"
content = '''The meaning of ILP_N_SUM_4F depends on the definition of ILP_CPU_PROFILE at the point of use, not at the point of macro definition'''
formal_spec = '''semantic_binding(ILP_N_SUM_4F) == binding_at_use_site(ILP_CPU_PROFILE.sum_4f)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SUM_4F"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SUM_4F'''
axiom_type = "constraint"
on_violation = '''Incorrect value accessed if ILP_CPU_PROFILE is redefined between macro definition and use'''
depends_on = ['ilp_cpu_profile_macro_context_sensitivity']
reviewed = true

[[axioms]]
id = "macro_ilp_n_sum_8f_precondition_profile_defined"
content = '''ILP_CPU_PROFILE must be defined and in scope before ILP_N_SUM_8F is used'''
formal_spec = '''is_defined(ILP_CPU_PROFILE) ∧ in_scope(ILP_CPU_PROFILE)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SUM_8F"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SUM_8F'''
axiom_type = "precondition"
on_violation = '''Compilation error: undefined identifier'''
depends_on = ['ilp_cpu_profile_macro_context_sensitivity', 'ilp_n_shift_4_macro_anti_pattern_global_dependency']
reviewed = true

[[axioms]]
id = "macro_ilp_n_sum_8f_precondition_member_exists"
content = '''ILP_CPU_PROFILE must have a member named sum_8f accessible at the point of use'''
formal_spec = '''has_member(expansion(ILP_CPU_PROFILE), 'sum_8f') ∧ is_accessible(ILP_CPU_PROFILE.sum_8f)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SUM_8F"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SUM_8F'''
axiom_type = "precondition"
on_violation = '''Compilation error: no member named 'sum_8f''''
depends_on = ['ilp_cpu_profile_macro_expansion']
reviewed = true

[[axioms]]
id = "macro_ilp_n_sum_8f_expansion"
content = '''After macro expansion, ILP_N_SUM_8F is textually replaced with ILP_CPU_PROFILE.sum_8f'''
formal_spec = '''expansion(ILP_N_SUM_8F) == 'ILP_CPU_PROFILE.sum_8f''''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SUM_8F"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SUM_8F'''
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed by preprocessor'''
depends_on = ['ilp_cpu_profile_macro_expansion']
reviewed = true

[[axioms]]
id = "macro_ilp_n_sum_8f_effect_simple_substitution"
content = '''ILP_N_SUM_8F performs simple textual substitution with no arguments, no multiple evaluation, and no side effects'''
formal_spec = '''no_side_effects(ILP_N_SUM_8F) ∧ evaluation_count(ILP_N_SUM_8F) = 0'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SUM_8F"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SUM_8F'''
axiom_type = "effect"
on_violation = '''N/A - macro has no arguments to evaluate'''
depends_on = ['ilp_cpu_profile_macro_simple_substitution']
reviewed = true

[[axioms]]
id = "macro_ilp_n_sum_8f_effect_lvalue"
content = '''Any modification to ILP_N_SUM_8F directly modifies ILP_CPU_PROFILE.sum_8f (lvalue semantics preserved)'''
formal_spec = '''is_lvalue(ILP_N_SUM_8F) == is_lvalue(ILP_CPU_PROFILE.sum_8f) ∧ address_of(ILP_N_SUM_8F) == address_of(ILP_CPU_PROFILE.sum_8f)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SUM_8F"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SUM_8F'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by textual substitution'''
depends_on = ['cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b', 'cpp20_expr_cast_lvalue_result_d4e8a1c3', 'cpp20_basic_lval_temp_materialization_b4e9f1c5']
reviewed = true

[[axioms]]
id = "macro_ilp_n_sum_8f_context_sensitivity"
content = '''The meaning of ILP_N_SUM_8F depends on the definition of ILP_CPU_PROFILE at the point of use, not at the point of macro definition'''
formal_spec = '''semantic_binding(ILP_N_SUM_8F) == binding_at_use_site(ILP_CPU_PROFILE.sum_8f)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SUM_8F"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SUM_8F'''
axiom_type = "effect"
on_violation = '''N/A - context-dependent binding is inherent to macros'''
depends_on = ['ilp_cpu_profile_macro_context_sensitivity']
reviewed = true

[[axioms]]
id = "macro_ilp_n_sum_8f_anti_pattern_global_dependency"
content = '''Using this macro creates an implicit dependency on ILP_CPU_PROFILE being defined in scope; consider using the qualified name directly for clarity'''
formal_spec = '''implicit_dependency(ILP_N_SUM_8F, ILP_CPU_PROFILE)'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "ILP_N_SUM_8F"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SUM_8F'''
axiom_type = "anti_pattern"
on_violation = '''Reduced code clarity and maintainability'''
depends_on = ['ilp_n_shift_4_macro_anti_pattern_global_dependency']
reviewed = true

[[axioms]]
id = "macro_ilp_n_dotproduct_4_precondition_ilp_cpu_profile_defined"
content = '''ILP_CPU_PROFILE must be defined and in scope before ILP_N_DOTPRODUCT_4 is used'''
formal_spec = '''is_defined(ILP_CPU_PROFILE) ∧ in_scope(ILP_CPU_PROFILE)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_DOTPRODUCT_4"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_DOTPRODUCT_4'''
axiom_type = "precondition"
on_violation = '''Compilation error: ILP_CPU_PROFILE is not defined'''
depends_on = ['ilp_cpu_profile_macro_context_sensitivity', 'ilp_n_shift_4_macro_anti_pattern_global_dependency']
reviewed = true

[[axioms]]
id = "macro_ilp_n_dotproduct_4_precondition_dotproduct_4_member"
content = '''ILP_CPU_PROFILE must have a member named dotproduct_4'''
formal_spec = '''has_member(ILP_CPU_PROFILE, 'dotproduct_4')'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_DOTPRODUCT_4"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_DOTPRODUCT_4'''
axiom_type = "precondition"
on_violation = '''Compilation error: ILP_CPU_PROFILE has no member dotproduct_4'''
depends_on = ['ilp_cpu_profile_macro_expansion']
reviewed = true

[[axioms]]
id = "macro_ilp_n_dotproduct_4_expansion"
content = '''After macro expansion, ILP_N_DOTPRODUCT_4 is textually replaced with ILP_CPU_PROFILE.dotproduct_4'''
formal_spec = '''expansion(ILP_N_DOTPRODUCT_4) == 'ILP_CPU_PROFILE.dotproduct_4''''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_DOTPRODUCT_4"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_DOTPRODUCT_4'''
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed by preprocessor'''
depends_on = ['ilp_cpu_profile_macro_expansion']
reviewed = true

[[axioms]]
id = "macro_ilp_n_dotproduct_4_effect_no_side_effects"
content = '''ILP_N_DOTPRODUCT_4 performs simple textual substitution with no arguments, no multiple evaluation, and no side effects'''
formal_spec = '''no_side_effects(ILP_N_DOTPRODUCT_4) ∧ evaluation_count(ILP_N_DOTPRODUCT_4) = 0'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_DOTPRODUCT_4"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_DOTPRODUCT_4'''
axiom_type = "effect"
on_violation = '''N/A - no side effects possible'''
depends_on = ['ilp_cpu_profile_macro_simple_substitution']
reviewed = true

[[axioms]]
id = "macro_ilp_n_dotproduct_4_effect_lvalue"
content = '''Any modification to ILP_N_DOTPRODUCT_4 directly modifies ILP_CPU_PROFILE.dotproduct_4 (lvalue semantics preserved)'''
formal_spec = '''is_lvalue(ILP_N_DOTPRODUCT_4) == is_lvalue(ILP_CPU_PROFILE.dotproduct_4) && address_of(ILP_N_DOTPRODUCT_4) == address_of(ILP_CPU_PROFILE.dotproduct_4)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_DOTPRODUCT_4"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_DOTPRODUCT_4'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by textual substitution'''
depends_on = ['cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b', 'cpp20_expr_cast_lvalue_result_d4e8a1c3', 'cpp20_basic_lval_temp_materialization_b4e9f1c5']
reviewed = true

[[axioms]]
id = "macro_ilp_n_dotproduct_4_anti_pattern_global_dependency"
content = '''Using this macro creates an implicit dependency on ILP_CPU_PROFILE being defined in scope; consider using the qualified name directly for clarity'''
formal_spec = '''implicit_dependency(ILP_N_DOTPRODUCT_4, ILP_CPU_PROFILE)'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "ILP_N_DOTPRODUCT_4"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_DOTPRODUCT_4'''
axiom_type = "anti_pattern"
on_violation = '''Reduced code clarity and maintainability'''
depends_on = ['ilp_n_shift_4_macro_anti_pattern_global_dependency', 'ilp_cpu_profile_macro_context_sensitivity']
reviewed = true

[[axioms]]
id = "macro_ilp_n_dotproduct_4_context_sensitivity"
content = '''The meaning of ILP_N_DOTPRODUCT_4 depends on the definition of ILP_CPU_PROFILE at the point of use, not at the point of macro definition'''
formal_spec = '''semantic_binding(ILP_N_DOTPRODUCT_4) == binding_at_use_site(ILP_CPU_PROFILE.dotproduct_4)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_DOTPRODUCT_4"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_DOTPRODUCT_4'''
axiom_type = "effect"
on_violation = '''N/A - inherent macro behavior'''
depends_on = ['ilp_cpu_profile_macro_context_sensitivity']
reviewed = true

[[axioms]]
id = "macro_ilp_n_dotproduct_8_precondition_ilp_cpu_profile_defined"
content = '''ILP_CPU_PROFILE must be defined and in scope before using ILP_N_DOTPRODUCT_8'''
formal_spec = '''defined(ILP_CPU_PROFILE) at point_of_use(ILP_N_DOTPRODUCT_8)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_DOTPRODUCT_8"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_DOTPRODUCT_8'''
axiom_type = "precondition"
on_violation = '''Compilation error: ILP_CPU_PROFILE undefined'''
depends_on = ['ilp_cpu_profile_macro_context_sensitivity', 'ilp_n_shift_4_macro_anti_pattern_global_dependency']
reviewed = true

[[axioms]]
id = "macro_ilp_n_dotproduct_8_precondition_dotproduct_8_member"
content = '''ILP_CPU_PROFILE must have a member named dotproduct_8'''
formal_spec = '''has_member(ILP_CPU_PROFILE, 'dotproduct_8')'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_DOTPRODUCT_8"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_DOTPRODUCT_8'''
axiom_type = "precondition"
on_violation = '''Compilation error: no member named 'dotproduct_8' in ILP_CPU_PROFILE'''
depends_on = ['ilp_cpu_profile_macro_expansion']
reviewed = true

[[axioms]]
id = "macro_ilp_n_dotproduct_8_expansion"
content = '''After macro expansion, ILP_N_DOTPRODUCT_8 is textually replaced with ILP_CPU_PROFILE.dotproduct_8'''
formal_spec = '''expansion(ILP_N_DOTPRODUCT_8) == 'ILP_CPU_PROFILE.dotproduct_8''''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_DOTPRODUCT_8"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_DOTPRODUCT_8'''
axiom_type = "postcondition"
on_violation = '''N/A - this is the definition'''
depends_on = ['ilp_cpu_profile_macro_simple_substitution']
reviewed = true

[[axioms]]
id = "macro_ilp_n_dotproduct_8_effect_no_side_effects"
content = '''ILP_N_DOTPRODUCT_8 performs simple textual substitution with no side effects and no multiple evaluation'''
formal_spec = '''no_side_effects(ILP_N_DOTPRODUCT_8) ∧ evaluation_count(ILP_N_DOTPRODUCT_8) = 0'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_DOTPRODUCT_8"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_DOTPRODUCT_8'''
axiom_type = "effect"
on_violation = '''N/A - this is guaranteed by the macro definition'''
depends_on = ['ilp_cpu_profile_macro_simple_substitution']
reviewed = true

[[axioms]]
id = "macro_ilp_n_dotproduct_8_effect_lvalue_preserved"
content = '''Any modification to ILP_N_DOTPRODUCT_8 directly modifies ILP_CPU_PROFILE.dotproduct_8 (lvalue semantics preserved)'''
formal_spec = '''is_lvalue(ILP_N_DOTPRODUCT_8) == is_lvalue(ILP_CPU_PROFILE.dotproduct_8) ∧ address_of(ILP_N_DOTPRODUCT_8) == address_of(ILP_CPU_PROFILE.dotproduct_8)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_DOTPRODUCT_8"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_DOTPRODUCT_8'''
axiom_type = "effect"
on_violation = '''N/A - this is guaranteed by textual substitution'''
depends_on = ['cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b', 'cpp20_expr_cast_lvalue_result_d4e8a1c3', 'cpp20_basic_lval_temp_materialization_b4e9f1c5']
reviewed = true

[[axioms]]
id = "macro_ilp_n_dotproduct_8_context_sensitivity"
content = '''The meaning of ILP_N_DOTPRODUCT_8 depends on the definition of ILP_CPU_PROFILE at the point of use, not at the point of macro definition'''
formal_spec = '''semantic_binding(ILP_N_DOTPRODUCT_8) == binding_at_use_site(ILP_CPU_PROFILE.dotproduct_8)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_DOTPRODUCT_8"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_DOTPRODUCT_8'''
axiom_type = "effect"
on_violation = '''N/A - this is inherent to macro semantics'''
depends_on = ['ilp_cpu_profile_macro_context_sensitivity']
reviewed = true

[[axioms]]
id = "macro_ilp_n_dotproduct_8_anti_pattern_global_dependency"
content = '''Using this macro creates an implicit dependency on ILP_CPU_PROFILE being defined in scope; consider using the qualified name ILP_CPU_PROFILE.dotproduct_8 directly for clarity'''
formal_spec = '''implicit_dependency(ILP_N_DOTPRODUCT_8, ILP_CPU_PROFILE)'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "ILP_N_DOTPRODUCT_8"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_DOTPRODUCT_8'''
axiom_type = "anti_pattern"
on_violation = '''Reduced code clarity and maintainability'''
depends_on = ['ilp_n_shift_4_macro_anti_pattern_global_dependency']
reviewed = true

[[axioms]]
id = "macro_ilp_n_dotproduct_8_complexity_zero_overhead"
content = '''ILP_N_DOTPRODUCT_8 has zero runtime overhead as it is a compile-time textual substitution'''
formal_spec = '''runtime_cost(ILP_N_DOTPRODUCT_8) = 0'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_DOTPRODUCT_8"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_DOTPRODUCT_8'''
axiom_type = "complexity"
on_violation = '''N/A - this is guaranteed by macro expansion'''
depends_on = ['ilp_cpu_profile_macro_simple_substitution']
reviewed = true

[[axioms]]
id = "macro_ilp_n_search_1_precondition_ilp_cpu_profile_defined"
content = '''ILP_CPU_PROFILE must be defined and accessible in the scope where ILP_N_SEARCH_1 is used'''
formal_spec = '''is_defined(ILP_CPU_PROFILE) ∧ in_scope(ILP_CPU_PROFILE)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SEARCH_1"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SEARCH_1'''
axiom_type = "precondition"
on_violation = '''Compilation error: undefined identifier'''
depends_on = ['ilp_cpu_profile_macro_context_sensitivity', 'ilp_n_shift_4_macro_anti_pattern_global_dependency']
reviewed = true

[[axioms]]
id = "macro_ilp_n_search_1_precondition_search_1_member"
content = '''ILP_CPU_PROFILE must have a member named search_1'''
formal_spec = '''has_member(ILP_CPU_PROFILE, 'search_1')'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SEARCH_1"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SEARCH_1'''
axiom_type = "precondition"
on_violation = '''Compilation error: no member named 'search_1''''
depends_on = ['ilp_cpu_profile_macro_expansion']
reviewed = true

[[axioms]]
id = "macro_ilp_n_search_1_expansion"
content = '''After macro expansion, ILP_N_SEARCH_1 is textually replaced with ILP_CPU_PROFILE.search_1'''
formal_spec = '''expansion(ILP_N_SEARCH_1) == 'ILP_CPU_PROFILE.search_1''''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SEARCH_1"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SEARCH_1'''
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed by preprocessor'''
depends_on = ['ilp_cpu_profile_macro_simple_substitution']
reviewed = true

[[axioms]]
id = "macro_ilp_n_search_1_effect_no_side_effects"
content = '''ILP_N_SEARCH_1 performs simple textual substitution with no side effects and no evaluation (no parameters)'''
formal_spec = '''no_side_effects(ILP_N_SEARCH_1) ∧ evaluation_count(ILP_N_SEARCH_1) = 0'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SEARCH_1"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SEARCH_1'''
axiom_type = "effect"
on_violation = '''N/A - no parameters to evaluate'''
depends_on = ['ilp_cpu_profile_macro_simple_substitution']
reviewed = true

[[axioms]]
id = "macro_ilp_n_search_1_effect_lvalue"
content = '''Any modification to ILP_N_SEARCH_1 directly modifies ILP_CPU_PROFILE.search_1 (lvalue semantics preserved)'''
formal_spec = '''is_lvalue(ILP_N_SEARCH_1) == is_lvalue(ILP_CPU_PROFILE.search_1) ∧ address_of(ILP_N_SEARCH_1) == address_of(ILP_CPU_PROFILE.search_1)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SEARCH_1"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SEARCH_1'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by textual substitution'''
depends_on = ['cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b', 'cpp20_expr_cast_lvalue_result_d4e8a1c3', 'cpp20_basic_lval_temp_materialization_b4e9f1c5']
reviewed = true

[[axioms]]
id = "macro_ilp_n_search_1_context_sensitivity"
content = '''The meaning of ILP_N_SEARCH_1 depends on the definition of ILP_CPU_PROFILE at the point of use, not at the point of macro definition'''
formal_spec = '''semantic_binding(ILP_N_SEARCH_1) == binding_at_use_site(ILP_CPU_PROFILE.search_1)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SEARCH_1"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SEARCH_1'''
axiom_type = "effect"
on_violation = '''Unexpected behavior if ILP_CPU_PROFILE is redefined'''
depends_on = ['ilp_cpu_profile_macro_context_sensitivity']
reviewed = true

[[axioms]]
id = "macro_ilp_n_search_1_anti_pattern_global_dependency"
content = '''Using this macro creates an implicit dependency on ILP_CPU_PROFILE being defined in scope; consider using the qualified name directly for clarity'''
formal_spec = '''implicit_dependency(ILP_N_SEARCH_1, ILP_CPU_PROFILE)'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "ILP_N_SEARCH_1"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SEARCH_1'''
axiom_type = "anti_pattern"
on_violation = '''Reduced code clarity and maintainability'''
depends_on = ['ilp_n_shift_4_macro_anti_pattern_global_dependency']
reviewed = true

[[axioms]]
id = "macro_ilp_n_search_1_complexity_zero_overhead"
content = '''ILP_N_SEARCH_1 has zero runtime overhead - it is purely a compile-time textual substitution'''
formal_spec = '''runtime_overhead(ILP_N_SEARCH_1) = 0'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SEARCH_1"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SEARCH_1'''
axiom_type = "complexity"
on_violation = '''N/A - guaranteed by preprocessor'''
depends_on = ['ilp_cpu_profile_macro_simple_substitution']
reviewed = true

[[axioms]]
id = "macro_ilp_n_search_2_precondition_ilp_cpu_profile_defined"
content = '''ILP_CPU_PROFILE must be defined and in scope before using ILP_N_SEARCH_2'''
formal_spec = '''defined(ILP_CPU_PROFILE) ∧ in_scope(ILP_CPU_PROFILE)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SEARCH_2"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SEARCH_2'''
axiom_type = "precondition"
on_violation = '''Compilation error: ILP_CPU_PROFILE is not defined'''
depends_on = ['ilp_cpu_profile_macro_expansion', 'ilp_n_shift_4_macro_anti_pattern_global_dependency']
reviewed = true

[[axioms]]
id = "macro_ilp_n_search_2_precondition_member_exists"
content = '''ILP_CPU_PROFILE must have a member named search_2 accessible in the current context'''
formal_spec = '''has_member(ILP_CPU_PROFILE, 'search_2') ∧ is_accessible(ILP_CPU_PROFILE.search_2)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SEARCH_2"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SEARCH_2'''
axiom_type = "precondition"
on_violation = '''Compilation error: no member named 'search_2' in ILP_CPU_PROFILE'''
depends_on = ['ilp_cpu_profile_macro_expansion']
reviewed = true

[[axioms]]
id = "macro_ilp_n_search_2_expansion"
content = '''After macro expansion, ILP_N_SEARCH_2 is textually replaced with ILP_CPU_PROFILE.search_2'''
formal_spec = '''expansion(ILP_N_SEARCH_2) == 'ILP_CPU_PROFILE.search_2''''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SEARCH_2"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SEARCH_2'''
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed by preprocessor'''
depends_on = ['ilp_cpu_profile_macro_simple_substitution']
reviewed = true

[[axioms]]
id = "macro_ilp_n_search_2_effect_no_side_effects"
content = '''ILP_N_SEARCH_2 performs simple textual substitution with no arguments, no multiple evaluation, and no side effects'''
formal_spec = '''no_side_effects(ILP_N_SEARCH_2) ∧ evaluation_count(ILP_N_SEARCH_2) = 0'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SEARCH_2"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SEARCH_2'''
axiom_type = "effect"
on_violation = '''N/A - no side effects possible'''
depends_on = ['ilp_cpu_profile_macro_simple_substitution']
reviewed = true

[[axioms]]
id = "macro_ilp_n_search_2_effect_lvalue"
content = '''Any modification to ILP_N_SEARCH_2 directly modifies ILP_CPU_PROFILE.search_2 (lvalue semantics preserved)'''
formal_spec = '''is_lvalue(ILP_N_SEARCH_2) == is_lvalue(ILP_CPU_PROFILE.search_2) ∧ address_of(ILP_N_SEARCH_2) == address_of(ILP_CPU_PROFILE.search_2)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SEARCH_2"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SEARCH_2'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by textual substitution'''
depends_on = ['cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b', 'cpp20_expr_cast_lvalue_result_d4e8a1c3', 'cpp20_basic_lval_temp_materialization_b4e9f1c5']
reviewed = true

[[axioms]]
id = "macro_ilp_n_search_2_context_sensitivity"
content = '''The meaning of ILP_N_SEARCH_2 depends on the definition of ilp::cpu::default_profile at the point of use, not at the point of macro definition'''
formal_spec = '''semantic_binding(ILP_N_SEARCH_2) == binding_at_use_site(ilp::cpu::default_profile.search_2)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SEARCH_2"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SEARCH_2'''
axiom_type = "effect"
on_violation = '''N/A - but changes to default_profile affect all uses'''
depends_on = ['ilp_cpu_profile_macro_context_sensitivity']
reviewed = true

[[axioms]]
id = "macro_ilp_n_search_2_anti_pattern_global_dependency"
content = '''Using this macro creates an implicit dependency on ILP_CPU_PROFILE being defined in scope; consider using the qualified name directly for clarity'''
formal_spec = '''implicit_dependency(ILP_N_SEARCH_2, ILP_CPU_PROFILE)'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "ILP_N_SEARCH_2"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SEARCH_2'''
axiom_type = "anti_pattern"
on_violation = '''Reduced code clarity and maintainability'''
depends_on = ['ilp_n_shift_4_macro_anti_pattern_global_dependency']
reviewed = true

[[axioms]]
id = "macro_ilp_n_search_2_complexity_zero_overhead"
content = '''Macro expansion has zero runtime overhead - it is purely a compile-time textual substitution'''
formal_spec = '''runtime_cost(ILP_N_SEARCH_2) = O(1) ∧ expansion_time(ILP_N_SEARCH_2) = O(1)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SEARCH_2"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SEARCH_2'''
axiom_type = "complexity"
on_violation = '''N/A - guaranteed by preprocessor'''
depends_on = ['ilp_cpu_profile_macro_simple_substitution']
reviewed = true

[[axioms]]
id = "macro_ilp_n_search_4_precondition_ilp_cpu_profile_defined"
content = '''ILP_CPU_PROFILE must be defined and in scope before using ILP_N_SEARCH_4'''
formal_spec = '''is_defined(ILP_CPU_PROFILE) ∧ in_scope(ILP_CPU_PROFILE)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SEARCH_4"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SEARCH_4'''
axiom_type = "precondition"
on_violation = '''Compilation error due to undefined macro ILP_CPU_PROFILE'''
depends_on = ['ilp_cpu_profile_macro_expansion', 'ilp_n_shift_4_macro_anti_pattern_global_dependency']
reviewed = true

[[axioms]]
id = "macro_ilp_n_search_4_precondition_search_4_member"
content = '''The expansion of ILP_CPU_PROFILE must have a member named search_4'''
formal_spec = '''has_member(expansion(ILP_CPU_PROFILE), 'search_4')'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SEARCH_4"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SEARCH_4'''
axiom_type = "precondition"
on_violation = '''Compilation error due to missing member search_4'''
depends_on = ['ilp_cpu_profile_macro_expansion']
reviewed = true

[[axioms]]
id = "macro_ilp_n_search_4_postcondition_expansion"
content = '''After macro expansion, ILP_N_SEARCH_4 is textually replaced with ILP_CPU_PROFILE.search_4'''
formal_spec = '''expansion(ILP_N_SEARCH_4) == expansion(ILP_CPU_PROFILE) + '.search_4''''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SEARCH_4"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SEARCH_4'''
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed by preprocessor'''
depends_on = ['ilp_cpu_profile_macro_expansion']
reviewed = true

[[axioms]]
id = "macro_ilp_n_search_4_effect_simple_substitution"
content = '''ILP_N_SEARCH_4 performs simple textual substitution with no arguments, no multiple evaluation, and no side effects'''
formal_spec = '''no_side_effects(ILP_N_SEARCH_4) ∧ evaluation_count(ILP_N_SEARCH_4) = 0 ∧ is_object_like_macro(ILP_N_SEARCH_4)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SEARCH_4"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SEARCH_4'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by macro definition'''
depends_on = ['ilp_cpu_profile_macro_simple_substitution']
reviewed = true

[[axioms]]
id = "macro_ilp_n_search_4_effect_lvalue"
content = '''Any modification to ILP_N_SEARCH_4 directly modifies ILP_CPU_PROFILE.search_4 (lvalue semantics preserved)'''
formal_spec = '''is_lvalue(ILP_N_SEARCH_4) == is_lvalue(ILP_CPU_PROFILE.search_4) ∧ address_of(ILP_N_SEARCH_4) == address_of(ILP_CPU_PROFILE.search_4)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SEARCH_4"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SEARCH_4'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by textual substitution'''
depends_on = ['cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b', 'cpp20_expr_cast_lvalue_result_d4e8a1c3', 'cpp20_basic_lval_temp_materialization_b4e9f1c5']
reviewed = true

[[axioms]]
id = "macro_ilp_n_search_4_context_sensitivity"
content = '''The meaning of ILP_N_SEARCH_4 depends on the definition of ILP_CPU_PROFILE at the point of use, not at the point of macro definition'''
formal_spec = '''semantic_binding(ILP_N_SEARCH_4) == binding_at_use_site(expansion(ILP_CPU_PROFILE).search_4)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SEARCH_4"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SEARCH_4'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by preprocessor semantics'''
depends_on = ['ilp_cpu_profile_macro_context_sensitivity']
reviewed = true

[[axioms]]
id = "macro_ilp_n_search_4_anti_pattern_global_dependency"
content = '''Using this macro creates an implicit dependency on ILP_CPU_PROFILE being defined in scope; consider using the qualified name directly for clarity'''
formal_spec = '''implicit_dependency(ILP_N_SEARCH_4, ILP_CPU_PROFILE)'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "ILP_N_SEARCH_4"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SEARCH_4'''
axiom_type = "anti_pattern"
on_violation = '''Reduced code maintainability and clarity'''
depends_on = ['ilp_n_shift_4_macro_anti_pattern_global_dependency']
reviewed = true

[[axioms]]
id = "macro_ilp_n_search_4_complexity_zero_overhead"
content = '''Macro expansion has zero runtime overhead; it is purely a compile-time textual substitution'''
formal_spec = '''runtime_cost(ILP_N_SEARCH_4) = O(1) ∧ compile_time_cost(ILP_N_SEARCH_4) = O(1)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SEARCH_4"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SEARCH_4'''
axiom_type = "complexity"
on_violation = '''N/A - guaranteed by preprocessor implementation'''
depends_on = ['ilp_cpu_profile_macro_simple_substitution']
reviewed = true

[[axioms]]
id = "macro_ilp_n_search_8_precondition_ilp_cpu_profile_defined"
content = '''ILP_CPU_PROFILE must be defined in scope before ILP_N_SEARCH_8 is used'''
formal_spec = '''is_defined(ILP_CPU_PROFILE) ∧ has_member(ILP_CPU_PROFILE, search_8)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SEARCH_8"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SEARCH_8'''
axiom_type = "precondition"
on_violation = '''Compilation error: undefined identifier or member access on undefined macro'''
depends_on = ['ilp_cpu_profile_macro_context_sensitivity', 'ilp_cpu_profile_macro_expansion']
reviewed = true

[[axioms]]
id = "macro_ilp_n_search_8_expansion"
content = '''After macro expansion, ILP_N_SEARCH_8 is textually replaced with ILP_CPU_PROFILE.search_8, which further expands to ilp::cpu::default_profile.search_8'''
formal_spec = '''expansion(ILP_N_SEARCH_8) == 'ILP_CPU_PROFILE.search_8' ∧ full_expansion(ILP_N_SEARCH_8) == 'ilp::cpu::default_profile.search_8''''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SEARCH_8"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SEARCH_8'''
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed by preprocessor'''
depends_on = ['ilp_cpu_profile_macro_expansion']
reviewed = true

[[axioms]]
id = "macro_ilp_n_search_8_effect_no_side_effects"
content = '''ILP_N_SEARCH_8 performs simple textual substitution with no arguments, no multiple evaluation, and no side effects'''
formal_spec = '''no_side_effects(ILP_N_SEARCH_8) ∧ evaluation_count(ILP_N_SEARCH_8) = 0 ∧ argument_count(ILP_N_SEARCH_8) = 0'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SEARCH_8"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SEARCH_8'''
axiom_type = "effect"
on_violation = '''N/A - no arguments to evaluate'''
depends_on = ['ilp_cpu_profile_macro_simple_substitution']
reviewed = true

[[axioms]]
id = "macro_ilp_n_search_8_effect_lvalue"
content = '''Any modification to ILP_N_SEARCH_8 directly modifies ILP_CPU_PROFILE.search_8 (lvalue semantics preserved through member access)'''
formal_spec = '''is_lvalue(ILP_N_SEARCH_8) == is_lvalue(ILP_CPU_PROFILE.search_8) ∧ address_of(ILP_N_SEARCH_8) == address_of(ILP_CPU_PROFILE.search_8)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SEARCH_8"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SEARCH_8'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by member access semantics'''
depends_on = ['cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b', 'cpp20_expr_cast_lvalue_result_d4e8a1c3', 'cpp20_basic_lval_temp_materialization_b4e9f1c5']
reviewed = true

[[axioms]]
id = "macro_ilp_n_search_8_anti_pattern_global_dependency"
content = '''Using this macro creates an implicit dependency on ILP_CPU_PROFILE being defined in scope; consider using the qualified name ilp::cpu::default_profile.search_8 directly for clarity'''
formal_spec = '''implicit_dependency(ILP_N_SEARCH_8, ILP_CPU_PROFILE) ∧ reduces_readability(ILP_N_SEARCH_8)'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "ILP_N_SEARCH_8"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SEARCH_8'''
axiom_type = "anti_pattern"
on_violation = '''Reduced code clarity and maintainability'''
depends_on = ['ilp_n_shift_4_macro_anti_pattern_global_dependency', 'ilp_cpu_profile_macro_context_sensitivity']
reviewed = true

[[axioms]]
id = "macro_ilp_n_search_8_complexity_zero_overhead"
content = '''ILP_N_SEARCH_8 has zero runtime overhead as it is a compile-time textual substitution that resolves to a direct member access'''
formal_spec = '''runtime_cost(ILP_N_SEARCH_8) == runtime_cost(ilp::cpu::default_profile.search_8) ∧ expansion_time == O(1)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SEARCH_8"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SEARCH_8'''
axiom_type = "complexity"
on_violation = '''N/A - guaranteed by preprocessor'''
depends_on = ['ilp_cpu_profile_macro_simple_substitution']
reviewed = true

[[axioms]]
id = "macro_ilp_n_copy_1_precondition_ilp_cpu_profile_defined"
content = '''ILP_CPU_PROFILE must be defined and in scope before ILP_N_COPY_1 is used'''
formal_spec = '''defined(ILP_CPU_PROFILE) at point_of_use(ILP_N_COPY_1)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_COPY_1"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_COPY_1'''
axiom_type = "precondition"
on_violation = '''Compilation error due to undefined identifier'''
depends_on = ['ilp_cpu_profile_macro_context_sensitivity']
reviewed = true

[[axioms]]
id = "macro_ilp_n_copy_1_precondition_copy_1_member_exists"
content = '''ILP_CPU_PROFILE must have a member named copy_1 accessible at the point of use'''
formal_spec = '''has_member(ILP_CPU_PROFILE, 'copy_1') && is_accessible(ILP_CPU_PROFILE.copy_1)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_COPY_1"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_COPY_1'''
axiom_type = "precondition"
on_violation = '''Compilation error due to member access violation'''
depends_on = ['ilp_cpu_profile_macro_expansion']
reviewed = true

[[axioms]]
id = "macro_ilp_n_copy_1_effect_simple_substitution"
content = '''ILP_N_COPY_1 performs simple textual substitution with no arguments, no multiple evaluation, and no side effects'''
formal_spec = '''expansion(ILP_N_COPY_1) == 'ILP_CPU_PROFILE.copy_1' && no_side_effects(ILP_N_COPY_1) && evaluation_count(ILP_N_COPY_1) = 0'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_COPY_1"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_COPY_1'''
axiom_type = "effect"
on_violation = '''N/A - this is a guaranteed property'''
depends_on = ['ilp_cpu_profile_macro_simple_substitution']
reviewed = true

[[axioms]]
id = "macro_ilp_n_copy_1_effect_lvalue"
content = '''Any modification to ILP_N_COPY_1 directly modifies ILP_CPU_PROFILE.copy_1 (lvalue semantics preserved)'''
formal_spec = '''is_lvalue(ILP_N_COPY_1) == is_lvalue(ILP_CPU_PROFILE.copy_1) && address_of(ILP_N_COPY_1) == address_of(ILP_CPU_PROFILE.copy_1)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_COPY_1"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_COPY_1'''
axiom_type = "effect"
on_violation = '''N/A - this is a guaranteed property'''
depends_on = ['cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b', 'cpp20_expr_cast_lvalue_result_d4e8a1c3', 'cpp20_basic_lval_temp_materialization_b4e9f1c5']
reviewed = true

[[axioms]]
id = "macro_ilp_n_copy_1_postcondition_alias"
content = '''After macro expansion, ILP_N_COPY_1 is an alias for ILP_CPU_PROFILE.copy_1, referring to the same object'''
formal_spec = '''∀context. expansion(ILP_N_COPY_1, context) == ILP_CPU_PROFILE.copy_1'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_COPY_1"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_COPY_1'''
axiom_type = "postcondition"
on_violation = '''N/A - this is a guaranteed property'''
depends_on = ['ilp_cpu_profile_macro_expansion', 'ilp_cpu_profile_macro_context_sensitivity']
reviewed = true

[[axioms]]
id = "macro_ilp_n_copy_1_anti_pattern_global_dependency"
content = '''Using this macro creates an implicit dependency on ILP_CPU_PROFILE being defined in scope; consider using the qualified name directly for clarity'''
formal_spec = '''implicit_dependency(ILP_N_COPY_1, ILP_CPU_PROFILE)'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "ILP_N_COPY_1"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_COPY_1'''
axiom_type = "anti_pattern"
on_violation = '''Reduced code clarity and maintainability'''
depends_on = ['ilp_n_shift_4_macro_anti_pattern_global_dependency']
reviewed = true

[[axioms]]
id = "macro_ilp_n_copy_1_complexity_zero"
content = '''Macro expansion has zero runtime cost - it is a compile-time textual substitution'''
formal_spec = '''runtime_cost(ILP_N_COPY_1) == 0'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_COPY_1"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_COPY_1'''
axiom_type = "complexity"
on_violation = '''N/A - this is a guaranteed property'''
depends_on = ['ilp_cpu_profile_macro_simple_substitution']
reviewed = true

[[axioms]]
id = "macro_ilp_n_copy_2_precondition_profile_defined"
content = '''ILP_CPU_PROFILE must be defined and in scope before using ILP_N_COPY_2'''
formal_spec = '''defined(ILP_CPU_PROFILE) ∧ in_scope(ILP_CPU_PROFILE)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_COPY_2"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_COPY_2'''
axiom_type = "precondition"
on_violation = '''compilation error: ILP_CPU_PROFILE not defined'''
depends_on = ['ilp_cpu_profile_macro_expansion', 'ilp_n_shift_4_macro_anti_pattern_global_dependency']
reviewed = true

[[axioms]]
id = "macro_ilp_n_copy_2_precondition_member_exists"
content = '''ILP_CPU_PROFILE must have a member named copy_2 accessible at the point of use'''
formal_spec = '''has_member(expansion(ILP_CPU_PROFILE), 'copy_2') ∧ is_accessible(expansion(ILP_CPU_PROFILE).copy_2)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_COPY_2"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_COPY_2'''
axiom_type = "precondition"
on_violation = '''compilation error: no member named 'copy_2' in ILP_CPU_PROFILE'''
depends_on = ['ilp_cpu_profile_macro_expansion']
reviewed = true

[[axioms]]
id = "macro_ilp_n_copy_2_expansion"
content = '''After macro expansion, ILP_N_COPY_2 is textually replaced with ILP_CPU_PROFILE.copy_2'''
formal_spec = '''expansion(ILP_N_COPY_2) == 'ILP_CPU_PROFILE.copy_2''''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_COPY_2"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_COPY_2'''
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed by preprocessor'''
depends_on = ['ilp_cpu_profile_macro_simple_substitution']
reviewed = true

[[axioms]]
id = "macro_ilp_n_copy_2_effect_simple_substitution"
content = '''ILP_N_COPY_2 performs simple textual substitution with no arguments, no multiple evaluation, and no side effects'''
formal_spec = '''no_side_effects(ILP_N_COPY_2) ∧ evaluation_count(ILP_N_COPY_2) = 0'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_COPY_2"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_COPY_2'''
axiom_type = "effect"
on_violation = '''N/A - no side effects possible'''
depends_on = ['ilp_cpu_profile_macro_simple_substitution']
reviewed = true

[[axioms]]
id = "macro_ilp_n_copy_2_effect_lvalue"
content = '''Any modification to ILP_N_COPY_2 directly modifies ILP_CPU_PROFILE.copy_2 (lvalue semantics preserved)'''
formal_spec = '''is_lvalue(ILP_N_COPY_2) == is_lvalue(ILP_CPU_PROFILE.copy_2) ∧ address_of(ILP_N_COPY_2) == address_of(ILP_CPU_PROFILE.copy_2)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_COPY_2"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_COPY_2'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by simple substitution'''
depends_on = ['cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b', 'cpp20_expr_cast_lvalue_result_d4e8a1c3', 'cpp20_basic_lval_temp_materialization_b4e9f1c5']
reviewed = true

[[axioms]]
id = "macro_ilp_n_copy_2_context_sensitivity"
content = '''The meaning of ILP_N_COPY_2 depends on the definition of ilp::cpu::default_profile at the point of use, not at the point of macro definition'''
formal_spec = '''semantic_binding(ILP_N_COPY_2) == binding_at_use_site(ilp::cpu::default_profile.copy_2)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_COPY_2"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_COPY_2'''
axiom_type = "effect"
on_violation = '''N/A - context-dependent behavior is intentional'''
depends_on = ['ilp_cpu_profile_macro_context_sensitivity']
reviewed = true

[[axioms]]
id = "macro_ilp_n_copy_2_anti_pattern_global_dependency"
content = '''Using this macro creates an implicit dependency on ILP_CPU_PROFILE being defined in scope; consider using the qualified name directly for clarity'''
formal_spec = '''implicit_dependency(ILP_N_COPY_2, ILP_CPU_PROFILE)'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "ILP_N_COPY_2"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_COPY_2'''
axiom_type = "anti_pattern"
on_violation = '''reduced code clarity and maintainability'''
depends_on = ['ilp_n_shift_4_macro_anti_pattern_global_dependency']
reviewed = true

[[axioms]]
id = "macro_ilp_n_copy_2_complexity_zero"
content = '''Macro expansion has zero runtime cost; complexity depends on what operations are performed on the expanded member'''
formal_spec = '''time_complexity(expansion(ILP_N_COPY_2)) = O(1) ∧ space_complexity(expansion(ILP_N_COPY_2)) = O(1)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_COPY_2"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_COPY_2'''
axiom_type = "complexity"
on_violation = '''N/A - guaranteed by preprocessor'''
depends_on = ['ilp_cpu_profile_macro_simple_substitution']
reviewed = true

[[axioms]]
id = "ilp_n_copy_4_macro_expansion"
content = '''After macro expansion, ILP_N_COPY_4 is textually replaced with ILP_CPU_PROFILE.copy_4'''
formal_spec = '''expansion(ILP_N_COPY_4) == 'ILP_CPU_PROFILE.copy_4''''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_COPY_4"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_COPY_4'''
axiom_type = "postcondition"
on_violation = '''Compilation error if ILP_CPU_PROFILE is not defined'''
depends_on = ['ilp_cpu_profile_macro_expansion']
reviewed = true

[[axioms]]
id = "ilp_n_copy_4_macro_context_sensitivity"
content = '''The meaning of ILP_N_COPY_4 depends on the definition of ilp::cpu::default_profile at the point of use, inherited through ILP_CPU_PROFILE, not at the point of macro definition'''
formal_spec = '''semantic_binding(ILP_N_COPY_4) == binding_at_use_site(ilp::cpu::default_profile.copy_4)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_COPY_4"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_COPY_4'''
axiom_type = "effect"
on_violation = '''Different value accessed if default_profile changes between macro definition and use'''
depends_on = ['ilp_cpu_profile_macro_context_sensitivity']
reviewed = true

[[axioms]]
id = "ilp_n_copy_4_macro_simple_substitution"
content = '''ILP_N_COPY_4 performs simple textual substitution with no arguments, no multiple evaluation, and no side effects'''
formal_spec = '''no_side_effects(ILP_N_COPY_4) ∧ evaluation_count(ILP_N_COPY_4) = 0'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_COPY_4"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_COPY_4'''
axiom_type = "effect"
on_violation = '''N/A - no evaluation occurs'''
depends_on = ['ilp_cpu_profile_macro_simple_substitution']
reviewed = true

[[axioms]]
id = "ilp_n_copy_4_macro_precondition_ilp_cpu_profile_defined"
content = '''ILP_CPU_PROFILE must be defined in scope before using ILP_N_COPY_4'''
formal_spec = '''requires(defined(ILP_CPU_PROFILE))'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_COPY_4"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_COPY_4'''
axiom_type = "precondition"
on_violation = '''Compilation error: ILP_CPU_PROFILE not defined'''
depends_on = ['ilp_cpu_profile_macro_expansion']
reviewed = true

[[axioms]]
id = "ilp_n_copy_4_macro_effect_lvalue"
content = '''Any modification to ILP_N_COPY_4 directly modifies ILP_CPU_PROFILE.copy_4 (lvalue semantics preserved)'''
formal_spec = '''is_lvalue(ILP_N_COPY_4) == is_lvalue(ILP_CPU_PROFILE.copy_4) && address_of(ILP_N_COPY_4) == address_of(ILP_CPU_PROFILE.copy_4)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_COPY_4"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_COPY_4'''
axiom_type = "effect"
on_violation = '''N/A - direct textual substitution guarantees this'''
depends_on = ['cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b', 'cpp20_expr_cast_lvalue_result_d4e8a1c3', 'cpp20_basic_lval_temp_materialization_b4e9f1c5']
reviewed = true

[[axioms]]
id = "ilp_n_copy_4_macro_anti_pattern_global_dependency"
content = '''Using this macro creates an implicit dependency on ILP_CPU_PROFILE being defined in scope; consider using the qualified name directly for clarity'''
formal_spec = '''implicit_dependency(ILP_N_COPY_4, ILP_CPU_PROFILE)'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "ILP_N_COPY_4"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_COPY_4'''
axiom_type = "anti_pattern"
on_violation = '''Reduced code clarity and maintainability'''
depends_on = ['ilp_n_shift_4_macro_anti_pattern_global_dependency']
reviewed = true

[[axioms]]
id = "ilp_n_copy_4_macro_precondition_copy_4_member_exists"
content = '''The expansion ILP_CPU_PROFILE must have a member named copy_4'''
formal_spec = '''requires(has_member(ILP_CPU_PROFILE, copy_4))'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_COPY_4"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_COPY_4'''
axiom_type = "precondition"
on_violation = '''Compilation error: no member named 'copy_4' in expansion of ILP_CPU_PROFILE'''
depends_on = ['ilp_cpu_profile_macro_expansion']
reviewed = true

[[axioms]]
id = "macro_ilp_n_copy_8_precondition_ilp_cpu_profile_defined"
content = '''ILP_CPU_PROFILE must be defined and in scope before using ILP_N_COPY_8'''
formal_spec = '''defined(ILP_CPU_PROFILE) ∧ in_scope(ILP_CPU_PROFILE)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_COPY_8"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_COPY_8'''
axiom_type = "precondition"
on_violation = '''Compilation error: ILP_CPU_PROFILE not defined'''
depends_on = ['ilp_cpu_profile_macro_context_sensitivity', 'ilp_n_shift_4_macro_anti_pattern_global_dependency']
reviewed = true

[[axioms]]
id = "macro_ilp_n_copy_8_precondition_copy_8_member"
content = '''The expanded ILP_CPU_PROFILE must have a member named copy_8'''
formal_spec = '''has_member(expansion(ILP_CPU_PROFILE), 'copy_8')'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_COPY_8"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_COPY_8'''
axiom_type = "precondition"
on_violation = '''Compilation error: no member named 'copy_8''''
depends_on = ['ilp_cpu_profile_macro_expansion', 'ilp_cpu_profile_macro_context_sensitivity']
reviewed = true

[[axioms]]
id = "macro_ilp_n_copy_8_expansion"
content = '''After macro expansion, ILP_N_COPY_8 is textually replaced with ILP_CPU_PROFILE.copy_8'''
formal_spec = '''expansion(ILP_N_COPY_8) == 'ILP_CPU_PROFILE.copy_8''''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_COPY_8"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_COPY_8'''
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed by preprocessor'''
depends_on = ['ilp_cpu_profile_macro_simple_substitution']
reviewed = true

[[axioms]]
id = "macro_ilp_n_copy_8_effect_simple_substitution"
content = '''ILP_N_COPY_8 performs simple textual substitution with no arguments, no multiple evaluation, and no side effects'''
formal_spec = '''no_side_effects(ILP_N_COPY_8) ∧ evaluation_count(ILP_N_COPY_8) = 0'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_COPY_8"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_COPY_8'''
axiom_type = "effect"
on_violation = '''N/A - no side effects possible'''
depends_on = ['ilp_cpu_profile_macro_simple_substitution']
reviewed = true

[[axioms]]
id = "macro_ilp_n_copy_8_effect_lvalue"
content = '''Any modification to ILP_N_COPY_8 directly modifies ILP_CPU_PROFILE.copy_8 (lvalue semantics preserved)'''
formal_spec = '''is_lvalue(ILP_N_COPY_8) == is_lvalue(ILP_CPU_PROFILE.copy_8) ∧ address_of(ILP_N_COPY_8) == address_of(ILP_CPU_PROFILE.copy_8)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_COPY_8"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_COPY_8'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by textual substitution'''
depends_on = ['cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b', 'cpp20_expr_cast_lvalue_result_d4e8a1c3', 'cpp20_basic_lval_temp_materialization_b4e9f1c5']
reviewed = true

[[axioms]]
id = "macro_ilp_n_copy_8_context_sensitivity"
content = '''The meaning of ILP_N_COPY_8 depends on the definition of ILP_CPU_PROFILE at the point of use, not at the point of macro definition'''
formal_spec = '''semantic_binding(ILP_N_COPY_8) == binding_at_use_site(ILP_CPU_PROFILE.copy_8)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_COPY_8"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_COPY_8'''
axiom_type = "effect"
on_violation = '''N/A - inherent macro behavior'''
depends_on = ['ilp_cpu_profile_macro_context_sensitivity']
reviewed = true

[[axioms]]
id = "macro_ilp_n_copy_8_anti_pattern_global_dependency"
content = '''Using this macro creates an implicit dependency on ILP_CPU_PROFILE being defined in scope; consider using the qualified name directly for clarity'''
formal_spec = '''implicit_dependency(ILP_N_COPY_8, ILP_CPU_PROFILE)'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "ILP_N_COPY_8"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_COPY_8'''
axiom_type = "anti_pattern"
on_violation = '''Reduced code clarity and maintainability'''
depends_on = ['ilp_n_shift_4_macro_anti_pattern_global_dependency']
reviewed = true

[[axioms]]
id = "macro_ilp_n_copy_8_complexity_zero"
content = '''Macro expansion has zero runtime overhead - it is a compile-time textual substitution'''
formal_spec = '''runtime_cost(ILP_N_COPY_8) = O(0)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_COPY_8"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_COPY_8'''
axiom_type = "complexity"
on_violation = '''N/A - guaranteed by preprocessor'''
depends_on = ['ilp_cpu_profile_macro_simple_substitution']
reviewed = true

[[axioms]]
id = "ilp_n_transform_1_macro_expansion"
content = '''After macro expansion, ILP_N_TRANSFORM_1 is textually replaced with ILP_CPU_PROFILE.transform_1'''
formal_spec = '''expansion(ILP_N_TRANSFORM_1) == 'ILP_CPU_PROFILE.transform_1''''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_TRANSFORM_1"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_TRANSFORM_1'''
axiom_type = "postcondition"
on_violation = '''compilation error'''
depends_on = ['ilp_cpu_profile_macro_expansion']
reviewed = true

[[axioms]]
id = "ilp_n_transform_1_macro_simple_substitution"
content = '''ILP_N_TRANSFORM_1 performs simple textual substitution with no arguments, no multiple evaluation, and no side effects'''
formal_spec = '''no_side_effects(ILP_N_TRANSFORM_1) ∧ evaluation_count(ILP_N_TRANSFORM_1) = 0'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_TRANSFORM_1"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_TRANSFORM_1'''
axiom_type = "effect"
on_violation = '''N/A - this is a guaranteed property'''
depends_on = ['ilp_cpu_profile_macro_simple_substitution']
reviewed = true

[[axioms]]
id = "ilp_n_transform_1_macro_precondition_dependency"
content = '''ILP_CPU_PROFILE must be defined and in scope before ILP_N_TRANSFORM_1 is used'''
formal_spec = '''defined(ILP_CPU_PROFILE) ∧ in_scope(ILP_CPU_PROFILE)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_TRANSFORM_1"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_TRANSFORM_1'''
axiom_type = "precondition"
on_violation = '''compilation error - undefined identifier'''
depends_on = ['ilp_cpu_profile_macro_expansion']
reviewed = true

[[axioms]]
id = "ilp_n_transform_1_macro_context_sensitivity"
content = '''The meaning of ILP_N_TRANSFORM_1 depends on the definition of ilp::cpu::default_profile at the point of use, not at the point of macro definition'''
formal_spec = '''semantic_binding(ILP_N_TRANSFORM_1) == binding_at_use_site(ilp::cpu::default_profile.transform_1)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_TRANSFORM_1"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_TRANSFORM_1'''
axiom_type = "effect"
on_violation = '''N/A - this is a guaranteed property of macro semantics'''
depends_on = ['ilp_cpu_profile_macro_context_sensitivity']
reviewed = true

[[axioms]]
id = "ilp_n_transform_1_macro_lvalue_semantics"
content = '''Any modification to ILP_N_TRANSFORM_1 directly modifies ILP_CPU_PROFILE.transform_1 (lvalue semantics preserved)'''
formal_spec = '''is_lvalue(ILP_N_TRANSFORM_1) == is_lvalue(ILP_CPU_PROFILE.transform_1) && address_of(ILP_N_TRANSFORM_1) == address_of(ILP_CPU_PROFILE.transform_1)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_TRANSFORM_1"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_TRANSFORM_1'''
axiom_type = "effect"
on_violation = '''N/A - this is a guaranteed property of macro expansion'''
depends_on = ['cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b', 'cpp20_expr_cast_lvalue_result_d4e8a1c3', 'cpp20_basic_lval_temp_materialization_b4e9f1c5']
reviewed = true

[[axioms]]
id = "ilp_n_transform_1_macro_anti_pattern_global_dependency"
content = '''Using this macro creates an implicit dependency on ILP_CPU_PROFILE being defined in scope; consider using ILP_CPU_PROFILE.transform_1 directly for clarity'''
formal_spec = '''implicit_dependency(ILP_N_TRANSFORM_1, ILP_CPU_PROFILE)'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "ILP_N_TRANSFORM_1"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_TRANSFORM_1'''
axiom_type = "anti_pattern"
on_violation = '''reduced code readability and maintainability'''
depends_on = ['ilp_n_shift_4_macro_anti_pattern_global_dependency']
reviewed = true

[[axioms]]
id = "ilp_n_transform_1_macro_constraint_member_existence"
content = '''The type of ILP_CPU_PROFILE must have a member named transform_1'''
formal_spec = '''has_member(typeof(ILP_CPU_PROFILE), 'transform_1')'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_TRANSFORM_1"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_TRANSFORM_1'''
axiom_type = "precondition"
on_violation = '''compilation error - no member named 'transform_1''''
depends_on = ['ilp_cpu_profile_macro_expansion']
reviewed = true

[[axioms]]
id = "macro_ilp_n_transform_2_precondition_cpu_profile_defined"
content = '''ILP_CPU_PROFILE must be defined in scope before using ILP_N_TRANSFORM_2'''
formal_spec = '''is_defined(ILP_CPU_PROFILE) == true'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_TRANSFORM_2"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_TRANSFORM_2'''
axiom_type = "precondition"
on_violation = '''Compilation error due to undefined macro'''
depends_on = ['ilp_cpu_profile_macro_expansion']
reviewed = true

[[axioms]]
id = "macro_ilp_n_transform_2_precondition_transform_2_member_exists"
content = '''ILP_CPU_PROFILE must have a member named transform_2 accessible at the point of use'''
formal_spec = '''has_member(ILP_CPU_PROFILE, 'transform_2') == true'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_TRANSFORM_2"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_TRANSFORM_2'''
axiom_type = "precondition"
on_violation = '''Compilation error due to missing member transform_2'''
depends_on = ['ilp_cpu_profile_macro_context_sensitivity']
reviewed = true

[[axioms]]
id = "macro_ilp_n_transform_2_expansion"
content = '''After macro expansion, ILP_N_TRANSFORM_2 is textually replaced with ILP_CPU_PROFILE.transform_2'''
formal_spec = '''expansion(ILP_N_TRANSFORM_2) == 'ILP_CPU_PROFILE.transform_2''''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_TRANSFORM_2"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_TRANSFORM_2'''
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed by preprocessor'''
depends_on = ['ilp_cpu_profile_macro_simple_substitution']
reviewed = true

[[axioms]]
id = "macro_ilp_n_transform_2_effect_simple_substitution"
content = '''ILP_N_TRANSFORM_2 performs simple textual substitution with no arguments, no multiple evaluation, and no side effects'''
formal_spec = '''no_side_effects(ILP_N_TRANSFORM_2) ∧ evaluation_count(ILP_N_TRANSFORM_2) = 0'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_TRANSFORM_2"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_TRANSFORM_2'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by macro definition'''
depends_on = ['ilp_cpu_profile_macro_simple_substitution']
reviewed = true

[[axioms]]
id = "macro_ilp_n_transform_2_effect_lvalue"
content = '''Any modification to ILP_N_TRANSFORM_2 directly modifies ILP_CPU_PROFILE.transform_2 (lvalue semantics preserved)'''
formal_spec = '''is_lvalue(ILP_N_TRANSFORM_2) == is_lvalue(ILP_CPU_PROFILE.transform_2) && address_of(ILP_N_TRANSFORM_2) == address_of(ILP_CPU_PROFILE.transform_2)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_TRANSFORM_2"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_TRANSFORM_2'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by textual substitution'''
depends_on = ['cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b', 'cpp20_expr_cast_lvalue_result_d4e8a1c3', 'cpp20_basic_lval_temp_materialization_b4e9f1c5']
reviewed = true

[[axioms]]
id = "macro_ilp_n_transform_2_context_sensitivity"
content = '''The meaning of ILP_N_TRANSFORM_2 depends on the definition of ILP_CPU_PROFILE at the point of use, not at the point of macro definition'''
formal_spec = '''semantic_binding(ILP_N_TRANSFORM_2) == binding_at_use_site(ILP_CPU_PROFILE.transform_2)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_TRANSFORM_2"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_TRANSFORM_2'''
axiom_type = "effect"
on_violation = '''N/A - inherent property of macro semantics'''
depends_on = ['ilp_cpu_profile_macro_context_sensitivity']
reviewed = true

[[axioms]]
id = "macro_ilp_n_transform_2_anti_pattern_global_dependency"
content = '''Using this macro creates an implicit dependency on ILP_CPU_PROFILE being defined in scope; consider using the qualified name directly for clarity'''
formal_spec = '''implicit_dependency(ILP_N_TRANSFORM_2, ILP_CPU_PROFILE)'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "ILP_N_TRANSFORM_2"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_TRANSFORM_2'''
axiom_type = "anti_pattern"
on_violation = '''Reduced code clarity and increased coupling'''
depends_on = ['ilp_n_shift_4_macro_anti_pattern_global_dependency']
reviewed = true

[[axioms]]
id = "macro_ilp_n_transform_2_complexity_zero_overhead"
content = '''Macro expansion has zero runtime overhead - it is purely a compile-time textual substitution'''
formal_spec = '''runtime_cost(ILP_N_TRANSFORM_2) == O(0)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_TRANSFORM_2"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_TRANSFORM_2'''
axiom_type = "complexity"
on_violation = '''N/A - guaranteed by preprocessor semantics'''
depends_on = ['ilp_cpu_profile_macro_simple_substitution']
reviewed = true

[[axioms]]
id = "macro_ilp_n_transform_4_precondition_ilp_cpu_profile_defined"
content = '''ILP_CPU_PROFILE must be defined and in scope before using ILP_N_TRANSFORM_4'''
formal_spec = '''defined(ILP_CPU_PROFILE) at point_of_use(ILP_N_TRANSFORM_4)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_TRANSFORM_4"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_TRANSFORM_4'''
axiom_type = "precondition"
on_violation = '''Compilation error: ILP_CPU_PROFILE not defined'''
depends_on = ['ilp_cpu_profile_macro_context_sensitivity', 'ilp_n_shift_4_macro_anti_pattern_global_dependency']
reviewed = true

[[axioms]]
id = "macro_ilp_n_transform_4_precondition_transform_4_member"
content = '''ILP_CPU_PROFILE must have a member named transform_4'''
formal_spec = '''has_member(ILP_CPU_PROFILE, 'transform_4')'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_TRANSFORM_4"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_TRANSFORM_4'''
axiom_type = "precondition"
on_violation = '''Compilation error: no member named 'transform_4''''
depends_on = ['ilp_cpu_profile_macro_expansion']
reviewed = true

[[axioms]]
id = "macro_ilp_n_transform_4_postcondition_expansion"
content = '''After macro expansion, ILP_N_TRANSFORM_4 is textually replaced with ILP_CPU_PROFILE.transform_4'''
formal_spec = '''expansion(ILP_N_TRANSFORM_4) == 'ILP_CPU_PROFILE.transform_4''''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_TRANSFORM_4"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_TRANSFORM_4'''
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed by preprocessor'''
depends_on = ['ilp_cpu_profile_macro_simple_substitution', 'ilp_cpu_profile_macro_expansion']
reviewed = true

[[axioms]]
id = "macro_ilp_n_transform_4_effect_no_side_effects"
content = '''ILP_N_TRANSFORM_4 performs simple textual substitution with no side effects and no argument evaluation (object-like macro)'''
formal_spec = '''no_side_effects(ILP_N_TRANSFORM_4) ∧ evaluation_count(ILP_N_TRANSFORM_4) = 0'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_TRANSFORM_4"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_TRANSFORM_4'''
axiom_type = "effect"
on_violation = '''N/A - object-like macros have no evaluation'''
depends_on = ['ilp_cpu_profile_macro_simple_substitution']
reviewed = true

[[axioms]]
id = "macro_ilp_n_transform_4_effect_lvalue"
content = '''Any modification to ILP_N_TRANSFORM_4 directly modifies ILP_CPU_PROFILE.transform_4 (lvalue semantics preserved)'''
formal_spec = '''is_lvalue(ILP_N_TRANSFORM_4) == is_lvalue(ILP_CPU_PROFILE.transform_4) && address_of(ILP_N_TRANSFORM_4) == address_of(ILP_CPU_PROFILE.transform_4)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_TRANSFORM_4"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_TRANSFORM_4'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by textual substitution'''
depends_on = ['cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b', 'cpp20_expr_cast_lvalue_result_d4e8a1c3', 'cpp20_basic_lval_temp_materialization_b4e9f1c5']
reviewed = true

[[axioms]]
id = "macro_ilp_n_transform_4_anti_pattern_global_dependency"
content = '''Using this macro creates an implicit dependency on ILP_CPU_PROFILE being defined in scope; consider using the qualified name directly for clarity'''
formal_spec = '''implicit_dependency(ILP_N_TRANSFORM_4, ILP_CPU_PROFILE)'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "ILP_N_TRANSFORM_4"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_TRANSFORM_4'''
axiom_type = "anti_pattern"
on_violation = '''Reduced code clarity and maintainability'''
depends_on = ['ilp_n_shift_4_macro_anti_pattern_global_dependency', 'ilp_cpu_profile_macro_context_sensitivity']
reviewed = true

[[axioms]]
id = "macro_ilp_n_transform_4_complexity_zero_overhead"
content = '''Zero runtime overhead - this is a compile-time textual substitution with no function call or evaluation cost'''
formal_spec = '''runtime_cost(ILP_N_TRANSFORM_4) = O(1) ∧ overhead(ILP_N_TRANSFORM_4) = 0'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_TRANSFORM_4"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_TRANSFORM_4'''
axiom_type = "complexity"
on_violation = '''N/A - guaranteed by preprocessor'''
depends_on = ['ilp_cpu_profile_macro_simple_substitution']
reviewed = true

[[axioms]]
id = "macro_ilp_n_transform_8_precondition_ilp_cpu_profile_defined"
content = '''ILP_CPU_PROFILE must be defined in scope before using ILP_N_TRANSFORM_8'''
formal_spec = '''is_defined(ILP_CPU_PROFILE) == true'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_TRANSFORM_8"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_TRANSFORM_8'''
axiom_type = "precondition"
on_violation = '''Compilation error: use of undeclared identifier'''
depends_on = ['ilp_cpu_profile_macro_expansion']
reviewed = true

[[axioms]]
id = "macro_ilp_n_transform_8_precondition_transform_8_member_exists"
content = '''ILP_CPU_PROFILE.transform_8 must be a valid member expression (ILP_CPU_PROFILE must have a member named transform_8)'''
formal_spec = '''has_member(ILP_CPU_PROFILE, 'transform_8') == true'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_TRANSFORM_8"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_TRANSFORM_8'''
axiom_type = "precondition"
on_violation = '''Compilation error: no member named 'transform_8''''
depends_on = ['ilp_cpu_profile_macro_expansion', 'ilp_cpu_profile_macro_context_sensitivity']
reviewed = true

[[axioms]]
id = "macro_ilp_n_transform_8_postcondition_expansion"
content = '''After macro expansion, ILP_N_TRANSFORM_8 is textually replaced with ILP_CPU_PROFILE.transform_8'''
formal_spec = '''expansion(ILP_N_TRANSFORM_8) == 'ILP_CPU_PROFILE.transform_8''''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_TRANSFORM_8"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_TRANSFORM_8'''
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed by preprocessor'''
depends_on = ['ilp_cpu_profile_macro_simple_substitution']
reviewed = true

[[axioms]]
id = "macro_ilp_n_transform_8_effect_no_side_effects"
content = '''ILP_N_TRANSFORM_8 performs simple textual substitution with no arguments, no multiple evaluation, and no side effects'''
formal_spec = '''no_side_effects(ILP_N_TRANSFORM_8) ∧ evaluation_count(ILP_N_TRANSFORM_8) = 0'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_TRANSFORM_8"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_TRANSFORM_8'''
axiom_type = "effect"
on_violation = '''N/A - no side effects possible'''
depends_on = ['ilp_cpu_profile_macro_simple_substitution']
reviewed = true

[[axioms]]
id = "macro_ilp_n_transform_8_effect_lvalue"
content = '''Any modification to ILP_N_TRANSFORM_8 directly modifies ILP_CPU_PROFILE.transform_8 (lvalue semantics preserved)'''
formal_spec = '''is_lvalue(ILP_N_TRANSFORM_8) == is_lvalue(ILP_CPU_PROFILE.transform_8) && address_of(ILP_N_TRANSFORM_8) == address_of(ILP_CPU_PROFILE.transform_8)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_TRANSFORM_8"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_TRANSFORM_8'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by textual substitution'''
depends_on = ['cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b', 'cpp20_expr_cast_lvalue_result_d4e8a1c3', 'cpp20_basic_lval_temp_materialization_b4e9f1c5']
reviewed = true

[[axioms]]
id = "macro_ilp_n_transform_8_effect_context_sensitivity"
content = '''The meaning of ILP_N_TRANSFORM_8 depends on the definition of ILP_CPU_PROFILE at the point of use, not at the point of macro definition'''
formal_spec = '''semantic_binding(ILP_N_TRANSFORM_8) == binding_at_use_site(ILP_CPU_PROFILE.transform_8)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_TRANSFORM_8"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_TRANSFORM_8'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by preprocessor semantics'''
depends_on = ['ilp_cpu_profile_macro_context_sensitivity']
reviewed = true

[[axioms]]
id = "macro_ilp_n_transform_8_anti_pattern_global_dependency"
content = '''Using this macro creates an implicit dependency on ILP_CPU_PROFILE being defined in scope; consider using the qualified name directly for clarity'''
formal_spec = '''implicit_dependency(ILP_N_TRANSFORM_8, ILP_CPU_PROFILE)'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "ILP_N_TRANSFORM_8"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_TRANSFORM_8'''
axiom_type = "anti_pattern"
on_violation = '''Reduced code clarity and maintainability'''
depends_on = ['ilp_n_shift_4_macro_anti_pattern_global_dependency', 'ilp_cpu_profile_macro_expansion']
reviewed = true

[[axioms]]
id = "macro_ilp_n_transform_8_complexity_zero_overhead"
content = '''Macro expansion has zero runtime overhead - identical performance to using ILP_CPU_PROFILE.transform_8 directly'''
formal_spec = '''runtime_cost(ILP_N_TRANSFORM_8) == runtime_cost(ILP_CPU_PROFILE.transform_8)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_TRANSFORM_8"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_TRANSFORM_8'''
axiom_type = "complexity"
on_violation = '''N/A - guaranteed by preprocessor'''
depends_on = ['ilp_cpu_profile_macro_simple_substitution']
reviewed = true

[[axioms]]
id = "macro_ilp_n_multiply_4f_precondition_profile_defined"
content = '''ILP_CPU_PROFILE must be defined and in scope before using ILP_N_MULTIPLY_4F'''
formal_spec = '''defined(ILP_CPU_PROFILE) ∧ in_scope(ILP_CPU_PROFILE)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_MULTIPLY_4F"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_MULTIPLY_4F'''
axiom_type = "precondition"
on_violation = '''Compilation error: ILP_CPU_PROFILE is not declared in this scope'''
depends_on = ['ilp_cpu_profile_macro_expansion', 'ilp_n_shift_4_macro_anti_pattern_global_dependency']
reviewed = true

[[axioms]]
id = "macro_ilp_n_multiply_4f_precondition_member_exists"
content = '''ILP_CPU_PROFILE must have a member named multiply_4f'''
formal_spec = '''has_member(ILP_CPU_PROFILE, multiply_4f)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_MULTIPLY_4F"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_MULTIPLY_4F'''
axiom_type = "precondition"
on_violation = '''Compilation error: ILP_CPU_PROFILE has no member named multiply_4f'''
depends_on = ['ilp_cpu_profile_macro_expansion']
reviewed = true

[[axioms]]
id = "macro_ilp_n_multiply_4f_postcondition_expansion"
content = '''After macro expansion, ILP_N_MULTIPLY_4F is textually replaced with ILP_CPU_PROFILE.multiply_4f'''
formal_spec = '''expansion(ILP_N_MULTIPLY_4F) == 'ILP_CPU_PROFILE.multiply_4f''''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_MULTIPLY_4F"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_MULTIPLY_4F'''
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed by preprocessor'''
depends_on = ['ilp_cpu_profile_macro_simple_substitution']
reviewed = true

[[axioms]]
id = "macro_ilp_n_multiply_4f_effect_no_side_effects"
content = '''ILP_N_MULTIPLY_4F performs simple textual substitution with no arguments, no multiple evaluation, and no side effects'''
formal_spec = '''no_side_effects(ILP_N_MULTIPLY_4F) ∧ evaluation_count(ILP_N_MULTIPLY_4F) = 0'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_MULTIPLY_4F"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_MULTIPLY_4F'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by macro structure'''
depends_on = ['ilp_cpu_profile_macro_simple_substitution']
reviewed = true

[[axioms]]
id = "macro_ilp_n_multiply_4f_effect_lvalue"
content = '''Any modification to ILP_N_MULTIPLY_4F directly modifies ILP_CPU_PROFILE.multiply_4f (lvalue semantics preserved)'''
formal_spec = '''is_lvalue(ILP_N_MULTIPLY_4F) == is_lvalue(ILP_CPU_PROFILE.multiply_4f) && address_of(ILP_N_MULTIPLY_4F) == address_of(ILP_CPU_PROFILE.multiply_4f)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_MULTIPLY_4F"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_MULTIPLY_4F'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by macro expansion semantics'''
depends_on = ['cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b', 'cpp20_expr_cast_lvalue_result_d4e8a1c3', 'cpp20_basic_lval_temp_materialization_b4e9f1c5']
reviewed = true

[[axioms]]
id = "macro_ilp_n_multiply_4f_effect_context_sensitivity"
content = '''The meaning of ILP_N_MULTIPLY_4F depends on the definition of ILP_CPU_PROFILE at the point of use, not at the point of macro definition'''
formal_spec = '''semantic_binding(ILP_N_MULTIPLY_4F) == binding_at_use_site(ILP_CPU_PROFILE.multiply_4f)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_MULTIPLY_4F"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_MULTIPLY_4F'''
axiom_type = "effect"
on_violation = '''Unexpected behavior if ILP_CPU_PROFILE is redefined between macro definition and use'''
depends_on = ['ilp_cpu_profile_macro_context_sensitivity']
reviewed = true

[[axioms]]
id = "macro_ilp_n_multiply_4f_anti_pattern_global_dependency"
content = '''Using this macro creates an implicit dependency on ILP_CPU_PROFILE being defined in scope; consider using the qualified name directly for clarity'''
formal_spec = '''implicit_dependency(ILP_N_MULTIPLY_4F, ILP_CPU_PROFILE)'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "ILP_N_MULTIPLY_4F"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_MULTIPLY_4F'''
axiom_type = "anti_pattern"
on_violation = '''Reduced code clarity and maintainability'''
depends_on = ['ilp_n_shift_4_macro_anti_pattern_global_dependency']
reviewed = true

[[axioms]]
id = "macro_ilp_n_multiply_4f_complexity_zero_overhead"
content = '''Macro expansion has zero runtime overhead - it is a compile-time textual substitution'''
formal_spec = '''runtime_cost(ILP_N_MULTIPLY_4F) = O(1) ∧ expansion_time(ILP_N_MULTIPLY_4F) = O(1)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_MULTIPLY_4F"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_MULTIPLY_4F'''
axiom_type = "complexity"
on_violation = '''N/A - guaranteed by preprocessor'''
depends_on = ['ilp_cpu_profile_macro_simple_substitution']
reviewed = true

[[axioms]]
id = "macro_ilp_n_multiply_8f_precondition_ilp_cpu_profile_defined"
content = '''ILP_CPU_PROFILE must be defined and in scope before using ILP_N_MULTIPLY_8F'''
formal_spec = '''is_defined(ILP_CPU_PROFILE) ∧ in_scope(ILP_CPU_PROFILE)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_MULTIPLY_8F"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_MULTIPLY_8F'''
axiom_type = "precondition"
on_violation = '''Compilation error: use of undeclared identifier'''
depends_on = ['ilp_cpu_profile_macro_expansion', 'ilp_cpu_profile_macro_context_sensitivity']
reviewed = true

[[axioms]]
id = "macro_ilp_n_multiply_8f_precondition_multiply_8f_member"
content = '''ILP_CPU_PROFILE must have a member named multiply_8f accessible at the point of use'''
formal_spec = '''has_member(ILP_CPU_PROFILE, 'multiply_8f') ∧ is_accessible(ILP_CPU_PROFILE.multiply_8f)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_MULTIPLY_8F"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_MULTIPLY_8F'''
axiom_type = "precondition"
on_violation = '''Compilation error: no member named 'multiply_8f''''
depends_on = ['ilp_cpu_profile_macro_expansion']
reviewed = true

[[axioms]]
id = "macro_ilp_n_multiply_8f_expansion"
content = '''After macro expansion, ILP_N_MULTIPLY_8F is textually replaced with ILP_CPU_PROFILE.multiply_8f'''
formal_spec = '''expansion(ILP_N_MULTIPLY_8F) == 'ILP_CPU_PROFILE.multiply_8f''''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_MULTIPLY_8F"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_MULTIPLY_8F'''
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed by preprocessor'''
depends_on = ['ilp_cpu_profile_macro_expansion']
reviewed = true

[[axioms]]
id = "macro_ilp_n_multiply_8f_effect_simple_substitution"
content = '''ILP_N_MULTIPLY_8F performs simple textual substitution with no arguments, no multiple evaluation, and no side effects during expansion'''
formal_spec = '''no_side_effects(ILP_N_MULTIPLY_8F) ∧ evaluation_count(ILP_N_MULTIPLY_8F) = 0'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_MULTIPLY_8F"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_MULTIPLY_8F'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by macro design'''
depends_on = ['ilp_cpu_profile_macro_simple_substitution']
reviewed = true

[[axioms]]
id = "macro_ilp_n_multiply_8f_effect_lvalue"
content = '''Any modification to ILP_N_MULTIPLY_8F directly modifies ILP_CPU_PROFILE.multiply_8f (lvalue semantics preserved)'''
formal_spec = '''is_lvalue(ILP_N_MULTIPLY_8F) == is_lvalue(ILP_CPU_PROFILE.multiply_8f) ∧ address_of(ILP_N_MULTIPLY_8F) == address_of(ILP_CPU_PROFILE.multiply_8f)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_MULTIPLY_8F"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_MULTIPLY_8F'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by macro expansion'''
depends_on = ['cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b', 'cpp20_expr_cast_lvalue_result_d4e8a1c3', 'cpp20_basic_lval_temp_materialization_b4e9f1c5']
reviewed = true

[[axioms]]
id = "macro_ilp_n_multiply_8f_context_sensitivity"
content = '''The semantic meaning of ILP_N_MULTIPLY_8F depends on the definition of ILP_CPU_PROFILE at the point of use, not at the point of macro definition'''
formal_spec = '''semantic_binding(ILP_N_MULTIPLY_8F) == binding_at_use_site(ILP_CPU_PROFILE.multiply_8f)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_MULTIPLY_8F"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_MULTIPLY_8F'''
axiom_type = "effect"
on_violation = '''N/A - macro behavior is context-dependent by design'''
depends_on = ['ilp_cpu_profile_macro_context_sensitivity']
reviewed = true

[[axioms]]
id = "macro_ilp_n_multiply_8f_anti_pattern_global_dependency"
content = '''Using this macro creates an implicit dependency on ILP_CPU_PROFILE being defined in scope; consider using the qualified name ILP_CPU_PROFILE.multiply_8f directly for clarity'''
formal_spec = '''implicit_dependency(ILP_N_MULTIPLY_8F, ILP_CPU_PROFILE)'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "ILP_N_MULTIPLY_8F"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_MULTIPLY_8F'''
axiom_type = "anti_pattern"
on_violation = '''Reduced code clarity and maintainability'''
depends_on = ['ilp_n_shift_4_macro_anti_pattern_global_dependency']
reviewed = true

[[axioms]]
id = "macro_ilp_n_multiply_4i_expansion"
content = '''After macro expansion, ILP_N_MULTIPLY_4I is textually replaced with ILP_CPU_PROFILE.multiply_4i'''
formal_spec = '''expansion(ILP_N_MULTIPLY_4I) == expansion(ILP_CPU_PROFILE) + '.multiply_4i''''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_MULTIPLY_4I"
header = "ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_MULTIPLY_4I'''
axiom_type = "postcondition"
on_violation = '''compilation error if ILP_CPU_PROFILE is not defined'''
depends_on = ['ilp_cpu_profile_macro_expansion']
reviewed = true

[[axioms]]
id = "macro_ilp_n_multiply_4i_precondition_dependency"
content = '''ILP_CPU_PROFILE must be defined and refer to an object/struct with a multiply_4i member before ILP_N_MULTIPLY_4I can be used'''
formal_spec = '''requires(defined(ILP_CPU_PROFILE) ∧ has_member(ILP_CPU_PROFILE, multiply_4i))'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_MULTIPLY_4I"
header = "ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_MULTIPLY_4I'''
axiom_type = "precondition"
on_violation = '''compilation error: undefined identifier or no member named 'multiply_4i''''
depends_on = ['ilp_cpu_profile_macro_expansion']
reviewed = true

[[axioms]]
id = "macro_ilp_n_multiply_4i_effect_simple_substitution"
content = '''ILP_N_MULTIPLY_4I performs simple textual substitution with no arguments, no multiple evaluation, and no side effects at macro expansion time'''
formal_spec = '''no_side_effects(ILP_N_MULTIPLY_4I) ∧ evaluation_count(ILP_N_MULTIPLY_4I) = 0'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_MULTIPLY_4I"
header = "ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_MULTIPLY_4I'''
axiom_type = "effect"
on_violation = '''N/A - this is guaranteed by the macro definition'''
depends_on = ['ilp_cpu_profile_macro_simple_substitution']
reviewed = true

[[axioms]]
id = "macro_ilp_n_multiply_4i_effect_lvalue"
content = '''Any modification to ILP_N_MULTIPLY_4I directly modifies ILP_CPU_PROFILE.multiply_4i (lvalue semantics preserved through member access)'''
formal_spec = '''is_lvalue(ILP_N_MULTIPLY_4I) == is_lvalue(ILP_CPU_PROFILE.multiply_4i) ∧ address_of(ILP_N_MULTIPLY_4I) == address_of(ILP_CPU_PROFILE.multiply_4i)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_MULTIPLY_4I"
header = "ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_MULTIPLY_4I'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by textual substitution'''
depends_on = ['cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b', 'cpp20_expr_cast_lvalue_result_d4e8a1c3', 'cpp20_basic_lval_temp_materialization_b4e9f1c5']
reviewed = true

[[axioms]]
id = "macro_ilp_n_multiply_4i_context_sensitivity"
content = '''The meaning of ILP_N_MULTIPLY_4I depends on the definition of ILP_CPU_PROFILE at the point of use, which itself depends on ilp::cpu::default_profile'''
formal_spec = '''semantic_binding(ILP_N_MULTIPLY_4I) == binding_at_use_site(ILP_CPU_PROFILE.multiply_4i)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_MULTIPLY_4I"
header = "ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_MULTIPLY_4I'''
axiom_type = "invariant"
on_violation = '''different behavior in different translation units if ILP_CPU_PROFILE has different definitions'''
depends_on = ['ilp_cpu_profile_macro_context_sensitivity']
reviewed = true

[[axioms]]
id = "macro_ilp_n_multiply_4i_anti_pattern_global_dependency"
content = '''Using this macro creates an implicit dependency on ILP_CPU_PROFILE being defined in scope; consider using ILP_CPU_PROFILE.multiply_4i directly for clarity'''
formal_spec = '''implicit_dependency(ILP_N_MULTIPLY_4I, ILP_CPU_PROFILE)'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "ILP_N_MULTIPLY_4I"
header = "ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_MULTIPLY_4I'''
axiom_type = "anti_pattern"
on_violation = '''reduced code clarity and maintainability; harder to trace data dependencies'''
depends_on = ['ilp_n_shift_4_macro_anti_pattern_global_dependency']
reviewed = true

[[axioms]]
id = "ilp_n_multiply_8i_macro_expansion"
content = '''After macro expansion, ILP_N_MULTIPLY_8I is textually replaced with ILP_CPU_PROFILE.multiply_8i'''
formal_spec = '''expansion(ILP_N_MULTIPLY_8I) == 'ILP_CPU_PROFILE.multiply_8i''''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_MULTIPLY_8I"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_MULTIPLY_8I'''
axiom_type = "postcondition"
on_violation = '''compilation error if macro not defined'''
depends_on = ['ilp_cpu_profile_macro_expansion']
reviewed = true

[[axioms]]
id = "ilp_n_multiply_8i_macro_precondition_dependency"
content = '''ILP_CPU_PROFILE must be defined and in scope before using ILP_N_MULTIPLY_8I'''
formal_spec = '''requires(defined(ILP_CPU_PROFILE) ∧ in_scope(ILP_CPU_PROFILE))'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_MULTIPLY_8I"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_MULTIPLY_8I'''
axiom_type = "precondition"
on_violation = '''compilation error: undefined identifier'''
depends_on = ['ilp_cpu_profile_macro_expansion']
reviewed = true

[[axioms]]
id = "ilp_n_multiply_8i_macro_effect_simple_substitution"
content = '''ILP_N_MULTIPLY_8I performs simple textual substitution with no arguments, no multiple evaluation, and no side effects'''
formal_spec = '''no_side_effects(ILP_N_MULTIPLY_8I) ∧ evaluation_count(ILP_N_MULTIPLY_8I) = 0'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_MULTIPLY_8I"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_MULTIPLY_8I'''
axiom_type = "effect"
on_violation = '''n/a - guaranteed by macro structure'''
depends_on = ['ilp_cpu_profile_macro_simple_substitution']
reviewed = true

[[axioms]]
id = "ilp_n_multiply_8i_macro_context_sensitivity"
content = '''The meaning of ILP_N_MULTIPLY_8I depends on the definition of ilp::cpu::default_profile at the point of use, not at the point of macro definition'''
formal_spec = '''semantic_binding(ILP_N_MULTIPLY_8I) == binding_at_use_site(ilp::cpu::default_profile.multiply_8i)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_MULTIPLY_8I"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_MULTIPLY_8I'''
axiom_type = "effect"
on_violation = '''wrong value accessed if multiple definitions of default_profile exist'''
depends_on = ['ilp_cpu_profile_macro_context_sensitivity']
reviewed = true

[[axioms]]
id = "ilp_n_multiply_8i_macro_effect_lvalue"
content = '''Any modification to ILP_N_MULTIPLY_8I directly modifies ILP_CPU_PROFILE.multiply_8i (lvalue semantics preserved)'''
formal_spec = '''is_lvalue(ILP_N_MULTIPLY_8I) == is_lvalue(ILP_CPU_PROFILE.multiply_8i) && address_of(ILP_N_MULTIPLY_8I) == address_of(ILP_CPU_PROFILE.multiply_8i)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_MULTIPLY_8I"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_MULTIPLY_8I'''
axiom_type = "effect"
on_violation = '''n/a - guaranteed by macro expansion semantics'''
depends_on = ['cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b', 'cpp20_expr_cast_lvalue_result_d4e8a1c3', 'cpp20_basic_lval_temp_materialization_b4e9f1c5']
reviewed = true

[[axioms]]
id = "ilp_n_multiply_8i_macro_anti_pattern_global_dependency"
content = '''Using this macro creates an implicit dependency on ILP_CPU_PROFILE being defined in scope; consider using the qualified name directly for clarity'''
formal_spec = '''implicit_dependency(ILP_N_MULTIPLY_8I, ILP_CPU_PROFILE)'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "ILP_N_MULTIPLY_8I"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_MULTIPLY_8I'''
axiom_type = "anti_pattern"
on_violation = '''reduced code clarity and maintainability'''
depends_on = ['ilp_n_shift_4_macro_anti_pattern_global_dependency']
reviewed = true

[[axioms]]
id = "ilp_n_multiply_8i_macro_precondition_member_exists"
content = '''ILP_CPU_PROFILE must have a member named multiply_8i accessible at the point of use'''
formal_spec = '''requires(has_member(ILP_CPU_PROFILE, multiply_8i))'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_MULTIPLY_8I"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_MULTIPLY_8I'''
axiom_type = "precondition"
on_violation = '''compilation error: no member named multiply_8i'''
depends_on = ['ilp_cpu_profile_macro_expansion']
reviewed = true

[[axioms]]
id = "macro_ilp_n_divide_4f_precondition_profile_defined"
content = '''ILP_CPU_PROFILE must be defined and in scope before using ILP_N_DIVIDE_4F'''
formal_spec = '''defined(ILP_CPU_PROFILE) ∧ in_scope(ILP_CPU_PROFILE)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_DIVIDE_4F"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_DIVIDE_4F'''
axiom_type = "precondition"
on_violation = '''Compilation error: ILP_CPU_PROFILE not defined'''
depends_on = ['ilp_cpu_profile_macro_expansion', 'ilp_n_shift_4_macro_anti_pattern_global_dependency']
reviewed = true

[[axioms]]
id = "macro_ilp_n_divide_4f_precondition_member_exists"
content = '''ILP_CPU_PROFILE must have a member named divide_4f'''
formal_spec = '''has_member(ILP_CPU_PROFILE, 'divide_4f')'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_DIVIDE_4F"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_DIVIDE_4F'''
axiom_type = "precondition"
on_violation = '''Compilation error: no member named 'divide_4f' in ILP_CPU_PROFILE'''
depends_on = ['ilp_cpu_profile_macro_expansion']
reviewed = true

[[axioms]]
id = "macro_ilp_n_divide_4f_postcondition_expansion"
content = '''After macro expansion, ILP_N_DIVIDE_4F is textually replaced with ILP_CPU_PROFILE.divide_4f'''
formal_spec = '''expansion(ILP_N_DIVIDE_4F) == 'ILP_CPU_PROFILE.divide_4f''''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_DIVIDE_4F"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_DIVIDE_4F'''
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed by preprocessor'''
depends_on = ['ilp_cpu_profile_macro_simple_substitution']
reviewed = true

[[axioms]]
id = "macro_ilp_n_divide_4f_effect_lvalue"
content = '''Any modification to ILP_N_DIVIDE_4F directly modifies ILP_CPU_PROFILE.divide_4f (lvalue semantics preserved)'''
formal_spec = '''is_lvalue(ILP_N_DIVIDE_4F) == is_lvalue(ILP_CPU_PROFILE.divide_4f) && address_of(ILP_N_DIVIDE_4F) == address_of(ILP_CPU_PROFILE.divide_4f)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_DIVIDE_4F"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_DIVIDE_4F'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by textual substitution'''
depends_on = ['cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b', 'cpp20_expr_cast_lvalue_result_d4e8a1c3', 'cpp20_basic_lval_temp_materialization_b4e9f1c5']
reviewed = true

[[axioms]]
id = "macro_ilp_n_divide_4f_effect_no_side_effects"
content = '''ILP_N_DIVIDE_4F performs simple textual substitution with no arguments, no multiple evaluation, and no side effects'''
formal_spec = '''no_side_effects(ILP_N_DIVIDE_4F) ∧ evaluation_count(ILP_N_DIVIDE_4F) = 0'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_DIVIDE_4F"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_DIVIDE_4F'''
axiom_type = "effect"
on_violation = '''N/A - object-like macro has no evaluation'''
depends_on = ['ilp_cpu_profile_macro_simple_substitution']
reviewed = true

[[axioms]]
id = "macro_ilp_n_divide_4f_effect_context_sensitivity"
content = '''The meaning of ILP_N_DIVIDE_4F depends on the definition of ILP_CPU_PROFILE at the point of use, not at the point of macro definition'''
formal_spec = '''semantic_binding(ILP_N_DIVIDE_4F) == binding_at_use_site(ILP_CPU_PROFILE.divide_4f)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_DIVIDE_4F"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_DIVIDE_4F'''
axiom_type = "effect"
on_violation = '''N/A - inherent property of macro expansion'''
depends_on = ['ilp_cpu_profile_macro_context_sensitivity']
reviewed = true

[[axioms]]
id = "macro_ilp_n_divide_4f_anti_pattern_global_dependency"
content = '''Using this macro creates an implicit dependency on ILP_CPU_PROFILE being defined in scope; consider using the qualified name directly for clarity'''
formal_spec = '''implicit_dependency(ILP_N_DIVIDE_4F, ILP_CPU_PROFILE)'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "ILP_N_DIVIDE_4F"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_DIVIDE_4F'''
axiom_type = "anti_pattern"
on_violation = '''Reduced code clarity and maintainability; potential compilation errors if ILP_CPU_PROFILE is not in scope'''
depends_on = ['ilp_n_shift_4_macro_anti_pattern_global_dependency']
reviewed = true

[[axioms]]
id = "macro_ilp_n_divide_4f_complexity_zero_overhead"
content = '''Macro expansion has zero runtime overhead - it is purely a compile-time textual substitution'''
formal_spec = '''runtime_overhead(ILP_N_DIVIDE_4F) = 0'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_DIVIDE_4F"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_DIVIDE_4F'''
axiom_type = "complexity"
on_violation = '''N/A - guaranteed by preprocessor semantics'''
depends_on = ['ilp_cpu_profile_macro_simple_substitution']
reviewed = true

[[axioms]]
id = "macro_ilp_n_divide_8f_precondition_profile_defined"
content = '''ILP_CPU_PROFILE must be defined in scope before using ILP_N_DIVIDE_8F'''
formal_spec = '''defined(ILP_CPU_PROFILE) == true'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_DIVIDE_8F"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_DIVIDE_8F'''
axiom_type = "precondition"
on_violation = '''Compilation error due to undefined identifier'''
depends_on = ['ilp_cpu_profile_macro_expansion']
reviewed = true

[[axioms]]
id = "macro_ilp_n_divide_8f_precondition_member_exists"
content = '''ILP_CPU_PROFILE must have a member named divide_8f accessible at the point of use'''
formal_spec = '''has_member(expansion(ILP_CPU_PROFILE), 'divide_8f') == true'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_DIVIDE_8F"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_DIVIDE_8F'''
axiom_type = "precondition"
on_violation = '''Compilation error due to no member named divide_8f'''
depends_on = ['ilp_cpu_profile_macro_expansion']
reviewed = true

[[axioms]]
id = "macro_ilp_n_divide_8f_postcondition_expansion"
content = '''After macro expansion, ILP_N_DIVIDE_8F is textually replaced with ILP_CPU_PROFILE.divide_8f'''
formal_spec = '''expansion(ILP_N_DIVIDE_8F) == 'ILP_CPU_PROFILE.divide_8f''''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_DIVIDE_8F"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_DIVIDE_8F'''
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed by preprocessor'''
depends_on = ['ilp_cpu_profile_macro_simple_substitution']
reviewed = true

[[axioms]]
id = "macro_ilp_n_divide_8f_effect_no_side_effects"
content = '''ILP_N_DIVIDE_8F performs simple textual substitution with no arguments, no multiple evaluation, and no side effects'''
formal_spec = '''no_side_effects(ILP_N_DIVIDE_8F) ∧ evaluation_count(ILP_N_DIVIDE_8F) = 0'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_DIVIDE_8F"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_DIVIDE_8F'''
axiom_type = "effect"
on_violation = '''N/A - no side effects possible'''
depends_on = ['ilp_cpu_profile_macro_simple_substitution']
reviewed = true

[[axioms]]
id = "macro_ilp_n_divide_8f_effect_lvalue"
content = '''Any modification to ILP_N_DIVIDE_8F directly modifies ILP_CPU_PROFILE.divide_8f (lvalue semantics preserved)'''
formal_spec = '''is_lvalue(ILP_N_DIVIDE_8F) == is_lvalue(ILP_CPU_PROFILE.divide_8f) && address_of(ILP_N_DIVIDE_8F) == address_of(ILP_CPU_PROFILE.divide_8f)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_DIVIDE_8F"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_DIVIDE_8F'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by macro expansion semantics'''
depends_on = ['cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b', 'cpp20_expr_cast_lvalue_result_d4e8a1c3', 'cpp20_basic_lval_temp_materialization_b4e9f1c5']
reviewed = true

[[axioms]]
id = "macro_ilp_n_divide_8f_effect_context_sensitivity"
content = '''The meaning of ILP_N_DIVIDE_8F depends on the definition of ilp::cpu::default_profile at the point of use, not at the point of macro definition'''
formal_spec = '''semantic_binding(ILP_N_DIVIDE_8F) == binding_at_use_site(ilp::cpu::default_profile.divide_8f)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_DIVIDE_8F"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_DIVIDE_8F'''
axiom_type = "effect"
on_violation = '''N/A - inherent property of textual macro substitution'''
depends_on = ['ilp_cpu_profile_macro_context_sensitivity']
reviewed = true

[[axioms]]
id = "macro_ilp_n_divide_8f_anti_pattern_global_dependency"
content = '''Using this macro creates an implicit dependency on ILP_CPU_PROFILE being defined in scope; consider using the qualified name directly for clarity'''
formal_spec = '''implicit_dependency(ILP_N_DIVIDE_8F, ILP_CPU_PROFILE)'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "ILP_N_DIVIDE_8F"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_DIVIDE_8F'''
axiom_type = "anti_pattern"
on_violation = '''Reduced code clarity and maintainability'''
depends_on = ['ilp_n_shift_4_macro_anti_pattern_global_dependency']
reviewed = true

[[axioms]]
id = "macro_ilp_n_divide_8f_complexity_zero_overhead"
content = '''ILP_N_DIVIDE_8F has zero runtime overhead compared to direct member access since it is a compile-time textual substitution'''
formal_spec = '''runtime_cost(ILP_N_DIVIDE_8F) == runtime_cost(ILP_CPU_PROFILE.divide_8f)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_DIVIDE_8F"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_DIVIDE_8F'''
axiom_type = "complexity"
on_violation = '''N/A - guaranteed by preprocessor'''
depends_on = ['ilp_cpu_profile_macro_simple_substitution']
reviewed = true

[[axioms]]
id = "ilp_n_sqrt_4f_macro_expansion"
content = '''After macro expansion, ILP_N_SQRT_4F is textually replaced with ILP_CPU_PROFILE.sqrt_4f'''
formal_spec = '''expansion(ILP_N_SQRT_4F) == 'ILP_CPU_PROFILE.sqrt_4f''''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SQRT_4F"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SQRT_4F'''
axiom_type = "postcondition"
on_violation = '''Compilation error if macro is not defined'''
depends_on = ['ilp_cpu_profile_macro_expansion']
reviewed = true

[[axioms]]
id = "ilp_n_sqrt_4f_macro_simple_substitution"
content = '''ILP_N_SQRT_4F performs simple textual substitution with no arguments, no multiple evaluation, and no side effects'''
formal_spec = '''no_side_effects(ILP_N_SQRT_4F) ∧ evaluation_count(ILP_N_SQRT_4F) = 0'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SQRT_4F"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SQRT_4F'''
axiom_type = "effect"
on_violation = '''N/A - this is a guarantee'''
depends_on = ['ilp_cpu_profile_macro_simple_substitution']
reviewed = true

[[axioms]]
id = "ilp_n_sqrt_4f_macro_precondition_ilp_cpu_profile_defined"
content = '''ILP_CPU_PROFILE must be defined in scope before using ILP_N_SQRT_4F'''
formal_spec = '''defined(ILP_CPU_PROFILE) == true'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SQRT_4F"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SQRT_4F'''
axiom_type = "precondition"
on_violation = '''Compilation error - undefined identifier ILP_CPU_PROFILE'''
depends_on = ['ilp_cpu_profile_macro_expansion']
reviewed = true

[[axioms]]
id = "ilp_n_sqrt_4f_macro_precondition_member_exists"
content = '''ILP_CPU_PROFILE must have a member named sqrt_4f accessible at the point of use'''
formal_spec = '''has_member(typeof(ILP_CPU_PROFILE), 'sqrt_4f') == true'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SQRT_4F"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SQRT_4F'''
axiom_type = "precondition"
on_violation = '''Compilation error - no member named sqrt_4f'''
depends_on = ['ilp_cpu_profile_macro_expansion']
reviewed = true

[[axioms]]
id = "ilp_n_sqrt_4f_macro_context_sensitivity"
content = '''The meaning of ILP_N_SQRT_4F depends on the definition of ILP_CPU_PROFILE at the point of use, not at the point of macro definition'''
formal_spec = '''semantic_binding(ILP_N_SQRT_4F) == binding_at_use_site(ILP_CPU_PROFILE.sqrt_4f)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SQRT_4F"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SQRT_4F'''
axiom_type = "effect"
on_violation = '''N/A - this is a guarantee of macro semantics'''
depends_on = ['ilp_cpu_profile_macro_context_sensitivity']
reviewed = true

[[axioms]]
id = "ilp_n_sqrt_4f_macro_effect_lvalue"
content = '''Any modification to ILP_N_SQRT_4F directly modifies ILP_CPU_PROFILE.sqrt_4f (lvalue semantics preserved)'''
formal_spec = '''is_lvalue(ILP_N_SQRT_4F) == is_lvalue(ILP_CPU_PROFILE.sqrt_4f) && address_of(ILP_N_SQRT_4F) == address_of(ILP_CPU_PROFILE.sqrt_4f)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SQRT_4F"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SQRT_4F'''
axiom_type = "effect"
on_violation = '''N/A - this is a guarantee'''
depends_on = ['cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b', 'cpp20_expr_cast_lvalue_result_d4e8a1c3', 'cpp20_basic_lval_temp_materialization_b4e9f1c5']
reviewed = true

[[axioms]]
id = "ilp_n_sqrt_4f_macro_anti_pattern_global_dependency"
content = '''Using this macro creates an implicit dependency on ILP_CPU_PROFILE being defined in scope; consider using the qualified name directly for clarity'''
formal_spec = '''implicit_dependency(ILP_N_SQRT_4F, ILP_CPU_PROFILE)'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "ILP_N_SQRT_4F"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SQRT_4F'''
axiom_type = "anti_pattern"
on_violation = '''Reduced code clarity and maintainability'''
depends_on = ['ilp_n_shift_4_macro_anti_pattern_global_dependency']
reviewed = true

[[axioms]]
id = "macro_ilp_n_sqrt_8f_precondition_cpu_profile_defined"
content = '''ILP_CPU_PROFILE must be defined and in scope before ILP_N_SQRT_8F can be used'''
formal_spec = '''is_defined(ILP_CPU_PROFILE) ∧ in_scope(ILP_CPU_PROFILE)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SQRT_8F"
header = "ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SQRT_8F'''
axiom_type = "precondition"
on_violation = '''Compilation error: ILP_CPU_PROFILE not defined'''
depends_on = ['ilp_cpu_profile_macro_expansion']
reviewed = true

[[axioms]]
id = "macro_ilp_n_sqrt_8f_precondition_member_exists"
content = '''ILP_CPU_PROFILE must have a member named sqrt_8f accessible at the point of use'''
formal_spec = '''has_member(expansion(ILP_CPU_PROFILE), 'sqrt_8f') ∧ is_accessible(expansion(ILP_CPU_PROFILE).sqrt_8f)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SQRT_8F"
header = "ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SQRT_8F'''
axiom_type = "precondition"
on_violation = '''Compilation error: no member named 'sqrt_8f' in the expansion of ILP_CPU_PROFILE'''
depends_on = ['ilp_cpu_profile_macro_expansion']
reviewed = true

[[axioms]]
id = "macro_ilp_n_sqrt_8f_expansion"
content = '''After macro expansion, ILP_N_SQRT_8F is textually replaced with ILP_CPU_PROFILE.sqrt_8f'''
formal_spec = '''expansion(ILP_N_SQRT_8F) == 'ILP_CPU_PROFILE.sqrt_8f''''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SQRT_8F"
header = "ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SQRT_8F'''
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed by preprocessor'''
depends_on = ['ilp_cpu_profile_macro_simple_substitution']
reviewed = true

[[axioms]]
id = "macro_ilp_n_sqrt_8f_effect_simple_substitution"
content = '''ILP_N_SQRT_8F performs simple textual substitution with no arguments, no multiple evaluation, and no side effects'''
formal_spec = '''no_side_effects(ILP_N_SQRT_8F) ∧ evaluation_count(ILP_N_SQRT_8F) = 0'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SQRT_8F"
header = "ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SQRT_8F'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by preprocessor'''
depends_on = ['ilp_cpu_profile_macro_simple_substitution']
reviewed = true

[[axioms]]
id = "macro_ilp_n_sqrt_8f_effect_lvalue"
content = '''Any modification to ILP_N_SQRT_8F directly modifies ILP_CPU_PROFILE.sqrt_8f (lvalue semantics preserved)'''
formal_spec = '''is_lvalue(ILP_N_SQRT_8F) == is_lvalue(ILP_CPU_PROFILE.sqrt_8f) && address_of(ILP_N_SQRT_8F) == address_of(ILP_CPU_PROFILE.sqrt_8f)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SQRT_8F"
header = "ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SQRT_8F'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by textual substitution'''
depends_on = ['cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b', 'cpp20_expr_cast_lvalue_result_d4e8a1c3', 'cpp20_basic_lval_temp_materialization_b4e9f1c5']
reviewed = true

[[axioms]]
id = "macro_ilp_n_sqrt_8f_context_sensitivity"
content = '''The meaning of ILP_N_SQRT_8F depends on the definition of ilp::cpu::default_profile at the point of use, not at the point of macro definition'''
formal_spec = '''semantic_binding(ILP_N_SQRT_8F) == binding_at_use_site(ilp::cpu::default_profile.sqrt_8f)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SQRT_8F"
header = "ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SQRT_8F'''
axiom_type = "effect"
on_violation = '''May access wrong object if default_profile changes between definition and use'''
depends_on = ['ilp_cpu_profile_macro_context_sensitivity']
reviewed = true

[[axioms]]
id = "macro_ilp_n_sqrt_8f_anti_pattern_global_dependency"
content = '''Using this macro creates an implicit dependency on ILP_CPU_PROFILE being defined in scope; consider using the qualified name directly for clarity'''
formal_spec = '''implicit_dependency(ILP_N_SQRT_8F, ILP_CPU_PROFILE)'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "ILP_N_SQRT_8F"
header = "ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SQRT_8F'''
axiom_type = "anti_pattern"
on_violation = '''Reduced code clarity and increased coupling'''
depends_on = ['ilp_n_shift_4_macro_anti_pattern_global_dependency']
reviewed = true

[[axioms]]
id = "ilp_n_minmax_1_macro_expansion"
content = '''After macro expansion, ILP_N_MINMAX_1 is textually replaced with ILP_CPU_PROFILE.minmax_1'''
formal_spec = '''expansion(ILP_N_MINMAX_1) == 'ILP_CPU_PROFILE.minmax_1''''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_MINMAX_1"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_MINMAX_1'''
axiom_type = "postcondition"
on_violation = '''compilation error if ILP_CPU_PROFILE is not defined'''
depends_on = ['ilp_cpu_profile_macro_expansion']
reviewed = true

[[axioms]]
id = "ilp_n_minmax_1_macro_simple_substitution"
content = '''ILP_N_MINMAX_1 performs simple textual substitution with no arguments, no multiple evaluation, and no side effects'''
formal_spec = '''no_side_effects(ILP_N_MINMAX_1) ∧ evaluation_count(ILP_N_MINMAX_1) = 0'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_MINMAX_1"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_MINMAX_1'''
axiom_type = "effect"
on_violation = '''N/A - macro has no parameters to evaluate'''
depends_on = ['ilp_cpu_profile_macro_simple_substitution']
reviewed = true

[[axioms]]
id = "ilp_n_minmax_1_macro_context_sensitivity"
content = '''The meaning of ILP_N_MINMAX_1 depends on the definition of ILP_CPU_PROFILE (and thus ilp::cpu::default_profile) at the point of use, not at the point of macro definition'''
formal_spec = '''semantic_binding(ILP_N_MINMAX_1) == binding_at_use_site(ilp::cpu::default_profile.minmax_1)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_MINMAX_1"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_MINMAX_1'''
axiom_type = "precondition"
on_violation = '''incorrect member access if ILP_CPU_PROFILE is redefined'''
depends_on = ['ilp_cpu_profile_macro_context_sensitivity']
reviewed = true

[[axioms]]
id = "ilp_n_minmax_1_macro_lvalue_semantics"
content = '''Any modification to ILP_N_MINMAX_1 directly modifies ILP_CPU_PROFILE.minmax_1 (lvalue semantics preserved)'''
formal_spec = '''is_lvalue(ILP_N_MINMAX_1) == is_lvalue(ILP_CPU_PROFILE.minmax_1) && address_of(ILP_N_MINMAX_1) == address_of(ILP_CPU_PROFILE.minmax_1)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_MINMAX_1"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_MINMAX_1'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by textual substitution'''
depends_on = ['cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b', 'cpp20_expr_cast_lvalue_result_d4e8a1c3', 'cpp20_basic_lval_temp_materialization_b4e9f1c5']
reviewed = true

[[axioms]]
id = "ilp_n_minmax_1_macro_precondition_dependency"
content = '''ILP_CPU_PROFILE must be defined and in scope before using ILP_N_MINMAX_1'''
formal_spec = '''is_defined(ILP_CPU_PROFILE) ∧ in_scope(ILP_CPU_PROFILE)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_MINMAX_1"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_MINMAX_1'''
axiom_type = "precondition"
on_violation = '''compilation error - ILP_CPU_PROFILE not defined'''
depends_on = ['ilp_cpu_profile_macro_expansion']
reviewed = true

[[axioms]]
id = "ilp_n_minmax_1_macro_anti_pattern_global_dependency"
content = '''Using this macro creates an implicit dependency on ILP_CPU_PROFILE being defined in scope; consider using ILP_CPU_PROFILE.minmax_1 directly for clarity'''
formal_spec = '''implicit_dependency(ILP_N_MINMAX_1, ILP_CPU_PROFILE)'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "ILP_N_MINMAX_1"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_MINMAX_1'''
axiom_type = "anti_pattern"
on_violation = '''reduced code readability and maintainability'''
depends_on = ['ilp_n_shift_4_macro_anti_pattern_global_dependency']
reviewed = true

[[axioms]]
id = "ilp_n_minmax_1_macro_member_existence"
content = '''ILP_CPU_PROFILE must have a member named minmax_1 for this macro to be valid'''
formal_spec = '''has_member(typeof(ILP_CPU_PROFILE), minmax_1)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_MINMAX_1"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_MINMAX_1'''
axiom_type = "precondition"
on_violation = '''compilation error - no member named minmax_1'''
depends_on = ['ilp_cpu_profile_macro_expansion']
reviewed = true

[[axioms]]
id = "macro_ilp_n_minmax_2_precondition_ilp_cpu_profile_defined"
content = '''ILP_CPU_PROFILE must be defined and in scope before ILP_N_MINMAX_2 is used'''
formal_spec = '''defined(ILP_CPU_PROFILE) ∧ in_scope(ILP_CPU_PROFILE)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_MINMAX_2"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_MINMAX_2'''
axiom_type = "precondition"
on_violation = '''Compilation error: ILP_CPU_PROFILE not defined'''
depends_on = ['ilp_cpu_profile_macro_context_sensitivity', 'ilp_cpu_profile_macro_expansion']
reviewed = true

[[axioms]]
id = "macro_ilp_n_minmax_2_precondition_minmax_2_member_exists"
content = '''ILP_CPU_PROFILE must have a member named minmax_2 accessible at the point of use'''
formal_spec = '''has_member(ILP_CPU_PROFILE, minmax_2) ∧ accessible(ILP_CPU_PROFILE.minmax_2)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_MINMAX_2"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_MINMAX_2'''
axiom_type = "precondition"
on_violation = '''Compilation error: no member named 'minmax_2' in the expansion of ILP_CPU_PROFILE'''
depends_on = ['ilp_cpu_profile_macro_expansion']
reviewed = true

[[axioms]]
id = "macro_ilp_n_minmax_2_postcondition_expansion"
content = '''After macro expansion, ILP_N_MINMAX_2 is textually replaced with ILP_CPU_PROFILE.minmax_2'''
formal_spec = '''expansion(ILP_N_MINMAX_2) == 'ILP_CPU_PROFILE.minmax_2''''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_MINMAX_2"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_MINMAX_2'''
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed by preprocessor'''
depends_on = ['ilp_cpu_profile_macro_expansion']
reviewed = true

[[axioms]]
id = "macro_ilp_n_minmax_2_effect_simple_substitution"
content = '''ILP_N_MINMAX_2 performs simple textual substitution with no arguments, no multiple evaluation, and no side effects'''
formal_spec = '''no_side_effects(ILP_N_MINMAX_2) ∧ evaluation_count(ILP_N_MINMAX_2) = 0'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_MINMAX_2"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_MINMAX_2'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by object-like macro definition'''
depends_on = ['ilp_cpu_profile_macro_simple_substitution']
reviewed = true

[[axioms]]
id = "macro_ilp_n_minmax_2_effect_lvalue"
content = '''Any modification to ILP_N_MINMAX_2 directly modifies ILP_CPU_PROFILE.minmax_2 (lvalue semantics preserved)'''
formal_spec = '''is_lvalue(ILP_N_MINMAX_2) == is_lvalue(ILP_CPU_PROFILE.minmax_2) ∧ address_of(ILP_N_MINMAX_2) == address_of(ILP_CPU_PROFILE.minmax_2)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_MINMAX_2"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_MINMAX_2'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by simple member access expansion'''
depends_on = ['cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b', 'cpp20_expr_cast_lvalue_result_d4e8a1c3', 'cpp20_basic_lval_temp_materialization_b4e9f1c5']
reviewed = true

[[axioms]]
id = "macro_ilp_n_minmax_2_effect_context_sensitivity"
content = '''The meaning of ILP_N_MINMAX_2 depends on the definition of ilp::cpu::default_profile at the point of use, not at the point of macro definition'''
formal_spec = '''semantic_binding(ILP_N_MINMAX_2) == binding_at_use_site(ilp::cpu::default_profile.minmax_2)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_MINMAX_2"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_MINMAX_2'''
axiom_type = "effect"
on_violation = '''N/A - inherent macro behavior'''
depends_on = ['ilp_cpu_profile_macro_context_sensitivity']
reviewed = true

[[axioms]]
id = "macro_ilp_n_minmax_2_anti_pattern_global_dependency"
content = '''Using this macro creates an implicit dependency on ILP_CPU_PROFILE being defined in scope; consider using the qualified name directly for clarity'''
formal_spec = '''implicit_dependency(ILP_N_MINMAX_2, ILP_CPU_PROFILE)'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "ILP_N_MINMAX_2"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_MINMAX_2'''
axiom_type = "anti_pattern"
on_violation = '''Reduced code clarity and maintainability'''
depends_on = ['ilp_n_shift_4_macro_anti_pattern_global_dependency']
reviewed = true

[[axioms]]
id = "macro_ilp_n_minmax_2_complexity_zero_overhead"
content = '''Using ILP_N_MINMAX_2 has zero runtime overhead compared to using ILP_CPU_PROFILE.minmax_2 directly (compile-time substitution)'''
formal_spec = '''runtime_cost(ILP_N_MINMAX_2) == runtime_cost(ILP_CPU_PROFILE.minmax_2)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_MINMAX_2"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_MINMAX_2'''
axiom_type = "complexity"
on_violation = '''N/A - guaranteed by preprocessor'''
depends_on = ['ilp_cpu_profile_macro_simple_substitution']
reviewed = true

[[axioms]]
id = "ilp_n_minmax_4i_macro_precondition_ilp_cpu_profile_defined"
content = '''ILP_CPU_PROFILE must be defined and in scope before using ILP_N_MINMAX_4I'''
formal_spec = '''is_defined(ILP_CPU_PROFILE) ∧ in_scope(ILP_CPU_PROFILE)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_MINMAX_4I"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_MINMAX_4I'''
axiom_type = "precondition"
on_violation = '''Compilation error due to undefined macro'''
depends_on = ['ilp_cpu_profile_macro_context_sensitivity', 'ilp_cpu_profile_macro_expansion']
reviewed = true

[[axioms]]
id = "ilp_n_minmax_4i_macro_precondition_minmax_4i_member_exists"
content = '''ILP_CPU_PROFILE must expand to an object or reference with a member named minmax_4i'''
formal_spec = '''has_member(expansion(ILP_CPU_PROFILE), 'minmax_4i')'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_MINMAX_4I"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_MINMAX_4I'''
axiom_type = "precondition"
on_violation = '''Compilation error: no member named 'minmax_4i''''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "ilp_n_minmax_4i_macro_expansion"
content = '''After macro expansion, ILP_N_MINMAX_4I is textually replaced with ILP_CPU_PROFILE.minmax_4i'''
formal_spec = '''expansion(ILP_N_MINMAX_4I) == 'ILP_CPU_PROFILE.minmax_4i''''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_MINMAX_4I"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_MINMAX_4I'''
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed by preprocessor'''
depends_on = ['ilp_cpu_profile_macro_expansion']
reviewed = true

[[axioms]]
id = "ilp_n_minmax_4i_macro_effect_simple_substitution"
content = '''ILP_N_MINMAX_4I performs simple textual substitution with no arguments, no multiple evaluation, and no side effects during expansion'''
formal_spec = '''no_side_effects(ILP_N_MINMAX_4I) ∧ evaluation_count(ILP_N_MINMAX_4I) = 0'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_MINMAX_4I"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_MINMAX_4I'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by preprocessor'''
depends_on = ['ilp_cpu_profile_macro_simple_substitution']
reviewed = true

[[axioms]]
id = "ilp_n_minmax_4i_macro_effect_lvalue"
content = '''Any modification to ILP_N_MINMAX_4I directly modifies ILP_CPU_PROFILE.minmax_4i (lvalue semantics preserved)'''
formal_spec = '''is_lvalue(ILP_N_MINMAX_4I) == is_lvalue(ILP_CPU_PROFILE.minmax_4i) ∧ address_of(ILP_N_MINMAX_4I) == address_of(ILP_CPU_PROFILE.minmax_4i)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_MINMAX_4I"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_MINMAX_4I'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by textual substitution'''
depends_on = ['cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b', 'cpp20_expr_cast_lvalue_result_d4e8a1c3', 'cpp20_basic_lval_temp_materialization_b4e9f1c5']
reviewed = true

[[axioms]]
id = "ilp_n_minmax_4i_macro_context_sensitivity"
content = '''The ultimate binding of ILP_N_MINMAX_4I depends on the definition of ILP_CPU_PROFILE at the point of use, not at the point of macro definition'''
formal_spec = '''semantic_binding(ILP_N_MINMAX_4I) == binding_at_use_site(ILP_CPU_PROFILE.minmax_4i)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_MINMAX_4I"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_MINMAX_4I'''
axiom_type = "effect"
on_violation = '''N/A - semantic property of macro expansion'''
depends_on = ['ilp_cpu_profile_macro_context_sensitivity']
reviewed = true

[[axioms]]
id = "ilp_n_minmax_4i_macro_anti_pattern_global_dependency"
content = '''Using this macro creates an implicit dependency on ILP_CPU_PROFILE being defined in scope; consider using the qualified name directly for clarity'''
formal_spec = '''implicit_dependency(ILP_N_MINMAX_4I, ILP_CPU_PROFILE)'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "ILP_N_MINMAX_4I"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_MINMAX_4I'''
axiom_type = "anti_pattern"
on_violation = '''Reduced code clarity and potential maintenance issues'''
depends_on = ['ilp_n_shift_4_macro_anti_pattern_global_dependency']
reviewed = true

[[axioms]]
id = "ilp_n_minmax_4i_macro_anti_pattern_double_expansion"
content = '''ILP_N_MINMAX_4I expands to another macro ILP_CPU_PROFILE, creating a two-level expansion chain that may complicate debugging'''
formal_spec = '''is_macro(expansion_tokens(ILP_N_MINMAX_4I)[0])'''
layer = "library"
confidence = 0.85
source_file = ""
source_module = ""
function = "ILP_N_MINMAX_4I"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_MINMAX_4I'''
axiom_type = "anti_pattern"
on_violation = '''Reduced debuggability and unclear error messages'''
depends_on = ['ilp_cpu_profile_macro_expansion']
reviewed = true

[[axioms]]
id = "ilp_n_minmax_8i_macro_expansion"
content = '''After macro expansion, ILP_N_MINMAX_8I is textually replaced with ILP_CPU_PROFILE.minmax_8i'''
formal_spec = '''expansion(ILP_N_MINMAX_8I) == 'ILP_CPU_PROFILE.minmax_8i''''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_MINMAX_8I"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_MINMAX_8I'''
axiom_type = "effect"
on_violation = '''Compilation failure if ILP_CPU_PROFILE is not defined'''
depends_on = ['ilp_cpu_profile_macro_expansion']
reviewed = true

[[axioms]]
id = "ilp_n_minmax_8i_macro_simple_substitution"
content = '''ILP_N_MINMAX_8I performs simple textual substitution with no arguments, no multiple evaluation, and no side effects'''
formal_spec = '''no_side_effects(ILP_N_MINMAX_8I) ∧ evaluation_count(ILP_N_MINMAX_8I) = 0'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_MINMAX_8I"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_MINMAX_8I'''
axiom_type = "effect"
on_violation = '''Not applicable - macro has no parameters'''
depends_on = ['ilp_cpu_profile_macro_simple_substitution']
reviewed = true

[[axioms]]
id = "ilp_n_minmax_8i_macro_context_sensitivity"
content = '''The meaning of ILP_N_MINMAX_8I depends on the definition of ILP_CPU_PROFILE at the point of use, which transitively depends on ilp::cpu::default_profile'''
formal_spec = '''semantic_binding(ILP_N_MINMAX_8I) == binding_at_use_site(ILP_CPU_PROFILE.minmax_8i)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_MINMAX_8I"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_MINMAX_8I'''
axiom_type = "effect"
on_violation = '''Wrong value accessed if ILP_CPU_PROFILE definition changes between macro definition and use'''
depends_on = ['ilp_cpu_profile_macro_context_sensitivity']
reviewed = true

[[axioms]]
id = "ilp_n_minmax_8i_macro_precondition_ilp_cpu_profile_defined"
content = '''ILP_CPU_PROFILE must be defined and accessible in the scope where ILP_N_MINMAX_8I is used'''
formal_spec = '''is_defined(ILP_CPU_PROFILE) ∧ in_scope(ILP_CPU_PROFILE)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_MINMAX_8I"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_MINMAX_8I'''
axiom_type = "precondition"
on_violation = '''Compilation error due to undefined ILP_CPU_PROFILE'''
depends_on = ['ilp_cpu_profile_macro_expansion']
reviewed = true

[[axioms]]
id = "ilp_n_minmax_8i_macro_precondition_minmax_8i_member"
content = '''ILP_CPU_PROFILE must have a member named minmax_8i accessible at the point of use'''
formal_spec = '''has_member(ILP_CPU_PROFILE, 'minmax_8i')'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_MINMAX_8I"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_MINMAX_8I'''
axiom_type = "precondition"
on_violation = '''Compilation error: no member named 'minmax_8i' in the expanded expression'''
depends_on = ['ilp_cpu_profile_macro_expansion']
reviewed = true

[[axioms]]
id = "ilp_n_minmax_8i_macro_effect_lvalue"
content = '''Any modification to ILP_N_MINMAX_8I directly modifies ILP_CPU_PROFILE.minmax_8i (lvalue semantics preserved)'''
formal_spec = '''is_lvalue(ILP_N_MINMAX_8I) == is_lvalue(ILP_CPU_PROFILE.minmax_8i) && address_of(ILP_N_MINMAX_8I) == address_of(ILP_CPU_PROFILE.minmax_8i)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_MINMAX_8I"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_MINMAX_8I'''
axiom_type = "effect"
on_violation = '''Not applicable - textual substitution preserves lvalue/rvalue properties'''
depends_on = ['cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b', 'cpp20_expr_cast_lvalue_result_d4e8a1c3', 'cpp20_basic_lval_temp_materialization_b4e9f1c5']
reviewed = true

[[axioms]]
id = "ilp_n_minmax_8i_macro_anti_pattern_global_dependency"
content = '''Using this macro creates an implicit dependency on ILP_CPU_PROFILE being defined in scope; consider using ILP_CPU_PROFILE.minmax_8i directly for clarity'''
formal_spec = '''implicit_dependency(ILP_N_MINMAX_8I, ILP_CPU_PROFILE)'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "ILP_N_MINMAX_8I"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_MINMAX_8I'''
axiom_type = "anti_pattern"
on_violation = '''Reduced code clarity and maintainability'''
depends_on = ['ilp_n_shift_4_macro_anti_pattern_global_dependency']
reviewed = true

[[axioms]]
id = "ilp_n_minmax_8i_macro_postcondition_type_preservation"
content = '''After expansion, ILP_N_MINMAX_8I has exactly the same type as ILP_CPU_PROFILE.minmax_8i'''
formal_spec = '''typeof(ILP_N_MINMAX_8I) == typeof(ILP_CPU_PROFILE.minmax_8i)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_MINMAX_8I"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_MINMAX_8I'''
axiom_type = "postcondition"
on_violation = '''Not applicable - textual substitution guarantees type preservation'''
depends_on = ['ilp_cpu_profile_macro_simple_substitution']
reviewed = true

[[axioms]]
id = "macro_ilp_n_minmax_4f_precondition_ilp_cpu_profile_defined"
content = '''ILP_CPU_PROFILE macro must be defined and expand to an object with a minmax_4f member before ILP_N_MINMAX_4F can be used'''
formal_spec = '''defined(ILP_CPU_PROFILE) ∧ has_member(expansion(ILP_CPU_PROFILE), minmax_4f)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_MINMAX_4F"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_MINMAX_4F'''
axiom_type = "precondition"
on_violation = '''Compilation error: undefined identifier or member access on incomplete type'''
depends_on = ['ilp_cpu_profile_macro_expansion', 'ilp_cpu_profile_macro_context_sensitivity']
reviewed = true

[[axioms]]
id = "macro_ilp_n_minmax_4f_expansion"
content = '''After macro expansion, ILP_N_MINMAX_4F is textually replaced with ILP_CPU_PROFILE.minmax_4f'''
formal_spec = '''expansion(ILP_N_MINMAX_4F) == 'ILP_CPU_PROFILE.minmax_4f''''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_MINMAX_4F"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_MINMAX_4F'''
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed by preprocessor'''
depends_on = ['ilp_cpu_profile_macro_simple_substitution']
reviewed = true

[[axioms]]
id = "macro_ilp_n_minmax_4f_effect_no_side_effects"
content = '''ILP_N_MINMAX_4F performs simple textual substitution with no arguments, no multiple evaluation, and no side effects at expansion time'''
formal_spec = '''no_side_effects(ILP_N_MINMAX_4F) ∧ evaluation_count(ILP_N_MINMAX_4F) = 0'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_MINMAX_4F"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_MINMAX_4F'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by macro structure'''
depends_on = ['ilp_cpu_profile_macro_simple_substitution']
reviewed = true

[[axioms]]
id = "macro_ilp_n_minmax_4f_effect_lvalue"
content = '''Any modification to ILP_N_MINMAX_4F directly modifies ILP_CPU_PROFILE.minmax_4f (lvalue semantics preserved)'''
formal_spec = '''is_lvalue(ILP_N_MINMAX_4F) == is_lvalue(ILP_CPU_PROFILE.minmax_4f) ∧ address_of(ILP_N_MINMAX_4F) == address_of(ILP_CPU_PROFILE.minmax_4f)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_MINMAX_4F"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_MINMAX_4F'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by textual substitution'''
depends_on = ['cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b', 'cpp20_expr_cast_lvalue_result_d4e8a1c3', 'cpp20_basic_lval_temp_materialization_b4e9f1c5']
reviewed = true

[[axioms]]
id = "macro_ilp_n_minmax_4f_context_sensitivity"
content = '''The semantic binding of ILP_N_MINMAX_4F depends on the definition of ILP_CPU_PROFILE at the point of use, not at the point of macro definition'''
formal_spec = '''semantic_binding(ILP_N_MINMAX_4F) == binding_at_use_site(ILP_CPU_PROFILE.minmax_4f)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_MINMAX_4F"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_MINMAX_4F'''
axiom_type = "effect"
on_violation = '''May access different object than intended if ILP_CPU_PROFILE is redefined'''
depends_on = ['ilp_cpu_profile_macro_context_sensitivity']
reviewed = true

[[axioms]]
id = "macro_ilp_n_minmax_4f_anti_pattern_implicit_dependency"
content = '''Using ILP_N_MINMAX_4F creates an implicit dependency on ILP_CPU_PROFILE being defined in scope; consider using the qualified name directly for clarity'''
formal_spec = '''implicit_dependency(ILP_N_MINMAX_4F, ILP_CPU_PROFILE)'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "ILP_N_MINMAX_4F"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_MINMAX_4F'''
axiom_type = "anti_pattern"
on_violation = '''Reduced code clarity and maintainability; harder to trace dependencies'''
depends_on = ['ilp_n_shift_4_macro_anti_pattern_global_dependency', 'ilp_cpu_profile_macro_context_sensitivity']
reviewed = true

[[axioms]]
id = "macro_ilp_n_minmax_4f_complexity_zero_overhead"
content = '''ILP_N_MINMAX_4F has zero runtime overhead - it is purely compile-time textual substitution'''
formal_spec = '''runtime_cost(ILP_N_MINMAX_4F) = O(1) ∧ compile_time_cost(ILP_N_MINMAX_4F) = O(1)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_MINMAX_4F"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_MINMAX_4F'''
axiom_type = "complexity"
on_violation = '''N/A - guaranteed by preprocessor mechanism'''
depends_on = ['ilp_cpu_profile_macro_simple_substitution']
reviewed = true

[[axioms]]
id = "macro_ilp_n_minmax_8f_precondition_ilp_cpu_profile_defined"
content = '''ILP_CPU_PROFILE must be defined and in scope before using ILP_N_MINMAX_8F'''
formal_spec = '''defined(ILP_CPU_PROFILE) ∧ in_scope(ILP_CPU_PROFILE)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_MINMAX_8F"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_MINMAX_8F'''
axiom_type = "precondition"
on_violation = '''Compilation error due to undefined identifier'''
depends_on = ['ilp_cpu_profile_macro_context_sensitivity', 'ilp_n_shift_4_macro_anti_pattern_global_dependency']
reviewed = true

[[axioms]]
id = "macro_ilp_n_minmax_8f_precondition_member_exists"
content = '''ILP_CPU_PROFILE must have a member named minmax_8f accessible at the point of use'''
formal_spec = '''has_member(typeof(ILP_CPU_PROFILE), 'minmax_8f') ∧ is_accessible(ILP_CPU_PROFILE.minmax_8f)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_MINMAX_8F"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_MINMAX_8F'''
axiom_type = "precondition"
on_violation = '''Compilation error due to missing member or inaccessible member'''
depends_on = ['ilp_cpu_profile_macro_expansion']
reviewed = true

[[axioms]]
id = "macro_ilp_n_minmax_8f_postcondition_expansion"
content = '''After macro expansion, ILP_N_MINMAX_8F is textually replaced with ILP_CPU_PROFILE.minmax_8f'''
formal_spec = '''expansion(ILP_N_MINMAX_8F) == 'ILP_CPU_PROFILE.minmax_8f''''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_MINMAX_8F"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_MINMAX_8F'''
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed by preprocessor'''
depends_on = ['ilp_cpu_profile_macro_simple_substitution']
reviewed = true

[[axioms]]
id = "macro_ilp_n_minmax_8f_effect_no_side_effects"
content = '''ILP_N_MINMAX_8F performs simple textual substitution with no side effects and no multiple evaluation (object-like macro with no arguments)'''
formal_spec = '''no_side_effects(ILP_N_MINMAX_8F) ∧ evaluation_count(ILP_N_MINMAX_8F) = 0'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_MINMAX_8F"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_MINMAX_8F'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by macro structure'''
depends_on = ['ilp_cpu_profile_macro_simple_substitution']
reviewed = true

[[axioms]]
id = "macro_ilp_n_minmax_8f_effect_lvalue"
content = '''Any modification to ILP_N_MINMAX_8F directly modifies ILP_CPU_PROFILE.minmax_8f (lvalue semantics preserved)'''
formal_spec = '''is_lvalue(ILP_N_MINMAX_8F) == is_lvalue(ILP_CPU_PROFILE.minmax_8f) ∧ address_of(ILP_N_MINMAX_8F) == address_of(ILP_CPU_PROFILE.minmax_8f)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_MINMAX_8F"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_MINMAX_8F'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by textual substitution'''
depends_on = ['cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b', 'cpp20_expr_cast_lvalue_result_d4e8a1c3', 'cpp20_basic_lval_temp_materialization_b4e9f1c5']
reviewed = true

[[axioms]]
id = "macro_ilp_n_minmax_8f_anti_pattern_global_dependency"
content = '''Using this macro creates an implicit dependency on ILP_CPU_PROFILE being defined in scope; consider using the qualified name directly for clarity'''
formal_spec = '''implicit_dependency(ILP_N_MINMAX_8F, ILP_CPU_PROFILE)'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "ILP_N_MINMAX_8F"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_MINMAX_8F'''
axiom_type = "anti_pattern"
on_violation = '''Reduced code clarity and maintainability; potential compilation errors if ILP_CPU_PROFILE is not defined'''
depends_on = ['ilp_n_shift_4_macro_anti_pattern_global_dependency']
reviewed = true

[[axioms]]
id = "macro_ilp_n_minmax_8f_effect_context_sensitivity"
content = '''The meaning of ILP_N_MINMAX_8F depends on the definition of ILP_CPU_PROFILE at the point of use, not at the point of macro definition'''
formal_spec = '''semantic_binding(ILP_N_MINMAX_8F) == binding_at_use_site(ILP_CPU_PROFILE)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_MINMAX_8F"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_MINMAX_8F'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by macro expansion semantics'''
depends_on = ['ilp_cpu_profile_macro_context_sensitivity']
reviewed = true

[[axioms]]
id = "macro_ilp_n_bitwise_1_precondition_ilp_cpu_profile_defined"
content = '''ILP_CPU_PROFILE must be defined and in scope before ILP_N_BITWISE_1 is used'''
formal_spec = '''is_defined(ILP_CPU_PROFILE) ∧ in_scope(ILP_CPU_PROFILE)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_BITWISE_1"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_BITWISE_1'''
axiom_type = "precondition"
on_violation = '''Compilation error: undefined identifier'''
depends_on = ['ilp_cpu_profile_macro_context_sensitivity', 'ilp_cpu_profile_macro_expansion']
reviewed = true

[[axioms]]
id = "macro_ilp_n_bitwise_1_precondition_bitwise_1_member"
content = '''ILP_CPU_PROFILE must have a member named bitwise_1 accessible at the point of use'''
formal_spec = '''has_member(expansion(ILP_CPU_PROFILE), 'bitwise_1') ∧ is_accessible(expansion(ILP_CPU_PROFILE).bitwise_1)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_BITWISE_1"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_BITWISE_1'''
axiom_type = "precondition"
on_violation = '''Compilation error: no member named 'bitwise_1''''
depends_on = ['ilp_cpu_profile_macro_expansion']
reviewed = true

[[axioms]]
id = "macro_ilp_n_bitwise_1_expansion"
content = '''After macro expansion, ILP_N_BITWISE_1 is textually replaced with ILP_CPU_PROFILE.bitwise_1'''
formal_spec = '''expansion(ILP_N_BITWISE_1) == 'ILP_CPU_PROFILE.bitwise_1''''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_BITWISE_1"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_BITWISE_1'''
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed by preprocessor'''
depends_on = ['ilp_cpu_profile_macro_expansion']
reviewed = true

[[axioms]]
id = "macro_ilp_n_bitwise_1_effect_no_side_effects"
content = '''ILP_N_BITWISE_1 performs simple textual substitution with no arguments, no multiple evaluation, and no side effects'''
formal_spec = '''no_side_effects(ILP_N_BITWISE_1) ∧ evaluation_count(ILP_N_BITWISE_1) = 0'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_BITWISE_1"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_BITWISE_1'''
axiom_type = "effect"
on_violation = '''N/A - no side effects possible'''
depends_on = ['ilp_cpu_profile_macro_simple_substitution']
reviewed = true

[[axioms]]
id = "macro_ilp_n_bitwise_1_effect_lvalue"
content = '''Any modification to ILP_N_BITWISE_1 directly modifies ILP_CPU_PROFILE.bitwise_1 (lvalue semantics preserved)'''
formal_spec = '''is_lvalue(ILP_N_BITWISE_1) == is_lvalue(ILP_CPU_PROFILE.bitwise_1) ∧ address_of(ILP_N_BITWISE_1) == address_of(ILP_CPU_PROFILE.bitwise_1)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_BITWISE_1"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_BITWISE_1'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by textual substitution'''
depends_on = ['cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b', 'cpp20_expr_cast_lvalue_result_d4e8a1c3', 'cpp20_basic_lval_temp_materialization_b4e9f1c5']
reviewed = true

[[axioms]]
id = "macro_ilp_n_bitwise_1_context_sensitivity"
content = '''The meaning of ILP_N_BITWISE_1 depends on the definition of ILP_CPU_PROFILE (and transitively ilp::cpu::default_profile) at the point of use, not at the point of macro definition'''
formal_spec = '''semantic_binding(ILP_N_BITWISE_1) == binding_at_use_site(ILP_CPU_PROFILE.bitwise_1)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_BITWISE_1"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_BITWISE_1'''
axiom_type = "effect"
on_violation = '''N/A - context sensitivity is inherent to macro semantics'''
depends_on = ['ilp_cpu_profile_macro_context_sensitivity']
reviewed = true

[[axioms]]
id = "macro_ilp_n_bitwise_1_anti_pattern_global_dependency"
content = '''Using this macro creates an implicit dependency on ILP_CPU_PROFILE being defined in scope; consider using the qualified name directly for clarity'''
formal_spec = '''implicit_dependency(ILP_N_BITWISE_1, ILP_CPU_PROFILE)'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "ILP_N_BITWISE_1"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_BITWISE_1'''
axiom_type = "anti_pattern"
on_violation = '''Reduced code clarity and maintainability'''
depends_on = ['ilp_n_shift_4_macro_anti_pattern_global_dependency']
reviewed = true

[[axioms]]
id = "macro_ilp_n_bitwise_1_complexity_zero"
content = '''ILP_N_BITWISE_1 has zero runtime overhead - it is purely a compile-time textual substitution that resolves to a member access'''
formal_spec = '''runtime_overhead(ILP_N_BITWISE_1) = O(1) ∧ compile_time_overhead(ILP_N_BITWISE_1) = O(1)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_BITWISE_1"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_BITWISE_1'''
axiom_type = "complexity"
on_violation = '''N/A - guaranteed by preprocessor semantics'''
depends_on = ['ilp_cpu_profile_macro_simple_substitution']
reviewed = true

[[axioms]]
id = "ilp_n_bitwise_2_macro_expansion"
content = '''After macro expansion, ILP_N_BITWISE_2 is textually replaced with ILP_CPU_PROFILE.bitwise_2'''
formal_spec = '''expansion(ILP_N_BITWISE_2) == 'ILP_CPU_PROFILE.bitwise_2''''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_BITWISE_2"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_BITWISE_2'''
axiom_type = "postcondition"
on_violation = '''compilation error due to incorrect macro expansion'''
depends_on = ['ilp_cpu_profile_macro_expansion']
reviewed = true

[[axioms]]
id = "ilp_n_bitwise_2_macro_simple_substitution"
content = '''ILP_N_BITWISE_2 performs simple textual substitution with no arguments, no multiple evaluation, and no side effects'''
formal_spec = '''no_side_effects(ILP_N_BITWISE_2) ∧ evaluation_count(ILP_N_BITWISE_2) = 0'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_BITWISE_2"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_BITWISE_2'''
axiom_type = "effect"
on_violation = '''N/A - this is a guarantee of the macro'''
depends_on = ['ilp_cpu_profile_macro_simple_substitution']
reviewed = true

[[axioms]]
id = "ilp_n_bitwise_2_macro_context_sensitivity"
content = '''The meaning of ILP_N_BITWISE_2 depends on the definition of ILP_CPU_PROFILE (and transitively ilp::cpu::default_profile) at the point of use, not at the point of macro definition'''
formal_spec = '''semantic_binding(ILP_N_BITWISE_2) == binding_at_use_site(ILP_CPU_PROFILE.bitwise_2)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_BITWISE_2"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_BITWISE_2'''
axiom_type = "precondition"
on_violation = '''undefined behavior or compilation error if ILP_CPU_PROFILE is not defined'''
depends_on = ['ilp_cpu_profile_macro_context_sensitivity', 'ilp_cpu_profile_macro_expansion']
reviewed = true

[[axioms]]
id = "ilp_n_bitwise_2_macro_anti_pattern_global_dependency"
content = '''Using this macro creates an implicit dependency on ILP_CPU_PROFILE being defined in scope; consider using the qualified name directly for clarity'''
formal_spec = '''implicit_dependency(ILP_N_BITWISE_2, ILP_CPU_PROFILE)'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "ILP_N_BITWISE_2"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_BITWISE_2'''
axiom_type = "anti_pattern"
on_violation = '''reduced code readability and maintainability'''
depends_on = ['ilp_n_shift_4_macro_anti_pattern_global_dependency']
reviewed = true

[[axioms]]
id = "ilp_n_bitwise_2_macro_lvalue_semantics"
content = '''Any modification to ILP_N_BITWISE_2 directly modifies ILP_CPU_PROFILE.bitwise_2 (lvalue semantics preserved)'''
formal_spec = '''is_lvalue(ILP_N_BITWISE_2) == is_lvalue(ILP_CPU_PROFILE.bitwise_2) && address_of(ILP_N_BITWISE_2) == address_of(ILP_CPU_PROFILE.bitwise_2)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_BITWISE_2"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_BITWISE_2'''
axiom_type = "effect"
on_violation = '''N/A - this is a guarantee of textual substitution'''
depends_on = ['cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b', 'cpp20_expr_cast_lvalue_result_d4e8a1c3', 'cpp20_basic_lval_temp_materialization_b4e9f1c5']
reviewed = true

[[axioms]]
id = "ilp_n_bitwise_2_macro_precondition_ilp_cpu_profile_defined"
content = '''ILP_CPU_PROFILE must be defined and in scope before using ILP_N_BITWISE_2'''
formal_spec = '''defined(ILP_CPU_PROFILE) == true'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_BITWISE_2"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_BITWISE_2'''
axiom_type = "precondition"
on_violation = '''compilation error due to undefined identifier'''
depends_on = ['ilp_cpu_profile_macro_expansion']
reviewed = true

[[axioms]]
id = "ilp_n_bitwise_2_macro_precondition_bitwise_2_member"
content = '''The expansion of ILP_CPU_PROFILE must have a member named bitwise_2'''
formal_spec = '''has_member(expansion(ILP_CPU_PROFILE), 'bitwise_2') == true'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_BITWISE_2"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_BITWISE_2'''
axiom_type = "precondition"
on_violation = '''compilation error due to invalid member access'''
depends_on = ['ilp_cpu_profile_macro_expansion']
reviewed = true

[[axioms]]
id = "macro_ilp_n_bitwise_4_precondition_ilp_cpu_profile_defined"
content = '''ILP_CPU_PROFILE must be defined and in scope before ILP_N_BITWISE_4 is used'''
formal_spec = '''defined(ILP_CPU_PROFILE) ∧ in_scope(ILP_CPU_PROFILE)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_BITWISE_4"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_BITWISE_4'''
axiom_type = "precondition"
on_violation = '''Compilation error: undefined identifier'''
depends_on = ['ilp_cpu_profile_macro_context_sensitivity']
reviewed = true

[[axioms]]
id = "macro_ilp_n_bitwise_4_precondition_bitwise_4_member"
content = '''ILP_CPU_PROFILE must have a member named bitwise_4 accessible at the point of use'''
formal_spec = '''has_member(ILP_CPU_PROFILE, bitwise_4) ∧ is_accessible(ILP_CPU_PROFILE.bitwise_4)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_BITWISE_4"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_BITWISE_4'''
axiom_type = "precondition"
on_violation = '''Compilation error: no member named 'bitwise_4''''
depends_on = ['ilp_cpu_profile_macro_expansion']
reviewed = true

[[axioms]]
id = "macro_ilp_n_bitwise_4_postcondition_expansion"
content = '''After macro expansion, ILP_N_BITWISE_4 is textually replaced with ILP_CPU_PROFILE.bitwise_4'''
formal_spec = '''expansion(ILP_N_BITWISE_4) == 'ILP_CPU_PROFILE.bitwise_4''''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_BITWISE_4"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_BITWISE_4'''
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed by preprocessor'''
depends_on = ['ilp_cpu_profile_macro_simple_substitution']
reviewed = true

[[axioms]]
id = "macro_ilp_n_bitwise_4_effect_no_side_effects"
content = '''ILP_N_BITWISE_4 performs simple textual substitution with no side effects and no multiple evaluation'''
formal_spec = '''no_side_effects(ILP_N_BITWISE_4) ∧ evaluation_count(ILP_N_BITWISE_4) = 0'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_BITWISE_4"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_BITWISE_4'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by simple substitution'''
depends_on = ['ilp_cpu_profile_macro_simple_substitution']
reviewed = true

[[axioms]]
id = "macro_ilp_n_bitwise_4_effect_lvalue"
content = '''Any modification to ILP_N_BITWISE_4 directly modifies ILP_CPU_PROFILE.bitwise_4 (lvalue semantics preserved)'''
formal_spec = '''is_lvalue(ILP_N_BITWISE_4) == is_lvalue(ILP_CPU_PROFILE.bitwise_4) ∧ address_of(ILP_N_BITWISE_4) == address_of(ILP_CPU_PROFILE.bitwise_4)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_BITWISE_4"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_BITWISE_4'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by simple substitution'''
depends_on = ['cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b', 'cpp20_expr_cast_lvalue_result_d4e8a1c3', 'cpp20_basic_lval_temp_materialization_b4e9f1c5']
reviewed = true

[[axioms]]
id = "macro_ilp_n_bitwise_4_effect_context_sensitivity"
content = '''The meaning of ILP_N_BITWISE_4 depends on the definition of ILP_CPU_PROFILE at the point of use, not at the point of macro definition'''
formal_spec = '''semantic_binding(ILP_N_BITWISE_4) == binding_at_use_site(ILP_CPU_PROFILE)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_BITWISE_4"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_BITWISE_4'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by macro expansion rules'''
depends_on = ['ilp_cpu_profile_macro_context_sensitivity']
reviewed = true

[[axioms]]
id = "macro_ilp_n_bitwise_4_anti_pattern_global_dependency"
content = '''Using this macro creates an implicit dependency on ILP_CPU_PROFILE being defined in scope; consider using the qualified name directly for clarity'''
formal_spec = '''implicit_dependency(ILP_N_BITWISE_4, ILP_CPU_PROFILE)'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "ILP_N_BITWISE_4"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_BITWISE_4'''
axiom_type = "anti_pattern"
on_violation = '''Reduced code clarity and maintainability'''
depends_on = ['ilp_n_shift_4_macro_anti_pattern_global_dependency']
reviewed = true

[[axioms]]
id = "macro_ilp_n_bitwise_4_complexity_zero"
content = '''Macro expansion has zero runtime cost; complexity is O(1) textual substitution at compile time'''
formal_spec = '''runtime_cost(ILP_N_BITWISE_4) = 0 ∧ compile_time_cost(ILP_N_BITWISE_4) = O(1)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_BITWISE_4"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_BITWISE_4'''
axiom_type = "complexity"
on_violation = '''N/A - guaranteed by preprocessor'''
depends_on = ['ilp_cpu_profile_macro_simple_substitution']
reviewed = true

[[axioms]]
id = "macro_ilp_n_bitwise_8_precondition_ilp_cpu_profile_defined"
content = '''ILP_CPU_PROFILE must be defined and in scope before ILP_N_BITWISE_8 is used'''
formal_spec = '''defined(ILP_CPU_PROFILE) ∧ in_scope(ILP_CPU_PROFILE)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_BITWISE_8"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_BITWISE_8'''
axiom_type = "precondition"
on_violation = '''Compilation error: undefined identifier'''
depends_on = ['ilp_cpu_profile_macro_context_sensitivity', 'ilp_n_shift_4_macro_anti_pattern_global_dependency']
reviewed = true

[[axioms]]
id = "macro_ilp_n_bitwise_8_precondition_bitwise_8_member"
content = '''ILP_CPU_PROFILE must have a member named bitwise_8 accessible at the point of use'''
formal_spec = '''has_member(expansion(ILP_CPU_PROFILE), 'bitwise_8')'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_BITWISE_8"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_BITWISE_8'''
axiom_type = "precondition"
on_violation = '''Compilation error: no member named 'bitwise_8''''
depends_on = ['ilp_cpu_profile_macro_expansion', 'ilp_cpu_profile_macro_context_sensitivity']
reviewed = true

[[axioms]]
id = "macro_ilp_n_bitwise_8_expansion"
content = '''After macro expansion, ILP_N_BITWISE_8 is textually replaced with ILP_CPU_PROFILE.bitwise_8'''
formal_spec = '''expansion(ILP_N_BITWISE_8) == expansion(ILP_CPU_PROFILE) ++ '.bitwise_8''''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_BITWISE_8"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_BITWISE_8'''
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed by preprocessor'''
depends_on = ['ilp_cpu_profile_macro_expansion']
reviewed = true

[[axioms]]
id = "macro_ilp_n_bitwise_8_effect_simple_substitution"
content = '''ILP_N_BITWISE_8 performs simple textual substitution with no arguments, no multiple evaluation, and no side effects'''
formal_spec = '''no_side_effects(ILP_N_BITWISE_8) ∧ evaluation_count(ILP_N_BITWISE_8) = 0'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_BITWISE_8"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_BITWISE_8'''
axiom_type = "effect"
on_violation = '''N/A - no side effects possible'''
depends_on = ['ilp_cpu_profile_macro_simple_substitution']
reviewed = true

[[axioms]]
id = "macro_ilp_n_bitwise_8_effect_lvalue"
content = '''Any modification to ILP_N_BITWISE_8 directly modifies ILP_CPU_PROFILE.bitwise_8 (lvalue semantics preserved)'''
formal_spec = '''is_lvalue(ILP_N_BITWISE_8) == is_lvalue(ILP_CPU_PROFILE.bitwise_8) && address_of(ILP_N_BITWISE_8) == address_of(ILP_CPU_PROFILE.bitwise_8)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_BITWISE_8"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_BITWISE_8'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by textual substitution'''
depends_on = ['cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b', 'cpp20_expr_cast_lvalue_result_d4e8a1c3', 'cpp20_basic_lval_temp_materialization_b4e9f1c5']
reviewed = true

[[axioms]]
id = "macro_ilp_n_bitwise_8_anti_pattern_global_dependency"
content = '''Using this macro creates an implicit dependency on ILP_CPU_PROFILE being defined in scope; consider using the qualified name directly for clarity'''
formal_spec = '''implicit_dependency(ILP_N_BITWISE_8, ILP_CPU_PROFILE)'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "ILP_N_BITWISE_8"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_BITWISE_8'''
axiom_type = "anti_pattern"
on_violation = '''Reduced code clarity and maintainability'''
depends_on = ['ilp_n_shift_4_macro_anti_pattern_global_dependency']
reviewed = true

[[axioms]]
id = "macro_ilp_n_bitwise_8_context_sensitivity"
content = '''The meaning of ILP_N_BITWISE_8 depends on the definition of ilp::cpu::default_profile at the point of use, not at the point of macro definition'''
formal_spec = '''semantic_binding(ILP_N_BITWISE_8) == binding_at_use_site(ilp::cpu::default_profile.bitwise_8)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_BITWISE_8"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_BITWISE_8'''
axiom_type = "effect"
on_violation = '''N/A - inherent macro behavior'''
depends_on = ['ilp_cpu_profile_macro_context_sensitivity']
reviewed = true

[[axioms]]
id = "macro_ilp_n_bitwise_8_complexity"
content = '''Using ILP_N_BITWISE_8 has zero runtime overhead compared to accessing ILP_CPU_PROFILE.bitwise_8 directly (textual substitution only)'''
formal_spec = '''runtime_cost(ILP_N_BITWISE_8) == runtime_cost(ILP_CPU_PROFILE.bitwise_8)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_BITWISE_8"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_BITWISE_8'''
axiom_type = "complexity"
on_violation = '''N/A - guaranteed by preprocessor'''
depends_on = ['ilp_cpu_profile_macro_simple_substitution']
reviewed = true

[[axioms]]
id = "macro_ilp_n_shift_1_precondition_ilp_cpu_profile_defined"
content = '''ILP_CPU_PROFILE must be defined and in scope before using ILP_N_SHIFT_1'''
formal_spec = '''defined(ILP_CPU_PROFILE) ∧ in_scope(ILP_CPU_PROFILE)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SHIFT_1"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SHIFT_1'''
axiom_type = "precondition"
on_violation = '''Compilation error: undeclared identifier'''
depends_on = ['ilp_cpu_profile_macro_expansion']
reviewed = true

[[axioms]]
id = "macro_ilp_n_shift_1_precondition_shift_1_member_exists"
content = '''ILP_CPU_PROFILE must have a member named shift_1'''
formal_spec = '''has_member(ILP_CPU_PROFILE, 'shift_1')'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SHIFT_1"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SHIFT_1'''
axiom_type = "precondition"
on_violation = '''Compilation error: no member named 'shift_1''''
depends_on = ['ilp_cpu_profile_macro_expansion']
reviewed = true

[[axioms]]
id = "macro_ilp_n_shift_1_effect_simple_substitution"
content = '''ILP_N_SHIFT_1 performs simple textual substitution with no arguments, no multiple evaluation, and no side effects'''
formal_spec = '''expansion(ILP_N_SHIFT_1) == 'ILP_CPU_PROFILE.shift_1' ∧ no_side_effects(ILP_N_SHIFT_1) ∧ evaluation_count(ILP_N_SHIFT_1) = 0'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SHIFT_1"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SHIFT_1'''
axiom_type = "effect"
on_violation = '''N/A - this is the correct behavior'''
depends_on = ['ilp_cpu_profile_macro_simple_substitution']
reviewed = true

[[axioms]]
id = "macro_ilp_n_shift_1_effect_lvalue"
content = '''Any modification to ILP_N_SHIFT_1 directly modifies ILP_CPU_PROFILE.shift_1 (lvalue semantics preserved)'''
formal_spec = '''is_lvalue(ILP_N_SHIFT_1) == is_lvalue(ILP_CPU_PROFILE.shift_1) ∧ address_of(ILP_N_SHIFT_1) == address_of(ILP_CPU_PROFILE.shift_1)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SHIFT_1"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SHIFT_1'''
axiom_type = "effect"
on_violation = '''N/A - this is the correct behavior'''
depends_on = ['cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b', 'cpp20_expr_cast_lvalue_result_d4e8a1c3', 'cpp20_basic_lval_temp_materialization_b4e9f1c5']
reviewed = true

[[axioms]]
id = "macro_ilp_n_shift_1_effect_context_sensitivity"
content = '''The meaning of ILP_N_SHIFT_1 depends on the definition of ilp::cpu::default_profile at the point of use, not at the point of macro definition'''
formal_spec = '''semantic_binding(ILP_N_SHIFT_1) == binding_at_use_site(ilp::cpu::default_profile.shift_1)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SHIFT_1"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SHIFT_1'''
axiom_type = "effect"
on_violation = '''May access wrong profile if ilp::cpu::default_profile changes between contexts'''
depends_on = ['ilp_cpu_profile_macro_context_sensitivity']
reviewed = true

[[axioms]]
id = "macro_ilp_n_shift_1_anti_pattern_global_dependency"
content = '''Using this macro creates an implicit dependency on ILP_CPU_PROFILE being defined in scope; consider using the qualified name directly for clarity'''
formal_spec = '''implicit_dependency(ILP_N_SHIFT_1, ILP_CPU_PROFILE) ∧ clarity(ILP_CPU_PROFILE.shift_1) > clarity(ILP_N_SHIFT_1)'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "ILP_N_SHIFT_1"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SHIFT_1'''
axiom_type = "anti_pattern"
on_violation = '''Reduced code readability and increased coupling'''
depends_on = ['ilp_n_shift_4_macro_anti_pattern_global_dependency']
reviewed = true

[[axioms]]
id = "macro_ilp_n_shift_1_postcondition_expansion"
content = '''After macro expansion, ILP_N_SHIFT_1 is textually replaced with ILP_CPU_PROFILE.shift_1'''
formal_spec = '''expansion(ILP_N_SHIFT_1) == 'ILP_CPU_PROFILE.shift_1''''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SHIFT_1"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SHIFT_1'''
axiom_type = "postcondition"
on_violation = '''N/A - this is guaranteed by the preprocessor'''
depends_on = ['ilp_cpu_profile_macro_expansion']
reviewed = true

[[axioms]]
id = "ilp_n_shift_2_macro_expansion"
content = '''After macro expansion, ILP_N_SHIFT_2 is textually replaced with ILP_CPU_PROFILE.shift_2'''
formal_spec = '''expansion(ILP_N_SHIFT_2) == 'ILP_CPU_PROFILE.shift_2''''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SHIFT_2"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SHIFT_2'''
axiom_type = "postcondition"
on_violation = '''compilation error if ILP_CPU_PROFILE is not defined'''
depends_on = ['ilp_cpu_profile_macro_expansion']
reviewed = true

[[axioms]]
id = "ilp_n_shift_2_macro_precondition_profile_defined"
content = '''ILP_CPU_PROFILE must be defined before using ILP_N_SHIFT_2'''
formal_spec = '''is_defined(ILP_CPU_PROFILE) == true'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SHIFT_2"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SHIFT_2'''
axiom_type = "precondition"
on_violation = '''compilation error: ILP_CPU_PROFILE not defined'''
depends_on = ['ilp_cpu_profile_macro_expansion']
reviewed = true

[[axioms]]
id = "ilp_n_shift_2_macro_precondition_member_exists"
content = '''The expansion of ILP_CPU_PROFILE must have a member named shift_2'''
formal_spec = '''has_member(expansion(ILP_CPU_PROFILE), 'shift_2') == true'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SHIFT_2"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SHIFT_2'''
axiom_type = "precondition"
on_violation = '''compilation error: no member named shift_2'''
depends_on = ['ilp_cpu_profile_macro_expansion']
reviewed = true

[[axioms]]
id = "ilp_n_shift_2_macro_effect_no_side_effects"
content = '''ILP_N_SHIFT_2 performs simple textual substitution with no side effects and no argument evaluation'''
formal_spec = '''no_side_effects(ILP_N_SHIFT_2) ∧ evaluation_count(ILP_N_SHIFT_2) = 0'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SHIFT_2"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SHIFT_2'''
axiom_type = "effect"
on_violation = '''N/A - macro has no parameters to evaluate'''
depends_on = ['ilp_cpu_profile_macro_simple_substitution']
reviewed = true

[[axioms]]
id = "ilp_n_shift_2_macro_context_sensitivity"
content = '''The meaning of ILP_N_SHIFT_2 depends on the definition of ILP_CPU_PROFILE at the point of use, not at the point of macro definition'''
formal_spec = '''semantic_binding(ILP_N_SHIFT_2) == binding_at_use_site(ILP_CPU_PROFILE.shift_2)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SHIFT_2"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SHIFT_2'''
axiom_type = "effect"
on_violation = '''N/A - always context-dependent'''
depends_on = ['ilp_cpu_profile_macro_context_sensitivity']
reviewed = true

[[axioms]]
id = "ilp_n_shift_2_macro_effect_lvalue"
content = '''Any modification to ILP_N_SHIFT_2 directly modifies ILP_CPU_PROFILE.shift_2 (lvalue semantics preserved)'''
formal_spec = '''is_lvalue(ILP_N_SHIFT_2) == is_lvalue(ILP_CPU_PROFILE.shift_2) && address_of(ILP_N_SHIFT_2) == address_of(ILP_CPU_PROFILE.shift_2)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SHIFT_2"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SHIFT_2'''
axiom_type = "effect"
on_violation = '''N/A - direct textual substitution preserves value category'''
depends_on = ['cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b', 'cpp20_expr_cast_lvalue_result_d4e8a1c3', 'cpp20_basic_lval_temp_materialization_b4e9f1c5']
reviewed = true

[[axioms]]
id = "ilp_n_shift_2_macro_anti_pattern_global_dependency"
content = '''Using this macro creates an implicit dependency on ILP_CPU_PROFILE being defined in scope; consider using the qualified name directly for clarity'''
formal_spec = '''implicit_dependency(ILP_N_SHIFT_2, ILP_CPU_PROFILE)'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "ILP_N_SHIFT_2"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SHIFT_2'''
axiom_type = "anti_pattern"
on_violation = '''reduced code clarity and maintainability'''
depends_on = ['ilp_n_shift_4_macro_anti_pattern_global_dependency']
reviewed = true

[[axioms]]
id = "ilp_n_shift_2_macro_complexity"
content = '''Macro expansion has zero runtime cost (compile-time substitution only)'''
formal_spec = '''runtime_cost(ILP_N_SHIFT_2) == O(1) ∧ compile_time_cost(ILP_N_SHIFT_2) == O(1)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SHIFT_2"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SHIFT_2'''
axiom_type = "complexity"
on_violation = '''N/A - always constant time'''
reviewed = true

[[axioms]]
id = "macro_ilp_n_shift_4_precondition_profile_defined"
content = '''ILP_CPU_PROFILE must be defined and in scope before using ILP_N_SHIFT_4'''
formal_spec = '''defined(ILP_CPU_PROFILE) ∧ in_scope(ILP_CPU_PROFILE)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SHIFT_4"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SHIFT_4'''
axiom_type = "precondition"
on_violation = '''Compilation error: ILP_CPU_PROFILE not defined'''
depends_on = ['ilp_cpu_profile_macro_context_sensitivity', 'ilp_n_shift_4_macro_anti_pattern_global_dependency']
reviewed = true

[[axioms]]
id = "macro_ilp_n_shift_4_precondition_shift_4_member"
content = '''The expansion of ILP_CPU_PROFILE must have a member named shift_4'''
formal_spec = '''has_member(expansion(ILP_CPU_PROFILE), 'shift_4')'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SHIFT_4"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SHIFT_4'''
axiom_type = "precondition"
on_violation = '''Compilation error: no member named 'shift_4' in the expansion of ILP_CPU_PROFILE'''
depends_on = ['ilp_cpu_profile_macro_expansion']
reviewed = true

[[axioms]]
id = "macro_ilp_n_shift_4_postcondition_expansion"
content = '''After macro expansion, ILP_N_SHIFT_4 is textually replaced with ILP_CPU_PROFILE.shift_4'''
formal_spec = '''expansion(ILP_N_SHIFT_4) == 'ILP_CPU_PROFILE.shift_4''''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SHIFT_4"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SHIFT_4'''
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed by preprocessor'''
depends_on = ['ilp_cpu_profile_macro_expansion']
reviewed = true

[[axioms]]
id = "macro_ilp_n_shift_4_effect_no_side_effects"
content = '''ILP_N_SHIFT_4 performs simple textual substitution with no side effects and no evaluations'''
formal_spec = '''no_side_effects(ILP_N_SHIFT_4) ∧ evaluation_count(ILP_N_SHIFT_4) = 0'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SHIFT_4"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SHIFT_4'''
axiom_type = "effect"
on_violation = '''N/A - no side effects possible'''
depends_on = ['ilp_cpu_profile_macro_simple_substitution']
reviewed = true

[[axioms]]
id = "macro_ilp_n_shift_4_effect_lvalue"
content = '''Any modification to ILP_N_SHIFT_4 directly modifies ILP_CPU_PROFILE.shift_4 (lvalue semantics preserved)'''
formal_spec = '''is_lvalue(ILP_N_SHIFT_4) == is_lvalue(ILP_CPU_PROFILE.shift_4) ∧ address_of(ILP_N_SHIFT_4) == address_of(ILP_CPU_PROFILE.shift_4)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SHIFT_4"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SHIFT_4'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by textual substitution'''
depends_on = ['cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b', 'cpp20_expr_cast_lvalue_result_d4e8a1c3', 'cpp20_basic_lval_temp_materialization_b4e9f1c5']
reviewed = true

[[axioms]]
id = "macro_ilp_n_shift_4_effect_context_sensitivity"
content = '''The semantic meaning of ILP_N_SHIFT_4 depends on the definition of ILP_CPU_PROFILE at the point of use, not at the point where ILP_N_SHIFT_4 is defined'''
formal_spec = '''semantic_binding(ILP_N_SHIFT_4) == binding_at_use_site(ILP_CPU_PROFILE.shift_4)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SHIFT_4"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SHIFT_4'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by macro expansion order'''
depends_on = ['ilp_cpu_profile_macro_context_sensitivity']
reviewed = true

[[axioms]]
id = "macro_ilp_n_shift_4_anti_pattern_indirection"
content = '''This macro adds an unnecessary layer of indirection over ILP_CPU_PROFILE.shift_4; consider using the qualified name directly for clarity and to avoid hidden dependencies'''
formal_spec = '''unnecessary_indirection(ILP_N_SHIFT_4, ILP_CPU_PROFILE.shift_4)'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "ILP_N_SHIFT_4"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SHIFT_4'''
axiom_type = "anti_pattern"
on_violation = '''Reduced code clarity and maintainability'''
depends_on = ['ilp_n_shift_4_macro_anti_pattern_global_dependency']
reviewed = true

[[axioms]]
id = "macro_ilp_n_shift_8_precondition_ilp_cpu_profile_defined"
content = '''ILP_CPU_PROFILE must be defined and in scope before using ILP_N_SHIFT_8'''
formal_spec = '''defined(ILP_CPU_PROFILE) ∧ in_scope(ILP_CPU_PROFILE)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SHIFT_8"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SHIFT_8'''
axiom_type = "precondition"
on_violation = '''Compilation error: undefined identifier'''
depends_on = ['ilp_cpu_profile_macro_expansion', 'ilp_n_shift_4_macro_anti_pattern_global_dependency']
reviewed = true

[[axioms]]
id = "macro_ilp_n_shift_8_precondition_shift_8_member"
content = '''ILP_CPU_PROFILE must have a member named shift_8 for ILP_N_SHIFT_8 to be valid'''
formal_spec = '''has_member(ILP_CPU_PROFILE, 'shift_8')'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SHIFT_8"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SHIFT_8'''
axiom_type = "precondition"
on_violation = '''Compilation error: no member named 'shift_8''''
depends_on = ['ilp_cpu_profile_macro_expansion']
reviewed = true

[[axioms]]
id = "macro_ilp_n_shift_8_expansion"
content = '''After macro expansion, ILP_N_SHIFT_8 is textually replaced with ILP_CPU_PROFILE.shift_8'''
formal_spec = '''expansion(ILP_N_SHIFT_8) == 'ILP_CPU_PROFILE.shift_8''''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SHIFT_8"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SHIFT_8'''
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed by preprocessor'''
depends_on = ['ilp_cpu_profile_macro_simple_substitution']
reviewed = true

[[axioms]]
id = "macro_ilp_n_shift_8_effect_no_side_effects"
content = '''ILP_N_SHIFT_8 performs simple textual substitution with no side effects and no argument evaluation'''
formal_spec = '''no_side_effects(ILP_N_SHIFT_8) ∧ evaluation_count(ILP_N_SHIFT_8) = 0'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SHIFT_8"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SHIFT_8'''
axiom_type = "effect"
on_violation = '''N/A - no parameters to evaluate'''
depends_on = ['ilp_cpu_profile_macro_simple_substitution']
reviewed = true

[[axioms]]
id = "macro_ilp_n_shift_8_effect_lvalue"
content = '''Any modification to ILP_N_SHIFT_8 directly modifies ILP_CPU_PROFILE.shift_8 (lvalue semantics preserved)'''
formal_spec = '''is_lvalue(ILP_N_SHIFT_8) == is_lvalue(ILP_CPU_PROFILE.shift_8) && address_of(ILP_N_SHIFT_8) == address_of(ILP_CPU_PROFILE.shift_8)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SHIFT_8"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SHIFT_8'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by simple substitution'''
depends_on = ['cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b', 'cpp20_expr_cast_lvalue_result_d4e8a1c3', 'cpp20_basic_lval_temp_materialization_b4e9f1c5']
reviewed = true

[[axioms]]
id = "macro_ilp_n_shift_8_context_sensitivity"
content = '''The meaning of ILP_N_SHIFT_8 depends on the definition of ilp::cpu::default_profile at the point of use, not at the point of macro definition'''
formal_spec = '''semantic_binding(ILP_N_SHIFT_8) == binding_at_use_site(ilp::cpu::default_profile)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SHIFT_8"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SHIFT_8'''
axiom_type = "effect"
on_violation = '''Incorrect value if default_profile changes between definition and use'''
depends_on = ['ilp_cpu_profile_macro_context_sensitivity']
reviewed = true

[[axioms]]
id = "macro_ilp_n_shift_8_anti_pattern_implicit_dependency"
content = '''Using ILP_N_SHIFT_8 creates an implicit dependency on ILP_CPU_PROFILE being defined in scope; consider using ILP_CPU_PROFILE.shift_8 directly for clarity'''
formal_spec = '''implicit_dependency(ILP_N_SHIFT_8, ILP_CPU_PROFILE)'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "ILP_N_SHIFT_8"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SHIFT_8'''
axiom_type = "anti_pattern"
on_violation = '''Reduced code clarity and maintainability'''
depends_on = ['ilp_n_shift_4_macro_anti_pattern_global_dependency']
reviewed = true

[[axioms]]
id = "macro_ilp_n_shift_8_complexity_zero_overhead"
content = '''ILP_N_SHIFT_8 has zero runtime overhead - it is a compile-time textual substitution'''
formal_spec = '''runtime_cost(ILP_N_SHIFT_8) = O(1) ∧ expansion_time(ILP_N_SHIFT_8) = O(1)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SHIFT_8"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_cpu.hpp"
signature = '''ILP_N_SHIFT_8'''
axiom_type = "complexity"
on_violation = '''N/A - guaranteed by preprocessor mechanics'''
depends_on = ['ilp_cpu_profile_macro_simple_substitution']
reviewed = true

[[axioms]]
id = "ilp_n_sum_4_alias_precondition_f8a2c1e9"
content = '''ILP_N_SUM_4 requires that ILP_N_SUM_4F is defined before use, as this is a simple redirection macro'''
formal_spec = '''defined(ILP_N_SUM_4F) == true'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SUM_4"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_optimal_n.hpp"
signature = '''ILP_N_SUM_4'''
axiom_type = "precondition"
on_violation = '''compilation error: undefined macro'''
depends_on = ['ilp_n_sum_4_redirect_macro']
reviewed = true

[[axioms]]
id = "ilp_n_sum_4_transitive_preconditions_2b9f7d43"
content = '''All preconditions of ILP_N_SUM_4F apply transitively to ILP_N_SUM_4. This includes requirements on ILP_CPU_PROFILE being defined and having a valid sum_4f member.'''
formal_spec = '''forall precond in preconditions(ILP_N_SUM_4F): precond must hold for expansion(ILP_N_SUM_4)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SUM_4"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_optimal_n.hpp"
signature = '''ILP_N_SUM_4'''
axiom_type = "precondition"
on_violation = '''inherited from ILP_N_SUM_4F: compilation error or undefined behavior'''
depends_on = ['ilp_n_sum_4_transitivity', 'ilp_n_sum_4f_macro_effect_textual_substitution_7c3e8d92']
reviewed = true

[[axioms]]
id = "ilp_n_sum_4_effect_pure_substitution_6d4e2a17"
content = '''ILP_N_SUM_4 performs pure textual substitution to ILP_N_SUM_4F with no side effects during expansion. The macro is object-like (no parameters), so there are no argument evaluation concerns.'''
formal_spec = '''expand(ILP_N_SUM_4) == ILP_N_SUM_4F andBool noSideEffects(expand(ILP_N_SUM_4))'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SUM_4"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_optimal_n.hpp"
signature = '''ILP_N_SUM_4'''
axiom_type = "effect"
on_violation = '''N/A - this is guaranteed by macro semantics'''
depends_on = ['ilp_n_sum_4_redirect_macro']
reviewed = true

[[axioms]]
id = "ilp_n_sum_4_postcondition_type_inheritance_3f1a8c29"
content = '''After expansion, ILP_N_SUM_4 has the same type and value as ILP_CPU_PROFILE.sum_4f (via ILP_N_SUM_4F), establishing type equivalence through the redirection chain'''
formal_spec = '''type(expand(ILP_N_SUM_4)) == type(ILP_CPU_PROFILE.sum_4f) andBool value(expand(ILP_N_SUM_4)) == value(ILP_CPU_PROFILE.sum_4f)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SUM_4"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_optimal_n.hpp"
signature = '''ILP_N_SUM_4'''
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed by transitive expansion'''
depends_on = ['ilp_n_sum_4_redirect_macro', 'ilp_n_sum_4f_macro_effect_textual_substitution_7c3e8d92', 'ilp_n_sum_4_transitivity']
reviewed = true

[[axioms]]
id = "ilp_n_sum_4_constraint_no_params_c7e9d4b2"
content = '''ILP_N_SUM_4 is an object-like macro (no parameters), so it cannot accept arguments and does not have multiple evaluation concerns'''
formal_spec = '''isObjectLikeMacro(ILP_N_SUM_4) == true andBool paramCount(ILP_N_SUM_4) == 0'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SUM_4"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_optimal_n.hpp"
signature = '''ILP_N_SUM_4'''
axiom_type = "constraint"
on_violation = '''compilation error if used with parentheses or arguments'''
depends_on = ['ilp_n_sum_4_redirect_macro']
reviewed = true

[[axioms]]
id = "ilp_n_sum_4_complexity_zero_overhead_8a3f2e61"
content = '''ILP_N_SUM_4 has zero runtime overhead as it is resolved entirely at preprocessing time. Performance characteristics are identical to directly using ILP_CPU_PROFILE.sum_4f'''
formal_spec = '''runtimeCost(ILP_N_SUM_4) == O(1) andBool runtimeCost(ILP_N_SUM_4) == runtimeCost(ILP_CPU_PROFILE.sum_4f)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SUM_4"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_optimal_n.hpp"
signature = '''ILP_N_SUM_4'''
axiom_type = "complexity"
on_violation = '''N/A - guaranteed by preprocessor semantics'''
depends_on = ['ilp_n_sum_4_redirect_macro', 'ilp_n_sum_4f_macro_effect_textual_substitution_7c3e8d92']
reviewed = true

[[axioms]]
id = "ilp_n_sum_8_expansion_semantics"
content = '''ILP_N_SUM_8 expands to ILP_N_SUM_8F through textual substitution. The expansion is transitive: ILP_N_SUM_8 → ILP_N_SUM_8F → ILP_CPU_PROFILE.sum_8f. No side effects occur during expansion.'''
formal_spec = '''expand(ILP_N_SUM_8) = ILP_N_SUM_8F andBool expand(ILP_N_SUM_8F) = ILP_CPU_PROFILE.sum_8f andBool noSideEffects(ILP_N_SUM_8)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SUM_8"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_optimal_n.hpp"
signature = '''ILP_N_SUM_8'''
axiom_type = "effect"
on_violation = '''N/A - textual substitution always succeeds'''
depends_on = ['ilp_n_sum_8_alias_macro', 'macro_ilp_n_sum_8f_effect_alias_9f1e3b2a']
reviewed = true

[[axioms]]
id = "ilp_n_sum_8_no_argument_evaluation"
content = '''ILP_N_SUM_8 is an object-like macro with no parameters, therefore there are no arguments to evaluate and no risk of multiple evaluation side effects.'''
formal_spec = '''isObjectLikeMacro(ILP_N_SUM_8) andBool paramCount(ILP_N_SUM_8) = 0 andBool noArgumentEvaluation(ILP_N_SUM_8)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SUM_8"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_optimal_n.hpp"
signature = '''ILP_N_SUM_8'''
axiom_type = "postcondition"
on_violation = '''N/A - object-like macros have no parameters'''
depends_on = ['ilp_n_sum_8_no_params']
reviewed = true

[[axioms]]
id = "ilp_n_sum_8_final_form_member_access"
content = '''After full macro expansion, ILP_N_SUM_8 evaluates to a member access expression ILP_CPU_PROFILE.sum_8f. The validity of this expression depends on ILP_CPU_PROFILE being defined and sum_8f being a valid member.'''
formal_spec = '''fullyExpanded(ILP_N_SUM_8) = ILP_CPU_PROFILE.sum_8f andBool requires(isDefined(ILP_CPU_PROFILE) andBool hasMember(ILP_CPU_PROFILE, sum_8f))'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "ILP_N_SUM_8"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_optimal_n.hpp"
signature = '''ILP_N_SUM_8'''
axiom_type = "postcondition"
on_violation = '''Compilation error if ILP_CPU_PROFILE is undefined or does not have member sum_8f'''
depends_on = ['ilp_n_sum_8_alias_macro', 'macro_ilp_n_sum_8f_effect_alias_9f1e3b2a']
reviewed = true

[[axioms]]
id = "ilp_n_sum_8_type_inherited"
content = '''The type of ILP_N_SUM_8 is determined by the type of ILP_CPU_PROFILE.sum_8f. Since this is a simple alias chain, type constraints are inherited from the final expansion target.'''
formal_spec = '''typeOf(ILP_N_SUM_8) = typeOf(ILP_CPU_PROFILE.sum_8f)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_N_SUM_8"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/cpu_profiles/ilp_optimal_n.hpp"
signature = '''ILP_N_SUM_8'''
axiom_type = "constraint"
on_violation = '''Type errors propagate from the final member access expression'''
depends_on = ['ilp_n_sum_8_alias_macro', 'macro_ilp_n_sum_8f_effect_alias_9f1e3b2a']
reviewed = true

[[axioms]]
id = "ilp_always_inline_precondition_function_declaration"
content = '''ILP_ALWAYS_INLINE must be used as a function declaration specifier, not in arbitrary expressions'''
formal_spec = '''context(ILP_ALWAYS_INLINE) ∈ {function_declaration_specifiers}'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_ALWAYS_INLINE"
header = "ilp_for/detail/ctrl.hpp"
signature = '''ILP_ALWAYS_INLINE'''
axiom_type = "precondition"
on_violation = '''Compilation error or undefined behavior depending on context'''
reviewed = true

[[axioms]]
id = "ilp_always_inline_precondition_compiler_support"
content = '''The compiler must support __forceinline (MSVC-specific attribute)'''
formal_spec = '''compiler_supports(__forceinline) = true'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_ALWAYS_INLINE"
header = "ilp_for/detail/ctrl.hpp"
signature = '''ILP_ALWAYS_INLINE'''
axiom_type = "precondition"
on_violation = '''Compilation error if __forceinline is not recognized'''
reviewed = true

[[axioms]]
id = "ilp_always_inline_postcondition_inline_hint"
content = '''After expansion, the function is marked with __forceinline, giving a strong hint to the compiler to inline the function at all call sites'''
formal_spec = '''ILP_ALWAYS_INLINE → __forceinline'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_ALWAYS_INLINE"
header = "ilp_for/detail/ctrl.hpp"
signature = '''ILP_ALWAYS_INLINE'''
axiom_type = "postcondition"
on_violation = '''N/A - textual substitution always occurs'''
reviewed = true

[[axioms]]
id = "ilp_always_inline_effect_code_size"
content = '''Using ILP_ALWAYS_INLINE may significantly increase code size if the function is called from many locations, as each call site gets a copy of the function body'''
formal_spec = '''code_size(with_forceinline) ≥ code_size(without_forceinline)'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "ILP_ALWAYS_INLINE"
header = "ilp_for/detail/ctrl.hpp"
signature = '''ILP_ALWAYS_INLINE'''
axiom_type = "effect"
on_violation = '''N/A - this is a performance characteristic, not a correctness requirement'''
reviewed = true

[[axioms]]
id = "ilp_always_inline_anti_pattern_recursive"
content = '''Do not use ILP_ALWAYS_INLINE on recursive functions, as this can lead to compilation errors or infinite code expansion attempts'''
formal_spec = '''is_recursive(f) = true ⇒ ¬should_use(ILP_ALWAYS_INLINE, f)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_ALWAYS_INLINE"
header = "ilp_for/detail/ctrl.hpp"
signature = '''ILP_ALWAYS_INLINE'''
axiom_type = "anti_pattern"
on_violation = '''Compiler may ignore the inline directive, emit warnings, or fail to compile'''
reviewed = true

[[axioms]]
id = "ilp_always_inline_anti_pattern_large_functions"
content = '''Avoid using ILP_ALWAYS_INLINE on large functions, as forced inlining can degrade performance by bloating instruction cache and increasing compilation time'''
formal_spec = '''function_size(f) > threshold ⇒ ¬should_use(ILP_ALWAYS_INLINE, f)'''
layer = "library"
confidence = 0.85
source_file = ""
source_module = ""
function = "ILP_ALWAYS_INLINE"
header = "ilp_for/detail/ctrl.hpp"
signature = '''ILP_ALWAYS_INLINE'''
axiom_type = "anti_pattern"
on_violation = '''Degraded runtime performance due to instruction cache pressure despite faster call overhead elimination'''
reviewed = true

[[axioms]]
id = "ilp_always_inline_constraint_portability"
content = '''ILP_ALWAYS_INLINE is not portable across compilers; code using this macro should provide alternative definitions for non-MSVC compilers'''
formal_spec = '''portable_code ⇒ ∃(alternative_definition for ¬MSVC_compiler)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_ALWAYS_INLINE"
header = "ilp_for/detail/ctrl.hpp"
signature = '''ILP_ALWAYS_INLINE'''
axiom_type = "constraint"
on_violation = '''Code fails to compile on non-MSVC compilers (GCC, Clang, etc.)'''
reviewed = true

[[axioms]]
id = "ilp_always_inline_complexity_compile_time"
content = '''Extensive use of ILP_ALWAYS_INLINE increases compilation time as the compiler must perform inlining analysis and code generation at each call site'''
formal_spec = '''compile_time(with_forceinline) ≥ compile_time(without_forceinline)'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "ILP_ALWAYS_INLINE"
header = "ilp_for/detail/ctrl.hpp"
signature = '''ILP_ALWAYS_INLINE'''
axiom_type = "complexity"
on_violation = '''N/A - this is a compilation performance characteristic'''
reviewed = true

[[axioms]]
id = "ilp_always_inline.postcondition.attribute_expansion"
content = '''ILP_ALWAYS_INLINE expands to [[gnu::always_inline]] inline, applying both the GNU always_inline attribute and the inline keyword to the function declaration'''
formal_spec = '''ILP_ALWAYS_INLINE ≡ [[gnu::always_inline]] inline'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_ALWAYS_INLINE"
header = "ilp_for/detail/ctrl.hpp"
signature = '''ILP_ALWAYS_INLINE'''
axiom_type = "postcondition"
on_violation = '''N/A - textual substitution always occurs'''
depends_on = ['c11_c_decl_resolution_syntax_allocateIncompleteTentative_754037f1']
reviewed = true

[[axioms]]
id = "ilp_always_inline.constraint.usage_context"
content = '''ILP_ALWAYS_INLINE must be used in function declaration context where both attributes and inline specifier are valid'''
formal_spec = '''valid_context(ILP_ALWAYS_INLINE) → (valid_attribute_context([[gnu::always_inline]]) ∧ valid_inline_context)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_ALWAYS_INLINE"
header = "ilp_for/detail/ctrl.hpp"
signature = '''ILP_ALWAYS_INLINE'''
axiom_type = "constraint"
on_violation = '''Compilation error if used outside function declaration context'''
depends_on = ['c11_c_decl_resolution_syntax_allocateIncompleteTentative_754037f1']
reviewed = true

[[axioms]]
id = "ilp_always_inline.constraint.compiler_support"
content = '''The [[gnu::always_inline]] attribute requires GCC, Clang, or compatible compiler support for GNU attributes'''
formal_spec = '''use(ILP_ALWAYS_INLINE) → compiler_supports_gnu_attributes'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_ALWAYS_INLINE"
header = "ilp_for/detail/ctrl.hpp"
signature = '''ILP_ALWAYS_INLINE'''
axiom_type = "constraint"
on_violation = '''Compilation warning or error on compilers without GNU attribute support'''
reviewed = true

[[axioms]]
id = "ilp_always_inline.effect.inlining_semantics"
content = '''Functions declared with ILP_ALWAYS_INLINE must be inlined at all call sites; compiler will emit error or warning if inlining fails, unlike plain inline which is only a hint'''
formal_spec = '''∀ call_site: function_marked_always_inline(f) → (inlined(f, call_site) ∨ diagnostic_emitted)'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "ILP_ALWAYS_INLINE"
header = "ilp_for/detail/ctrl.hpp"
signature = '''ILP_ALWAYS_INLINE'''
axiom_type = "effect"
on_violation = '''Compiler diagnostic if function cannot be inlined'''
depends_on = ['c11_c_decl_resolution_syntax_allocateIncompleteTentative_754037f1']
reviewed = true

[[axioms]]
id = "ilp_always_inline.anti_pattern.definition_placement"
content = '''Functions declared with ILP_ALWAYS_INLINE must have their definition visible at all call sites (typically header-only), otherwise inlining cannot occur and compilation may fail'''
formal_spec = '''declared_with(f, ILP_ALWAYS_INLINE) → definition_visible_at_all_call_sites(f)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_ALWAYS_INLINE"
header = "ilp_for/detail/ctrl.hpp"
signature = '''ILP_ALWAYS_INLINE'''
axiom_type = "anti_pattern"
on_violation = '''Linker error or compiler error if definition not visible'''
depends_on = ['c11_c_decl_resolution_syntax_allocateIncompleteTentative_754037f1']
reviewed = true

[[axioms]]
id = "ilp_always_inline.complexity.code_size"
content = '''Functions marked with ILP_ALWAYS_INLINE will increase code size at each call site due to forced inlining; use only for performance-critical small functions'''
formal_spec = '''code_size_impact(ILP_ALWAYS_INLINE(f)) = O(call_count(f) × function_size(f))'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_ALWAYS_INLINE"
header = "ilp_for/detail/ctrl.hpp"
signature = '''ILP_ALWAYS_INLINE'''
axiom_type = "complexity"
on_violation = '''Code bloat and potential instruction cache misses if overused'''
reviewed = true

[[axioms]]
id = "ILP_ALWAYS_INLINE.expansion"
content = '''ILP_ALWAYS_INLINE expands to the 'inline' keyword, suggesting inline expansion to the compiler'''
formal_spec = '''expansion(ILP_ALWAYS_INLINE) = 'inline''''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_ALWAYS_INLINE"
header = "ilp_for/detail/ctrl.hpp"
signature = '''ILP_ALWAYS_INLINE'''
axiom_type = "postcondition"
on_violation = '''N/A - textual substitution always occurs'''
depends_on = ['c11_c_decl_resolution_syntax_allocateIncompleteTentative_754037f1']
reviewed = true

[[axioms]]
id = "ILP_ALWAYS_INLINE.usage_constraint"
content = '''ILP_ALWAYS_INLINE must be used in a context where the 'inline' keyword is valid (function definitions, variable declarations in C++17+)'''
formal_spec = '''valid_context(ILP_ALWAYS_INLINE) ⟹ valid_context(inline)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_ALWAYS_INLINE"
header = "ilp_for/detail/ctrl.hpp"
signature = '''ILP_ALWAYS_INLINE'''
axiom_type = "constraint"
on_violation = '''Compilation error if used in invalid context'''
depends_on = ['c11_c_decl_resolution_syntax_allocateIncompleteTentative_754037f1']
reviewed = true

[[axioms]]
id = "ILP_ALWAYS_INLINE.semantic_note"
content = '''Despite the name 'ALWAYS_INLINE', this macro only provides an inline hint to the compiler, not a guarantee of inlining; compiler may still choose not to inline'''
formal_spec = '''inline_hint(ILP_ALWAYS_INLINE) ∧ ¬guaranteed_inline(ILP_ALWAYS_INLINE)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_ALWAYS_INLINE"
header = "ilp_for/detail/ctrl.hpp"
signature = '''ILP_ALWAYS_INLINE'''
axiom_type = "effect"
on_violation = '''N/A - this is informational about compiler behavior'''
depends_on = ['c11_c_decl_resolution_syntax_allocateIncompleteTentative_754037f1']
reviewed = true

[[axioms]]
id = "ILP_ALWAYS_INLINE.odr_implication"
content = '''Functions declared with ILP_ALWAYS_INLINE follow ODR (One Definition Rule) relaxation for inline functions, allowing identical definitions in multiple translation units'''
formal_spec = '''inline_function(f) ⟹ odr_relaxation(f)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_ALWAYS_INLINE"
header = "ilp_for/detail/ctrl.hpp"
signature = '''ILP_ALWAYS_INLINE'''
axiom_type = "effect"
on_violation = '''N/A - this is a semantic property of inline keyword'''
depends_on = ['c11_c_decl_resolution_syntax_allocateIncompleteTentative_754037f1']
reviewed = true

[[axioms]]
id = "return_with_precondition_r_movable_7a3e2f91"
content = '''Type R must be move-constructible or move-assignable to support std::move(val)'''
formal_spec = '''is_move_constructible<R> || is_move_assignable<R>'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "return_with"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/ctrl.hpp"
signature = '''void return_with(R val)'''
axiom_type = "precondition"
on_violation = '''Compilation error: cannot move-construct or move-assign type R'''
depends_on = ['cpp20_dcl_init_list_copy_list_init_explicit_ctor_f2a3b4c5', 'cpp20_basic_life_vacuous_initialization_def_7c4e5d6a', 'cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8']
reviewed = true

[[axioms]]
id = "return_with_effect_sets_ok_false_9b4c1e82"
content = '''Sets member variable 'ok' to false, indicating a return state'''
formal_spec = '''post(ok == false)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "return_with"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/ctrl.hpp"
signature = '''void return_with(R val)'''
axiom_type = "effect"
on_violation = '''N/A - direct assignment always succeeds'''
reviewed = true

[[axioms]]
id = "return_with_effect_stores_return_value_3c7d8fa1"
content = '''Moves val into member variable 'return_value', transferring ownership'''
formal_spec = '''post(return_value == move(val))'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "return_with"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/ctrl.hpp"
signature = '''void return_with(R val)'''
axiom_type = "effect"
on_violation = '''N/A - move assignment always succeeds for move-assignable types'''
reviewed = true

[[axioms]]
id = "return_with_postcondition_val_moved_from_8e5f3bc2"
content = '''After execution, val is in a valid but unspecified moved-from state'''
formal_spec = '''post(valid_but_unspecified(val))'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "return_with"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/ctrl.hpp"
signature = '''void return_with(R val)'''
axiom_type = "postcondition"
on_violation = '''N/A - postcondition guarantee'''
depends_on = ['return_with_postcondition_val_moved_from_4f2a9b67']
reviewed = true

[[axioms]]
id = "return_with_postcondition_state_transition_2d1f7e93"
content = '''After execution, object state is: ok=false and return_value holds the moved value'''
formal_spec = '''post(ok == false && return_value == move(val))'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "return_with"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/ctrl.hpp"
signature = '''void return_with(R val)'''
axiom_type = "postcondition"
on_violation = '''N/A - postcondition guarantee'''
reviewed = true

[[axioms]]
id = "return_with_exception_noexcept_if_r_noexcept_6f8a3de4"
content = '''Function is noexcept if R's move constructor/assignment is noexcept; otherwise may throw if R's move operations throw'''
formal_spec = '''noexcept_spec = noexcept(is_nothrow_move_assignable<R>)'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "return_with"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/ctrl.hpp"
signature = '''void return_with(R val)'''
axiom_type = "exception"
on_violation = '''Exception propagates from R's move assignment operator'''
depends_on = ['cpp20_expr_type_composite_ptr_noexcept_func_m9h2k5i8', 'cpp20_basic_life_vacuous_initialization_def_7c4e5d6a', 'cpp20_special_same_kind_copy_move_ctor_d5e3a9b2', 'ilp_end_with_return_error_exception_no_throw_g2h5j8k1', 'cpp20_dcl_init_list_copy_list_init_explicit_ctor_f2a3b4c5', 'cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8']
reviewed = true

[[axioms]]
id = "return_with_complexity_constant_time_1a9e4bc7"
content = '''Time complexity is O(1) plus the cost of R's move assignment operator'''
formal_spec = '''time_complexity = O(1) + move_assign_complexity<R>'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "return_with"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/ctrl.hpp"
signature = '''void return_with(R val)'''
axiom_type = "complexity"
on_violation = '''N/A - complexity guarantee'''
depends_on = ['cpp20_container_node_move_assign_precondition_d6e7f8a9', 'c11_cpp_translation_name_syntax_operation_018c4422', 'cpp20_over_match_oper_fallback_builtin_comma_addr_arrow_b3c4d5e6', 'cpp20_over_match_oper_no_class_enum_builtin_f1a2b3c4']
reviewed = true

[[axioms]]
id = "return_with_anti_pattern_no_reuse_after_call_5c2e8d91"
content = '''Do not use val after calling this function, as it has been moved from'''
formal_spec = '''forall use_after: use_after(val) => undefined_behavior'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "return_with"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/ctrl.hpp"
signature = '''void return_with(R val)'''
axiom_type = "anti_pattern"
on_violation = '''Using moved-from object leads to unspecified behavior'''
depends_on = ['return_with_postcondition_val_moved_from_4f2a9b67']
reviewed = true

[[axioms]]
id = "ilp_ctrl_set_constraint_size_sizeof_a1b2c3d4"
content = '''The size of the decayed type U must not exceed arch::sbo_size bytes'''
formal_spec = '''sizeof(std::decay_t<T>) <= arch::sbo_size'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "set"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/ctrl.hpp"
signature = '''ILP_ALWAYS_INLINE void set(T&& val)'''
axiom_type = "constraint"
on_violation = '''Compile-time error: static assertion failure with message 'Return type exceeds SBO size. Use ILP_FOR_T(type, ...) instead.''''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "ilp_ctrl_set_constraint_align_alignof_e5f6g7h8"
content = '''The alignment requirement of the decayed type U must not exceed arch::sbo_size bytes'''
formal_spec = '''alignof(std::decay_t<T>) <= arch::sbo_size'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "set"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/ctrl.hpp"
signature = '''ILP_ALWAYS_INLINE void set(T&& val)'''
axiom_type = "constraint"
on_violation = '''Compile-time error: static assertion failure with message 'Return type alignment exceeds SBO size. Use ILP_FOR_T(type, ...) instead.''''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "ilp_ctrl_set_constraint_trivial_dtor_i9j0k1l2"
content = '''The decayed type U must be trivially destructible'''
formal_spec = '''std::is_trivially_destructible_v<std::decay_t<T>> == true'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "set"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/ctrl.hpp"
signature = '''ILP_ALWAYS_INLINE void set(T&& val)'''
axiom_type = "constraint"
on_violation = '''Compile-time error: static assertion failure with message 'SmallStorage only supports trivially-destructible types. Use ILP_FOR_T(type, ...) for non-trivial return types.''''
depends_on = ['cpp20_expr_prim_id_dtor_double_destroy_ub_c9d3e5f6', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_class_dtor_member_destruction_order_a7e4c9d2', 'cpp20_class_dtor_defaulted_constexpr_b3e7f2c4', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "ilp_ctrl_set_precondition_buffer_valid_m3n4o5p6"
content = '''The buffer member must point to valid, uninitialized storage with sufficient size and alignment for type U'''
formal_spec = '''is_valid_storage(buffer) && storage_size(buffer) >= sizeof(std::decay_t<T>) && storage_alignment(buffer) >= alignof(std::decay_t<T>) && !is_initialized(buffer)'''
layer = "library"
confidence = 0.85
source_file = ""
source_module = ""
function = "set"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/ctrl.hpp"
signature = '''ILP_ALWAYS_INLINE void set(T&& val)'''
axiom_type = "precondition"
on_violation = '''Undefined behavior: placement new on invalid or already-initialized storage'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "ilp_ctrl_set_effect_placement_new_q7r8s9t0"
content = '''Constructs an object of type U in the pre-allocated buffer storage using placement new, forwarding val with its original value category'''
formal_spec = '''new (buffer) std::decay_t<T>(static_cast<T&&>(val)) => constructs_in_place(buffer, std::decay_t<T>) && forwards_value_category(val)'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "set"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/ctrl.hpp"
signature = '''ILP_ALWAYS_INLINE void set(T&& val)'''
axiom_type = "effect"
on_violation = '''N/A - this is the primary effect'''
depends_on = ['cpp20_basic_life_vacuous_initialization_def_7c4e5d6a', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_list_copy_list_init_explicit_ctor_f2a3b4c5', 'cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "ilp_ctrl_set_postcondition_object_constructed_u1v2w3x4"
content = '''After successful execution, buffer contains a fully constructed object of type U initialized from val'''
formal_spec = '''is_initialized(buffer) && type_of(*buffer) == std::decay_t<T> && value_initialized_from(*buffer, val)'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "set"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/ctrl.hpp"
signature = '''ILP_ALWAYS_INLINE void set(T&& val)'''
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed by successful placement new'''
depends_on = ['cpp20_basic_life_vacuous_initialization_def_7c4e5d6a', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_list_copy_list_init_explicit_ctor_f2a3b4c5', 'cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8', 'cpp20_dcl_init_list_no_applicable_rule_a4b5c6d7', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "ilp_ctrl_set_anti_pattern_double_set_y5z6a7b8"
content = '''Calling set() multiple times without destroying the previously constructed object leads to undefined behavior (object lifetime violation)'''
formal_spec = '''is_initialized(buffer) && set(val) => undefined_behavior'''
layer = "library"
confidence = 0.85
source_file = ""
source_module = ""
function = "set"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/ctrl.hpp"
signature = '''ILP_ALWAYS_INLINE void set(T&& val)'''
axiom_type = "anti_pattern"
on_violation = '''Undefined behavior: constructing over an already-live object without destroying it first'''
depends_on = ['cpp20_basic_life_vacuous_initialization_def_7c4e5d6a', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_list_copy_list_init_explicit_ctor_f2a3b4c5', 'cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "ilp_ctrl_set_exception_constructor_throw_c9d0e1f2"
content = '''If the constructor of U throws an exception during placement new, the exception propagates and buffer remains uninitialized'''
formal_spec = '''new (buffer) std::decay_t<T>(static_cast<T&&>(val)) && throws(std::decay_t<T>::constructor) => propagates_exception && !is_initialized(buffer)'''
layer = "library"
confidence = 0.8
source_file = ""
source_module = ""
function = "set"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/ctrl.hpp"
signature = '''ILP_ALWAYS_INLINE void set(T&& val)'''
axiom_type = "exception"
on_violation = '''Exception propagates to caller; buffer state unchanged'''
depends_on = ['cpp20_basic_life_vacuous_initialization_def_7c4e5d6a', 'cpp20_except_throw_destruction_ordering_d5e1c7b9', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_except_throw_destruction_after_handler_exit_c4a9f2e6', 'cpp20_except_throw_uncaught_after_init_before_activation_1c8e5a4b', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_list_copy_list_init_explicit_ctor_f2a3b4c5', 'cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "ilp_ctrl_set_effect_perfect_forward_g3h4i5j6"
content = '''The static_cast<T&&>(val) performs perfect forwarding: if T is an lvalue reference, val is forwarded as lvalue; otherwise as rvalue'''
formal_spec = '''static_cast<T&&>(val) => (is_lvalue_reference<T> ? forwards_as_lvalue(val) : forwards_as_rvalue(val))'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "set"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/ctrl.hpp"
signature = '''ILP_ALWAYS_INLINE void set(T&& val)'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by C++ forwarding reference semantics'''
depends_on = ['ctrl_r_conversion_operator_anti_pattern_use_after_move_a9d4f7e2', 'extract_constraint_type_r_moveable_f6c8d2e4', 'ctrl_r_conversion_operator_effect_move_semantics_143', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_expr_cast_lvalue_result_d4e8a1c3', 'cpp20_dcl_init_ref_conversion_func_requires_ref_return_4g5h6i7j', 'cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_standard_conv_suppressed_8k9l0m1n', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_basic_lval_temp_materialization_b4e9f1c5']
reviewed = true

[[axioms]]
id = "ilp_ctrl_set_complexity_constant_k7l8m9n0"
content = '''Time complexity is O(1) plus the cost of U's move/copy constructor; space complexity is O(1) as storage is pre-allocated'''
formal_spec = '''time_complexity(set) = O(1) + cost(std::decay_t<T>::constructor) && space_complexity(set) = O(1)'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "set"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/ctrl.hpp"
signature = '''ILP_ALWAYS_INLINE void set(T&& val)'''
axiom_type = "complexity"
on_violation = '''N/A - this is a performance guarantee'''
depends_on = ['cpp20_basic_life_vacuous_initialization_def_7c4e5d6a', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_list_copy_list_init_explicit_ctor_f2a3b4c5', 'cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "set_constraint_sizeof_sbo_size_a1b2c3d4"
content = '''The decayed type U must have size less than or equal to arch::sbo_size for placement new in buffer to be valid'''
formal_spec = '''sizeof(U) <= arch::sbo_size where U = std::decay_t<T>'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "set"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/ctrl.hpp"
signature = '''ILP_ALWAYS_INLINE void set(T&& val)'''
axiom_type = "constraint"
on_violation = '''static_assert fails at compile time with 'Return type exceeds SBO size''''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "set_constraint_alignof_sbo_size_e5f6g7h8"
content = '''The decayed type U must have alignment less than or equal to arch::sbo_size for proper memory alignment in buffer'''
formal_spec = '''alignof(U) <= arch::sbo_size where U = std::decay_t<T>'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "set"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/ctrl.hpp"
signature = '''ILP_ALWAYS_INLINE void set(T&& val)'''
axiom_type = "constraint"
on_violation = '''static_assert fails at compile time with 'Return type alignment exceeds SBO size''''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "set_constraint_trivially_destructible_i9j0k1l2"
content = '''The decayed type U must be trivially destructible since SmallStorage does not call destructors explicitly'''
formal_spec = '''std::is_trivially_destructible_v<U> == true where U = std::decay_t<T>'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "set"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/ctrl.hpp"
signature = '''ILP_ALWAYS_INLINE void set(T&& val)'''
axiom_type = "constraint"
on_violation = '''static_assert fails at compile time with 'SmallStorage only supports trivially-destructible types''''
depends_on = ['cpp20_expr_prim_id_dtor_double_destroy_ub_c9d3e5f6', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_class_dtor_member_destruction_order_a7e4c9d2', 'cpp20_class_dtor_defaulted_constexpr_b3e7f2c4', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "set_precondition_buffer_valid_m3n4o5p6"
content = '''The buffer member must be properly aligned and have sufficient storage for placement new of type U'''
formal_spec = '''buffer != nullptr && is_aligned(buffer, alignof(U)) && available_space(buffer) >= sizeof(U)'''
layer = "library"
confidence = 0.85
source_file = ""
source_module = ""
function = "set"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/ctrl.hpp"
signature = '''ILP_ALWAYS_INLINE void set(T&& val)'''
axiom_type = "precondition"
on_violation = '''undefined behavior: misaligned access or buffer overflow'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "set_effect_placement_new_q7r8s9t0"
content = '''Constructs an object of type U in the pre-allocated buffer using placement new with perfect forwarding of val'''
formal_spec = '''new (buffer) U(static_cast<T&&>(val)) => constructs_object_at(buffer, U) && forwards_value(val)'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "set"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/ctrl.hpp"
signature = '''ILP_ALWAYS_INLINE void set(T&& val)'''
axiom_type = "effect"
on_violation = '''N/A - effect axiom'''
depends_on = ['cpp20_basic_life_vacuous_initialization_def_7c4e5d6a', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_list_copy_list_init_explicit_ctor_f2a3b4c5', 'cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "set_effect_perfect_forwarding_u1v2w3x4"
content = '''The static_cast<T&&>(val) performs perfect forwarding, preserving the value category of the original argument for move or copy construction'''
formal_spec = '''static_cast<T&&>(val) => (is_lvalue_reference_v<T> ? forward_as_lvalue(val) : forward_as_rvalue(val)) && preserves_value_category(val)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "set"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/ctrl.hpp"
signature = '''ILP_ALWAYS_INLINE void set(T&& val)'''
axiom_type = "effect"
on_violation = '''N/A - effect axiom'''
depends_on = ['cpp20_basic_life_vacuous_initialization_def_7c4e5d6a', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_list_copy_list_init_explicit_ctor_f2a3b4c5', 'cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "set_postcondition_object_constructed_y5z6a7b8"
content = '''After successful execution, buffer contains a fully constructed object of type U initialized from val'''
formal_spec = '''returns_normally => object_constructed(buffer, U) && initialized_from(buffer, val) && object_lifetime_started(buffer)'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "set"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/ctrl.hpp"
signature = '''ILP_ALWAYS_INLINE void set(T&& val)'''
axiom_type = "postcondition"
on_violation = '''N/A - postcondition axiom'''
depends_on = ['cpp20_basic_life_vacuous_initialization_def_7c4e5d6a', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_list_copy_list_init_explicit_ctor_f2a3b4c5', 'cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8', 'cpp20_dcl_init_list_no_applicable_rule_a4b5c6d7', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "set_anti_pattern_no_dtor_call_c9d0e1f2"
content = '''Do not call set() multiple times without manually destroying the previous object, as SmallStorage does not track object lifetime for non-trivial types'''
formal_spec = '''call_count(set) > 1 && !manually_destroyed(previous_object) => potential_memory_leak || undefined_behavior'''
layer = "library"
confidence = 0.8
source_file = ""
source_module = ""
function = "set"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/ctrl.hpp"
signature = '''ILP_ALWAYS_INLINE void set(T&& val)'''
axiom_type = "anti_pattern"
on_violation = '''undefined behavior: object lifetime violation, potential resource leak'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "set_anti_pattern_buffer_reuse_g3h4i5j6"
content = '''Do not reuse buffer storage without ensuring the previous object's lifetime has ended, even for trivially destructible types'''
formal_spec = '''placement_new(buffer) && previous_object_alive(buffer) => undefined_behavior'''
layer = "library"
confidence = 0.75
source_file = ""
source_module = ""
function = "set"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/ctrl.hpp"
signature = '''ILP_ALWAYS_INLINE void set(T&& val)'''
axiom_type = "anti_pattern"
on_violation = '''undefined behavior: overlapping object lifetimes in same storage'''
depends_on = ['cpp20_expr_prim_id_dtor_double_destroy_ub_c9d3e5f6', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_class_dtor_member_destruction_order_a7e4c9d2', 'cpp20_class_dtor_defaulted_constexpr_b3e7f2c4', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "set_complexity_constant_time_k7l8m9n0"
content = '''The function executes in constant time O(1) as it performs a single placement new construction'''
formal_spec = '''time_complexity(set) = O(1) + time_complexity(U::constructor)'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "set"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/ctrl.hpp"
signature = '''ILP_ALWAYS_INLINE void set(T&& val)'''
axiom_type = "complexity"
on_violation = '''N/A - complexity axiom'''
depends_on = ['cpp20_basic_life_vacuous_initialization_def_7c4e5d6a', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_list_copy_list_init_explicit_ctor_f2a3b4c5', 'cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "extract_precond_buffer_valid_storage_a8f3d2e1"
content = '''buffer must point to storage that contains a valid object of type R or cv-qualified variant before extraction'''
formal_spec = '''points_to_object_storage(buffer, R) && exists_object_at(reinterpret_cast<R*>(buffer))'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "extract"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/ctrl.hpp"
signature = '''ILP_ALWAYS_INLINE R extract()'''
axiom_type = "precondition"
on_violation = '''undefined behavior: dereferencing invalid pointer, std::launder requirements violated'''
depends_on = ['extract_launder_valid_storage_precond_b3c4d5e6', 'extract_precond_launder_transparency_d5e9f3a7', 'cpp20_basic_life_launder_required_6c7d8e9f']
reviewed = true

[[axioms]]
id = "extract_precond_buffer_alignment_a9b4c3d2"
content = '''buffer must be properly aligned for type R when reinterpret_cast is performed'''
formal_spec = '''is_aligned(buffer, alignof(R)) && valid_pointer_cast<R*>(buffer)'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "extract"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/ctrl.hpp"
signature = '''ILP_ALWAYS_INLINE R extract()'''
axiom_type = "precondition"
on_violation = '''undefined behavior: misaligned pointer access, potential hardware fault'''
depends_on = ['extract_buffer_alignment_precond_c9d0e1f2', 'extract_precond_reinterpret_valid_c4d8e2f9']
reviewed = true

[[axioms]]
id = "extract_precond_buffer_non_null_b7c8d9e0"
content = '''buffer must not be a null pointer when dereferenced through std::launder'''
formal_spec = '''reinterpret_cast<R*>(buffer) != nullptr && points_to_object(reinterpret_cast<R*>(buffer))'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "extract"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/ctrl.hpp"
signature = '''ILP_ALWAYS_INLINE R extract()'''
axiom_type = "precondition"
on_violation = '''undefined behavior: null pointer dereference'''
depends_on = ['c11_c_memory_reading_syntax_operation_bc1cd5d9', 'c11_cpp_expr_additive_operation_98819262', 'c11_cpp_translation_expr_new_operation_56ec7af1']
reviewed = true

[[axioms]]
id = "extract_precond_object_lifetime_started_c6d7e8f9"
content = '''The object of type R at buffer location must have its lifetime started before extraction'''
formal_spec = '''lifetime_started(object_at(reinterpret_cast<R*>(buffer))) && !lifetime_ended(object_at(reinterpret_cast<R*>(buffer)))'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "extract"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/ctrl.hpp"
signature = '''ILP_ALWAYS_INLINE R extract()'''
axiom_type = "precondition"
on_violation = '''undefined behavior or limited use: accessing object outside its lifetime'''
depends_on = ['cpp20_basic_life_runtime_property_1a2b3c4d', 'cpp20_basic_life_ptr_auto_refers_new_obj_8c9d0e1f', 'cpp20_basic_life_indirection_limited_use_7f8a9b0c', 'cpp20_basic_life_ptr_void_star_well_defined_3b4c5d6e']
reviewed = true

[[axioms]]
id = "extract_effect_perfect_forward_rvalue_d5e6f7a8"
content = '''Returns the object at buffer as an rvalue reference R&&, performing perfect forwarding that preserves value category'''
formal_spec = '''return_value = static_cast<R&&>(*std::launder(reinterpret_cast<R*>(buffer))) && preserves_value_category(*std::launder(reinterpret_cast<R*>(buffer))) && rvalue_forward(*std::launder(reinterpret_cast<R*>(buffer)))'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "extract"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/ctrl.hpp"
signature = '''ILP_ALWAYS_INLINE R extract()'''
axiom_type = "effect"
on_violation = '''N/A - this is the defined behavior'''
depends_on = ['ctrl_r_conversion_operator_anti_pattern_use_after_move_a9d4f7e2', 'extract_constraint_type_r_moveable_f6c8d2e4', 'ctrl_r_conversion_operator_effect_move_semantics_143', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "extract_effect_launder_pointer_optimization_e4f5a6b7"
content = '''std::launder provides pointer optimization transparency, ensuring the returned pointer refers to the actual object at the storage location even after transparent replacement'''
formal_spec = '''std_launder(reinterpret_cast<R*>(buffer)) => points_to(result, object_at(buffer)) && bypasses_optimizer_assumptions(result)'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "extract"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/ctrl.hpp"
signature = '''ILP_ALWAYS_INLINE R extract()'''
axiom_type = "effect"
on_violation = '''N/A - this is the defined behavior'''
depends_on = ['c11_c_memory_reading_syntax_operation_bc1cd5d9', 'c11_cpp_expr_additive_operation_98819262', 'c11_cpp_translation_expr_new_operation_56ec7af1']
reviewed = true

[[axioms]]
id = "extract_postcond_returns_rvalue_ref_f3a4b5c6"
content = '''Returns an rvalue reference to the object of type R stored in buffer, enabling move semantics'''
formal_spec = '''is_rvalue_reference(return_type) && typeof(return_value) == R&& && refers_to(return_value, object_at(buffer))'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "extract"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/ctrl.hpp"
signature = '''ILP_ALWAYS_INLINE R extract()'''
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed by static_cast<R&&>'''
depends_on = ['ctrl_r_conversion_operator_anti_pattern_use_after_move_a9d4f7e2', 'extract_constraint_type_r_moveable_f6c8d2e4', 'ctrl_r_conversion_operator_effect_move_semantics_143', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "extract_constraint_type_r_must_match_buffer_g2b3c4d5"
content = '''Template parameter R must match the actual type of the object stored in buffer (or a cv-qualified variant) to avoid type punning undefined behavior'''
formal_spec = '''typeof(object_at(buffer)) == R || typeof(object_at(buffer)) == cv_qualified_variant(R)'''
layer = "library"
confidence = 0.85
source_file = ""
source_module = ""
function = "extract"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/ctrl.hpp"
signature = '''ILP_ALWAYS_INLINE R extract()'''
axiom_type = "constraint"
on_violation = '''undefined behavior: type punning violation, strict aliasing violation'''
depends_on = ['for_loop_typed_constraint_return_type_r_b1c2d3e4', 'cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2', 'cpp20_temp_expl_spec_unspecialized_enclosing_template_param_a7b8c9d0', 'for_loop_range_typed_precond_n_valid_offset_b3c4d5e6']
reviewed = true

[[axioms]]
id = "extract_anti_pattern_double_extract_h1c2d3e4"
content = '''Do not call extract() multiple times on the same buffer without reconstructing the object, as the first call may move/destroy the object'''
formal_spec = '''extract_called(buffer) && !object_reconstructed(buffer) => !extract_callable(buffer)'''
layer = "library"
confidence = 0.8
source_file = ""
source_module = ""
function = "extract"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/ctrl.hpp"
signature = '''ILP_ALWAYS_INLINE R extract()'''
axiom_type = "anti_pattern"
on_violation = '''undefined behavior: accessing moved-from or destroyed object'''
depends_on = ['cpp20_basic_life_indirection_limited_use_7f8a9b0c']
reviewed = true

[[axioms]]
id = "extract_complexity_constant_time_i0d1e2f3"
content = '''extract() operates in O(1) constant time - performs only pointer operations and casts without iteration'''
formal_spec = '''time_complexity(extract) == O(1) && space_complexity(extract) == O(1)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "extract"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/ctrl.hpp"
signature = '''ILP_ALWAYS_INLINE R extract()'''
axiom_type = "complexity"
on_violation = '''N/A - performance guarantee'''
depends_on = ['c11_c_memory_reading_syntax_operation_bc1cd5d9', 'c11_cpp_expr_additive_operation_98819262', 'c11_cpp_translation_expr_new_operation_56ec7af1']
reviewed = true

[[axioms]]
id = "extract_precond_buffer_not_deallocated_j9e8f7a6"
content = '''The storage pointed to by buffer must not have been deallocated or released before extraction'''
formal_spec = '''!storage_reused_or_released(buffer) && storage_allocated(buffer)'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "extract"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/ctrl.hpp"
signature = '''ILP_ALWAYS_INLINE R extract()'''
axiom_type = "precondition"
on_violation = '''undefined behavior: use after free, dangling pointer dereference'''
depends_on = ['cpp20_basic_life_ptr_auto_refers_new_obj_8c9d0e1f', 'cpp20_basic_life_ptr_void_star_well_defined_3b4c5d6e']
reviewed = true

[[axioms]]
id = "extract_precond_buffer_valid_storage_f4a7b2c9"
content = '''buffer must point to storage containing a valid object of type R before extract() is called'''
formal_spec = '''points_to_object_storage(buffer, R) && exists_object_at(reinterpret_cast<R*>(buffer))'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "extract"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/ctrl.hpp"
signature = '''ILP_ALWAYS_INLINE R extract()'''
axiom_type = "precondition"
on_violation = '''undefined behavior: std::launder and pointer dereference operate on invalid storage'''
depends_on = ['extract_precond_launder_transparency_d5e9f3a7', 'extract_launder_valid_storage_precond_b3c4d5e6', 'cpp20_basic_life_launder_required_6c7d8e9f']
reviewed = true

[[axioms]]
id = "extract_precond_buffer_alignment_e3d9a1f5"
content = '''buffer must be properly aligned for type R to satisfy reinterpret_cast requirements'''
formal_spec = '''is_aligned(buffer, alignof(R)) && valid_pointer_cast<R*>(buffer)'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "extract"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/ctrl.hpp"
signature = '''ILP_ALWAYS_INLINE R extract()'''
axiom_type = "precondition"
on_violation = '''undefined behavior: misaligned pointer access'''
depends_on = ['extract_buffer_alignment_precond_c9d0e1f2', 'extract_precond_reinterpret_valid_c4d8e2f9']
reviewed = true

[[axioms]]
id = "extract_precond_object_lifetime_started_b8c2d4e6"
content = '''The object of type R at buffer location must have its lifetime already started before dereferencing'''
formal_spec = '''lifetime_started(object_at(reinterpret_cast<R*>(buffer))) && !lifetime_ended(object_at(reinterpret_cast<R*>(buffer)))'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "extract"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/ctrl.hpp"
signature = '''ILP_ALWAYS_INLINE R extract()'''
axiom_type = "precondition"
on_violation = '''undefined behavior: dereferencing pointer to object outside its lifetime'''
depends_on = ['cpp20_basic_life_runtime_property_1a2b3c4d', 'cpp20_basic_life_indirection_limited_use_7f8a9b0c', 'cpp20_expr_unary_op_indirection_ub_a7c3f2d1']
reviewed = true

[[axioms]]
id = "extract_precond_pointer_non_null_a5f7c3d1"
content = '''buffer must not be null when reinterpret_cast and dereferenced through std::launder'''
formal_spec = '''buffer != nullptr && reinterpret_cast<R*>(buffer) != nullptr'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "extract"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/ctrl.hpp"
signature = '''ILP_ALWAYS_INLINE R extract()'''
axiom_type = "precondition"
on_violation = '''undefined behavior: dereferencing null pointer'''
depends_on = ['cpp20_expr_unary_op_indirection_ub_a7c3f2d1', 'c11_c_conversion_syntax_operation_0d439ded']
reviewed = true

[[axioms]]
id = "extract_effect_launder_bypass_optimization_d2e8f4a6"
content = '''std::launder obtains a pointer to the object at buffer storage, bypassing compiler optimizations that assume no object exists there'''
formal_spec = '''std_launder(reinterpret_cast<R*>(buffer)) => points_to(result, object_at(buffer)) && optimization_barrier_applied(result)'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "extract"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/ctrl.hpp"
signature = '''ILP_ALWAYS_INLINE R extract()'''
axiom_type = "effect"
on_violation = '''n/a'''
depends_on = ['c11_c_memory_reading_syntax_operation_bc1cd5d9', 'c11_cpp_expr_additive_operation_98819262', 'c11_cpp_translation_expr_new_operation_56ec7af1']
reviewed = true

[[axioms]]
id = "extract_effect_perfect_forward_rvalue_c7b4d9e2"
content = '''static_cast<R&&> performs perfect forwarding to preserve the value category as an rvalue reference, enabling move semantics'''
formal_spec = '''static_cast<R&&>(*std::launder(reinterpret_cast<R*>(buffer))) => preserves_value_category(*std::launder(reinterpret_cast<R*>(buffer))) && rvalue_forward(*std::launder(reinterpret_cast<R*>(buffer)))'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "extract"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/ctrl.hpp"
signature = '''ILP_ALWAYS_INLINE R extract()'''
axiom_type = "effect"
on_violation = '''n/a'''
depends_on = ['ctrl_r_conversion_operator_anti_pattern_use_after_move_a9d4f7e2', 'extract_constraint_type_r_moveable_f6c8d2e4', 'ctrl_r_conversion_operator_effect_move_semantics_143', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "extract_postcond_returns_rvalue_ref_e9a3f5b7"
content = '''Returns an rvalue reference to the object of type R stored in buffer, enabling move operations'''
formal_spec = '''return_value == static_cast<R&&>(*std::launder(reinterpret_cast<R*>(buffer))) && is_rvalue_reference<R&&>(return_value)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "extract"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/ctrl.hpp"
signature = '''ILP_ALWAYS_INLINE R extract()'''
axiom_type = "postcondition"
on_violation = '''n/a'''
depends_on = ['ctrl_r_conversion_operator_anti_pattern_use_after_move_a9d4f7e2', 'extract_constraint_type_r_moveable_f6c8d2e4', 'ctrl_r_conversion_operator_effect_move_semantics_143', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "extract_constraint_type_r_moveable_f6c8d2e4"
content = '''Type R must be move-constructible or move-assignable for the rvalue reference return to be useful'''
formal_spec = '''is_move_constructible<R> || is_move_assignable<R>'''
layer = "library"
confidence = 0.8
source_file = ""
source_module = ""
function = "extract"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/ctrl.hpp"
signature = '''ILP_ALWAYS_INLINE R extract()'''
axiom_type = "constraint"
on_violation = '''compilation error or limited utility of returned rvalue reference'''
depends_on = ['ctrl_r_conversion_operator_anti_pattern_use_after_move_a9d4f7e2', 'cpp20_basic_life_vacuous_initialization_def_7c4e5d6a', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_list_copy_list_init_explicit_ctor_f2a3b4c5', 'ctrl_r_conversion_operator_anti_pattern_use_after_move_143', 'cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8', 'ctrl_r_conversion_operator_precondition_rvalue_143', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "extract_anti_pattern_double_extraction_a4d7b9c3"
content = '''Do not call extract() multiple times on the same buffer without reconstructing the object, as the first call may move from the object leaving it in a valid but unspecified state'''
formal_spec = '''extract_called(buffer) && object_moved_from(object_at(buffer)) => extract(buffer) yields unspecified_state'''
layer = "library"
confidence = 0.85
source_file = ""
source_module = ""
function = "extract"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/ctrl.hpp"
signature = '''ILP_ALWAYS_INLINE R extract()'''
axiom_type = "anti_pattern"
on_violation = '''well-defined but object state is unspecified after move'''
depends_on = ['cpp20_basic_life_indirection_limited_use_7f8a9b0c', 'ilp_ctrl_set_effect_perfect_forwarding_a5b6c7d8']
reviewed = true

[[axioms]]
id = "extract_complexity_constant_time_b5e2f8a9"
content = '''O(1) time and space complexity - performs only pointer casts and dereference operations'''
formal_spec = '''time_complexity(extract) == O(1) && space_complexity(extract) == O(1)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "extract"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/ctrl.hpp"
signature = '''ILP_ALWAYS_INLINE R extract()'''
axiom_type = "complexity"
on_violation = '''n/a'''
depends_on = ['c11_c_memory_reading_syntax_operation_bc1cd5d9', 'c11_cpp_expr_additive_operation_98819262', 'c11_cpp_translation_expr_new_operation_56ec7af1']
reviewed = true

[[axioms]]
id = "extract_effect_reinterpret_cast_type_punning_d8b3e5c7"
content = '''reinterpret_cast<R*>(buffer) reinterprets the buffer bytes as a pointer to type R without type conversion, providing type punning mechanism'''
formal_spec = '''reinterpret_cast<R*>(buffer) => reinterpret_bytes_as<R*>(buffer) && no_value_conversion(buffer)'''
layer = "library"
confidence = 0.85
source_file = ""
source_module = ""
function = "extract"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/ctrl.hpp"
signature = '''ILP_ALWAYS_INLINE R extract()'''
axiom_type = "effect"
on_violation = '''n/a'''
depends_on = ['cpp20_over_match_funcs_general_one_user_conversion_b3c5d7e9', 'c11_c_common_expr_bitwise_bitwise_fcfa6dec', 'c11_c_memory_reading_syntax_operation_bc1cd5d9', 'c11_cpp_expr_additive_operation_98819262', 'c11_cpp_translation_expr_new_operation_56ec7af1', 'c11_cpp_conversion_syntax_convertType_7e132831']
reviewed = true

[[axioms]]
id = "extract_precond_buffer_not_const_e7a9c4d2"
content = '''If R is non-const, buffer must point to non-const storage to avoid const-correctness violation'''
formal_spec = '''!is_const<R> => !is_const_storage(buffer)'''
layer = "library"
confidence = 0.8
source_file = ""
source_module = ""
function = "extract"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/ctrl.hpp"
signature = '''ILP_ALWAYS_INLINE R extract()'''
axiom_type = "precondition"
on_violation = '''undefined behavior: modifying const object through non-const reference'''
depends_on = ['cpp20_expr_cast_interpretation_order_f8b2c4d1']
reviewed = true

[[axioms]]
id = "ctrl_r_conversion_operator_precondition_extract_valid_c4f1a8e3"
content = '''Template parameter R must be a valid type for which s.extract<R>() is defined. The member object 's' must have a template method extract that can be instantiated with type R.'''
formal_spec = '''has_member_template(decltype(s), extract<R>) && is_valid_template_arg<R>(s.extract)'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "R"
header = "/home/m~endorff/Documents/Code/cpp/ilp_for/ilp_for/detail/ctrl.hpp"
signature = '''ILP_ALWAYS_INLINE operator R() &&'''
axiom_type = "precondition"
on_violation = '''Compilation error: no matching member function for call to 'extract''''
depends_on = ['cpp20_temp_expl_spec_unspecialized_enclosing_template_param_a7b8c9d0', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'for_loop_range_typed_precond_n_valid_offset_b3c4d5e6', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'for_loop_typed_constraint_return_type_r_b1c2d3e4']
reviewed = true

[[axioms]]
id = "ctrl_r_conversion_operator_precondition_rvalue_ref_b2e9f7d1"
content = '''This conversion operator requires the object to be an rvalue reference (&&). The object must be in a movable state and should not be used after this conversion.'''
formal_spec = '''is_rvalue_ref(this) && is_valid_object_state(s)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "R"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/ctrl.hpp"
signature = '''ILP_ALWAYS_INLINE operator R() &&'''
axiom_type = "precondition"
on_violation = '''Compilation error if called on lvalue; undefined behavior if object state is invalid'''
depends_on = ['cpp20_over_match_funcs_general_one_user_conversion_b3c5d7e9', 'c11_c_common_expr_bitwise_bitwise_fcfa6dec', 'ctrl_r_conversion_operator_anti_pattern_use_after_move_a9d4f7e2', 'extract_constraint_type_r_moveable_f6c8d2e4', 'ctrl_r_conversion_operator_effect_move_semantics_143', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_over_match_oper_no_class_enum_builtin_f1a2b3c4', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_over_match_oper_fallback_builtin_comma_addr_arrow_b3c4d5e6', 'c11_cpp_conversion_syntax_convertType_7e132831', 'c11_cpp_translation_name_syntax_operation_018c4422', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "ctrl_r_conversion_operator_precondition_extractable_data_8c3d4f92"
content = '''The member object 's' must contain data that can be extracted as type R. The extract operation must be semantically valid for the current state of 's'.'''
formal_spec = '''s.template can_extract<R>() && has_extractable_value<R>(s)'''
layer = "library"
confidence = 0.85
source_file = ""
source_module = ""
function = "R"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/ctrl.hpp"
signature = '''ILP_ALWAYS_INLINE operator R() &&'''
axiom_type = "precondition"
on_violation = '''Undefined behavior or exception depending on extract<R>() implementation'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "ctrl_r_conversion_operator_postcondition_returns_r_a1f8c2e7"
content = '''Returns an object of type R obtained by calling s.extract<R>(). The returned value is exactly the result of the extraction operation on 's'.'''
formal_spec = '''return_type(result) == R && result == s.template extract<R>()'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "R"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/ctrl.hpp"
signature = '''ILP_ALWAYS_INLINE operator R() &&'''
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed by type system'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "ctrl_r_conversion_operator_effect_move_semantics_d5a7b3c9"
content = '''Invokes s.template extract<R>() with move semantics (&&). After this operation, the object should be treated as moved-from and 's' may be in a valid but unspecified state.'''
formal_spec = '''invokes(s.template extract<R>()) && post_state(this) == moved_from'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "R"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/ctrl.hpp"
signature = '''ILP_ALWAYS_INLINE operator R() &&'''
axiom_type = "effect"
on_violation = '''N/A - behavioral specification'''
depends_on = ['cpp20_temp_expl_spec_unspecialized_enclosing_template_param_a7b8c9d0', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'for_loop_range_typed_precond_n_valid_offset_b3c4d5e6', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "ctrl_r_conversion_operator_constraint_type_convertible_e8f3a1d2"
content = '''Type R must be the exact type that s.extract<R>() returns or implicitly convertible to it. The conversion operator enables implicit conversion from the enclosing class to type R.'''
formal_spec = '''is_convertible<decltype(s.template extract<R>()), R>::value'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "R"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/ctrl.hpp"
signature = '''ILP_ALWAYS_INLINE operator R() &&'''
axiom_type = "constraint"
on_violation = '''Compilation error: cannot convert return type to R'''
depends_on = ['cpp20_over_match_funcs_general_one_user_conversion_b3c5d7e9', 'c11_c_common_expr_bitwise_bitwise_fcfa6dec', 'c11_c_conversion_syntax_operation_244d5a84', 'cpp20_class_dtor_trivial_conditions_a9d6e5b8', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_basic_life_end_without_destructor_9c0d1e2f', 'cpp20_over_match_oper_no_class_enum_builtin_f1a2b3c4', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_over_match_oper_fallback_builtin_comma_addr_arrow_b3c4d5e6', 'c11_cpp_conversion_syntax_convertType_7e132831', 'c11_cpp_translation_name_syntax_operation_018c4422', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_class_dtor_implicit_declaration_inline_public_d5f9a7b3']
reviewed = true

[[axioms]]
id = "ctrl_r_conversion_operator_exception_propagates_extract_f2c8e1a4"
content = '''Any exception thrown by s.extract<R>() will propagate to the caller. The conversion operator provides no exception handling, so exception safety depends entirely on extract<R>() implementation.'''
formal_spec = '''throws(this) ⟺ throws(s.template extract<R>())'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "R"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/ctrl.hpp"
signature = '''ILP_ALWAYS_INLINE operator R() &&'''
axiom_type = "exception"
on_violation = '''N/A - exception propagation behavior'''
depends_on = ['cpp20_over_match_funcs_general_one_user_conversion_b3c5d7e9', 'c11_c_common_expr_bitwise_bitwise_fcfa6dec', 'cpp20_except_throw_destruction_ordering_d5e1c7b9', 'cpp20_except_throw_destruction_after_handler_exit_c4a9f2e6', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_over_match_oper_no_class_enum_builtin_f1a2b3c4', 'cpp20_except_throw_uncaught_after_init_before_activation_1c8e5a4b', 'cpp20_expr_prim_this_context_restriction_a3b7c2d1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_over_match_oper_fallback_builtin_comma_addr_arrow_b3c4d5e6', 'c11_cpp_conversion_syntax_convertType_7e132831', 'c11_cpp_translation_name_syntax_operation_018c4422', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_expr_prim_this_static_member_forbidden_e4f8a1b2']
reviewed = true

[[axioms]]
id = "ctrl_r_conversion_operator_anti_pattern_use_after_move_a9d4f7e2"
content = '''Do not use the object after invoking this rvalue conversion operator. Since it requires && (rvalue reference), the object is moved-from after the conversion and further use may lead to undefined behavior.'''
formal_spec = '''∀ op: use_after(this, op) ⟹ undefined_behavior'''
layer = "library"
confidence = 0.85
source_file = ""
source_module = ""
function = "R"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/ctrl.hpp"
signature = '''ILP_ALWAYS_INLINE operator R() &&'''
axiom_type = "anti_pattern"
on_violation = '''Undefined behavior if object is accessed after move'''
depends_on = ['cpp20_over_match_funcs_general_one_user_conversion_b3c5d7e9', 'c11_c_common_expr_bitwise_bitwise_fcfa6dec', 'extract_constraint_type_r_moveable_f6c8d2e4', 'ctrl_r_conversion_operator_effect_move_semantics_143', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_over_match_oper_no_class_enum_builtin_f1a2b3c4', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_over_match_oper_fallback_builtin_comma_addr_arrow_b3c4d5e6', 'c11_cpp_conversion_syntax_convertType_7e132831', 'c11_cpp_translation_name_syntax_operation_018c4422', 'ctrl_r_conversion_operator_anti_pattern_use_after_move_143', 'ctrl_r_conversion_operator_precondition_rvalue_143']
reviewed = true

[[axioms]]
id = "ctrl_r_conversion_operator_complexity_constant_b7e2f9a1"
content = '''Time complexity is O(1) for the conversion operator itself, plus the complexity of s.extract<R>(). Space complexity is O(1) excluding the returned object.'''
formal_spec = '''time_complexity(this) = O(1) + time_complexity(s.template extract<R>()) && space_complexity(this) = O(1)'''
layer = "library"
confidence = 0.75
source_file = ""
source_module = ""
function = "R"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/ctrl.hpp"
signature = '''ILP_ALWAYS_INLINE operator R() &&'''
axiom_type = "complexity"
on_violation = '''N/A - performance specification'''
depends_on = ['cpp20_over_match_funcs_general_one_user_conversion_b3c5d7e9', 'c11_c_common_expr_bitwise_bitwise_fcfa6dec', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_over_match_oper_no_class_enum_builtin_f1a2b3c4', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_over_match_oper_fallback_builtin_comma_addr_arrow_b3c4d5e6', 'c11_cpp_conversion_syntax_convertType_7e132831', 'c11_cpp_translation_name_syntax_operation_018c4422', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "ctrl_r_conversion_operator_precondition_rvalue_143"
content = '''This conversion operator requires rvalue reference (&&) semantics - object must be an expiring value or moved-from state'''
formal_spec = '''is_rvalue_ref(this) && !is_lvalue_ref(this)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "R"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/ctrl.hpp"
signature = '''ILP_ALWAYS_INLINE operator R() &&'''
axiom_type = "precondition"
on_violation = '''compilation error - cannot bind lvalue to rvalue reference operator'''
depends_on = ['cpp20_over_match_funcs_general_one_user_conversion_b3c5d7e9', 'c11_c_common_expr_bitwise_bitwise_fcfa6dec', 'ctrl_r_conversion_operator_anti_pattern_use_after_move_a9d4f7e2', 'extract_constraint_type_r_moveable_f6c8d2e4', 'ctrl_r_conversion_operator_effect_move_semantics_143', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_over_match_oper_no_class_enum_builtin_f1a2b3c4', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_over_match_oper_fallback_builtin_comma_addr_arrow_b3c4d5e6', 'c11_cpp_conversion_syntax_convertType_7e132831', 'c11_cpp_translation_name_syntax_operation_018c4422', 'ctrl_r_conversion_operator_anti_pattern_use_after_move_143']
reviewed = true

[[axioms]]
id = "ctrl_r_conversion_operator_precondition_extract_valid_143"
content = '''Type R must be a valid template argument for the extract method and member s must support extraction to type R'''
formal_spec = '''has_member_template(decltype(s), extract<R>) && s.can_extract<R>()'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "R"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/ctrl.hpp"
signature = '''ILP_ALWAYS_INLINE operator R() &&'''
axiom_type = "precondition"
on_violation = '''compilation error if extract<R> is not available; runtime behavior depends on extract<R> implementation'''
depends_on = ['cpp20_temp_expl_spec_unspecialized_enclosing_template_param_a7b8c9d0', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'for_loop_range_typed_precond_n_valid_offset_b3c4d5e6', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "ctrl_r_conversion_operator_effect_move_semantics_143"
content = '''Invokes s.template extract<R>() which may consume/move resources from member s due to rvalue context'''
formal_spec = '''effect(call(s.extract<R>())) && may_invalidate(s)'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "R"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/ctrl.hpp"
signature = '''ILP_ALWAYS_INLINE operator R() &&'''
axiom_type = "effect"
on_violation = '''not applicable - describes behavior'''
depends_on = ['ctrl_r_conversion_operator_anti_pattern_use_after_move_a9d4f7e2', 'cpp20_temp_expl_spec_unspecialized_enclosing_template_param_a7b8c9d0', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'for_loop_range_typed_precond_n_valid_offset_b3c4d5e6', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2', 'ctrl_r_conversion_operator_anti_pattern_use_after_move_143', 'ctrl_r_conversion_operator_precondition_rvalue_143', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "ctrl_r_conversion_operator_postcondition_return_type_143"
content = '''Returns an object of type R obtained by calling s.template extract<R>(), where the returned value is the result of the extraction operation'''
formal_spec = '''return_type(result) == R && result == s.extract<R>()'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "R"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/ctrl.hpp"
signature = '''ILP_ALWAYS_INLINE operator R() &&'''
axiom_type = "postcondition"
on_violation = '''not applicable - guaranteed by type system and return statement'''
depends_on = ['cpp20_temp_expl_spec_unspecialized_enclosing_template_param_a7b8c9d0', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'for_loop_range_typed_precond_n_valid_offset_b3c4d5e6', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "ctrl_r_conversion_operator_constraint_type_r_143"
content = '''Template parameter R must be a complete type that is compatible with the extract<R>() method's return type'''
formal_spec = '''is_complete_type(R) && is_convertible(decltype(s.extract<R>()), R)'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "R"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/ctrl.hpp"
signature = '''ILP_ALWAYS_INLINE operator R() &&'''
axiom_type = "constraint"
on_violation = '''compilation error if R is incomplete or incompatible with extract<R> return type'''
depends_on = ['cpp20_temp_expl_spec_unspecialized_enclosing_template_param_a7b8c9d0', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'for_loop_range_typed_precond_n_valid_offset_b3c4d5e6', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'for_loop_typed_constraint_return_type_r_b1c2d3e4']
reviewed = true

[[axioms]]
id = "ctrl_r_conversion_operator_exception_extract_propagation_143"
content = '''Any exception thrown by s.template extract<R>() will propagate to the caller - no exception handling in conversion operator'''
formal_spec = '''throws(this) == throws(s.extract<R>())'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "R"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/ctrl.hpp"
signature = '''ILP_ALWAYS_INLINE operator R() &&'''
axiom_type = "exception"
on_violation = '''not applicable - describes exception transparency'''
depends_on = ['cpp20_over_match_funcs_general_one_user_conversion_b3c5d7e9', 'c11_c_common_expr_bitwise_bitwise_fcfa6dec', 'cpp20_except_throw_destruction_ordering_d5e1c7b9', 'cpp20_temp_expl_spec_unspecialized_enclosing_template_param_a7b8c9d0', 'cpp20_except_throw_destruction_after_handler_exit_c4a9f2e6', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_over_match_oper_no_class_enum_builtin_f1a2b3c4', 'for_loop_range_typed_precond_n_valid_offset_b3c4d5e6', 'cpp20_except_throw_uncaught_after_init_before_activation_1c8e5a4b', 'cpp20_expr_prim_this_context_restriction_a3b7c2d1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_over_match_oper_fallback_builtin_comma_addr_arrow_b3c4d5e6', 'c11_cpp_conversion_syntax_convertType_7e132831', 'c11_cpp_translation_name_syntax_operation_018c4422', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2', 'cpp20_expr_prim_this_static_member_forbidden_e4f8a1b2']
reviewed = true

[[axioms]]
id = "ctrl_r_conversion_operator_anti_pattern_use_after_move_143"
content = '''Do not use the object after invoking this rvalue conversion operator - member s may be in moved-from state'''
formal_spec = '''after(operator_R()) => is_moved_from(s) => undefined_behavior(use(s))'''
layer = "library"
confidence = 0.85
source_file = ""
source_module = ""
function = "R"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/ctrl.hpp"
signature = '''ILP_ALWAYS_INLINE operator R() &&'''
axiom_type = "anti_pattern"
on_violation = '''undefined behavior - accessing moved-from object'''
depends_on = ['cpp20_over_match_funcs_general_one_user_conversion_b3c5d7e9', 'c11_c_common_expr_bitwise_bitwise_fcfa6dec', 'ctrl_r_conversion_operator_anti_pattern_use_after_move_a9d4f7e2', 'ctrl_r_conversion_operator_effect_move_semantics_143', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_over_match_oper_no_class_enum_builtin_f1a2b3c4', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_over_match_oper_fallback_builtin_comma_addr_arrow_b3c4d5e6', 'c11_cpp_conversion_syntax_convertType_7e132831', 'c11_cpp_translation_name_syntax_operation_018c4422', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'ctrl_r_conversion_operator_precondition_rvalue_143']
reviewed = true

[[axioms]]
id = "ilp_end_with_return_error_effect_fprintf_stderr_a8c9d2f3"
content = '''Writes diagnostic error message to stderr stream about ILP_RETURN/ILP_END mismatch'''
formal_spec = '''effect: std::fprintf(stderr, error_message) => writes_to_stream(stderr) && message_contains('ILP_FOR ERROR') && message_contains('ILP_RETURN was called but ILP_END was used')'''
layer = "library"
confidence = 0.85
source_file = ""
source_module = ""
function = "ilp_end_with_return_error"
header = "ilp_for/detail/ctrl.hpp"
signature = '''[[noreturn]] inline void ilp_end_with_return_error()'''
axiom_type = "effect"
on_violation = '''I/O error if stderr is not writable, but typically succeeds'''
depends_on = ['c11_libc_stdio_comparison_88fbdc40']
reviewed = true

[[axioms]]
id = "ilp_end_with_return_error_precond_stderr_valid_b7e4f1a2"
content = '''stderr must be a valid writable FILE* stream'''
formal_spec = '''requires: stderr != nullptr && isWritable(stderr) && isValidStream(stderr)'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "ilp_end_with_return_error"
header = "ilp_for/detail/ctrl.hpp"
signature = '''[[noreturn]] inline void ilp_end_with_return_error()'''
axiom_type = "precondition"
on_violation = '''undefined behavior if stderr is invalid or not writable'''
depends_on = ['c11_libc_stdio_comparison_88fbdc40']
reviewed = true

[[axioms]]
id = "ilp_end_with_return_error_effect_abort_terminates_c3d8e5f6"
content = '''Causes abnormal program termination via std::abort() without cleanup'''
formal_spec = '''effect: std::abort() => abnormal_termination && !calls_destructors && !calls_atexit_handlers && !stack_unwinding'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ilp_end_with_return_error"
header = "ilp_for/detail/ctrl.hpp"
signature = '''[[noreturn]] inline void ilp_end_with_return_error()'''
axiom_type = "effect"
on_violation = '''guaranteed termination - no violation possible'''
depends_on = ['ilp_end_with_return_error_effect_no_cleanup_e5f7a9b1', 'c11_libc_stdlib_syntax_abort_55928485']
reviewed = true

[[axioms]]
id = "ilp_end_with_return_error_postcond_never_returns_d9f2a7b4"
content = '''Function never returns (marked [[noreturn]]) - program terminates'''
formal_spec = '''ensures: forall execution_path: terminates_abnormally(execution_path) && !returns(execution_path)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ilp_end_with_return_error"
header = "ilp_for/detail/ctrl.hpp"
signature = '''[[noreturn]] inline void ilp_end_with_return_error()'''
axiom_type = "postcondition"
on_violation = '''guaranteed by [[noreturn]] attribute and std::abort() call'''
depends_on = ['ilp_end_with_return_error_effect_no_cleanup_e5f7a9b1', 'c11_libc_stdlib_syntax_abort_55928485']
reviewed = true

[[axioms]]
id = "ilp_end_with_return_error_effect_diagnostic_purpose_e1a3c5b7"
content = '''Called when ILP_RETURN macro is used but ILP_END was used instead of ILP_END_RETURN, indicating programmer error in ILP_FOR framework usage'''
formal_spec = '''effect: called_when(ilp_return_used && ilp_end_used && !ilp_end_return_used) => reports_error && aborts_program'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "ilp_end_with_return_error"
header = "ilp_for/detail/ctrl.hpp"
signature = '''[[noreturn]] inline void ilp_end_with_return_error()'''
axiom_type = "effect"
on_violation = '''N/A - this function itself handles the violation'''
depends_on = ['ilp_for_auto_context_variable_k7l8m9n0', 'c11_libc_stdlib_syntax_abort_55928485']
reviewed = true

[[axioms]]
id = "ilp_end_with_return_error_anti_pattern_no_recovery_f8b6d4a9"
content = '''Do not call this function in contexts requiring cleanup or graceful shutdown - it terminates immediately without stack unwinding'''
formal_spec = '''anti_pattern: call_context_requires_cleanup => unsafe(ilp_end_with_return_error())'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "ilp_end_with_return_error"
header = "ilp_for/detail/ctrl.hpp"
signature = '''[[noreturn]] inline void ilp_end_with_return_error()'''
axiom_type = "anti_pattern"
on_violation = '''resource leaks, incomplete cleanup, no RAII destructor execution'''
depends_on = ['ilp_end_with_return_error_effect_no_cleanup_e5f7a9b1', 'c11_libc_stdlib_syntax_abort_55928485']
reviewed = true

[[axioms]]
id = "ilp_end_with_return_error_exception_no_throw_g2h5j8k1"
content = '''Function cannot throw exceptions - terminates via std::abort() which is noexcept'''
formal_spec = '''ensures: !can_throw_exception && terminates_via_abort'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ilp_end_with_return_error"
header = "ilp_for/detail/ctrl.hpp"
signature = '''[[noreturn]] inline void ilp_end_with_return_error()'''
axiom_type = "exception"
on_violation = '''N/A - guaranteed not to throw'''
depends_on = ['cpp20_expr_type_composite_ptr_noexcept_func_m9h2k5i8', 'return_with_exception_noexcept_if_r_noexcept_6f8a3de4']
reviewed = true

[[axioms]]
id = "ilp_end_with_return_error_complexity_constant_h3i6k9m2"
content = '''O(1) time and space complexity - performs one fprintf and one abort call'''
formal_spec = '''complexity: time = O(1) && space = O(1)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ilp_end_with_return_error"
header = "ilp_for/detail/ctrl.hpp"
signature = '''[[noreturn]] inline void ilp_end_with_return_error()'''
axiom_type = "complexity"
on_violation = '''N/A - complexity guarantee'''
depends_on = ['c11_libc_stdlib_syntax_abort_55928485']
reviewed = true

[[axioms]]
id = "validate_unroll_factor_constraint_N_minimum"
content = '''Template parameter N must be at least 1 (enforced via static_assert)'''
formal_spec = '''N >= 1'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "validate_unroll_factor"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_common.hpp"
signature = '''constexpr void validate_unroll_factor()'''
axiom_type = "constraint"
on_violation = '''compilation error: static_assert failure'''
depends_on = ['for_loop_typed_constraint_return_type_r_b1c2d3e4', 'cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2', 'cpp20_temp_expl_spec_unspecialized_enclosing_template_param_a7b8c9d0', 'for_loop_range_typed_precond_n_valid_offset_b3c4d5e6']
reviewed = true

[[axioms]]
id = "validate_unroll_factor_postcondition_N_validated"
content = '''After successful compilation, N is guaranteed to be >= 1; if N > 16, warning has been issued'''
formal_spec = '''N >= 1 && ((N > 16) => warn_large_unroll_factor<N>() invoked)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "validate_unroll_factor"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_common.hpp"
signature = '''constexpr void validate_unroll_factor()'''
axiom_type = "postcondition"
on_violation = '''N/A - enforced at compile-time'''
depends_on = ['validate_unroll_factor_postcondition_validation', 'cpp20_temp_inst_no_implicit_unless_required_b3c4d5e6']
reviewed = true

[[axioms]]
id = "validate_unroll_factor_effect_warn_on_large_N"
content = '''When N > 16, invokes warn_large_unroll_factor<N>() to issue a compile-time warning about large unroll factors'''
formal_spec = '''if constexpr (N > 16) then invoke(warn_large_unroll_factor<N>())'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "validate_unroll_factor"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_common.hpp"
signature = '''constexpr void validate_unroll_factor()'''
axiom_type = "effect"
on_violation = '''N/A - conditional effect'''
depends_on = ['cpp20_temp_inst_no_implicit_unless_required_b3c4d5e6', 'validate_unroll_factor_effect_warn_large_N']
reviewed = true

[[axioms]]
id = "validate_unroll_factor_anti_pattern_excessive_unroll"
content = '''Using N > 16 without careful consideration can cause code bloat and reduced performance due to excessive loop unrolling'''
formal_spec = '''caution_recommended: N > 16'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "validate_unroll_factor"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_common.hpp"
signature = '''constexpr void validate_unroll_factor()'''
axiom_type = "anti_pattern"
on_violation = '''potential code bloat, instruction cache pollution, degraded performance'''
depends_on = ['validate_unroll_factor_anti_pattern_excessive_N']
reviewed = true

[[axioms]]
id = "validate_unroll_factor_effect_constexpr_evaluation"
content = '''Function is constexpr and performs all validation at compile-time; no runtime overhead'''
formal_spec = '''evaluation_context == compile_time && runtime_cost == O(1)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "validate_unroll_factor"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_common.hpp"
signature = '''constexpr void validate_unroll_factor()'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by constexpr'''
depends_on = ['cpp20_temp_inst_no_implicit_unless_required_b3c4d5e6']
reviewed = true

[[axioms]]
id = "validate_unroll_factor_complexity_compile_time"
content = '''O(1) compile-time evaluation; O(1) runtime complexity (no-op after compilation)'''
formal_spec = '''compile_time_complexity == O(1) && runtime_complexity == O(1)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "validate_unroll_factor"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_common.hpp"
signature = '''constexpr void validate_unroll_factor()'''
axiom_type = "complexity"
on_violation = '''N/A - inherent property'''
reviewed = true

[[axioms]]
id = "validate_unroll_factor_exception_propagation"
content = '''If warn_large_unroll_factor<N>() throws or fails, exception propagates to caller before any subsequent operations'''
formal_spec = '''warn_large_unroll_factor<N>() throws E => validate_unroll_factor() throws E'''
layer = "library"
confidence = 0.85
source_file = ""
source_module = ""
function = "validate_unroll_factor"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_common.hpp"
signature = '''constexpr void validate_unroll_factor()'''
axiom_type = "exception"
on_violation = '''exception propagates'''
depends_on = ['cpp20_except_throw_uncaught_after_init_before_activation_1c8e5a4b', 'cpp20_except_throw_destruction_after_handler_exit_c4a9f2e6', 'cpp20_except_throw_destruction_ordering_d5e1c7b9']
reviewed = true

[[axioms]]
id = "check_sum_overflow_effect_diagnostic_emission_a1b2c3d4"
content = '''At compile-time, if both AccumT and ElemT are integral types and sizeof(AccumT) < sizeof(ElemT), the function invokes warn_accumulator_overflow<AccumT, ElemT>() to emit a diagnostic about potential overflow risk.'''
formal_spec = '''constexpr_if(std::integral<AccumT> && std::integral<ElemT> && sizeof(AccumT) < sizeof(ElemT)) => invoke(warn_accumulator_overflow<AccumT, ElemT>())'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "check_sum_overflow"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_common.hpp"
signature = '''constexpr void check_sum_overflow()'''
axiom_type = "effect"
on_violation = '''N/A - compile-time check, no runtime violation possible'''
depends_on = ['check_sum_overflow_effect_comptime_check_9a3f2b4c']
reviewed = true

[[axioms]]
id = "check_sum_overflow_postcondition_warning_issued_e5f6a7b8"
content = '''After execution, if the conditions std::integral<AccumT> && std::integral<ElemT> && sizeof(AccumT) < sizeof(ElemT) are met, a warning has been issued to alert the developer of potential accumulator overflow.'''
formal_spec = '''post(check_sum_overflow()) && (std::integral<AccumT> && std::integral<ElemT> && sizeof(AccumT) < sizeof(ElemT)) => warning_issued'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "check_sum_overflow"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_common.hpp"
signature = '''constexpr void check_sum_overflow()'''
axiom_type = "postcondition"
on_violation = '''N/A - postcondition always satisfied if preconditions met'''
depends_on = ['check_sum_overflow_postcondition_diagnostic_8b9c0d1e']
reviewed = true

[[axioms]]
id = "check_sum_overflow_constraint_type_safety_c9d0e1f2"
content = '''The function only performs overflow checking when both AccumT and ElemT satisfy std::integral<T>. For non-integral types (e.g., floating-point), the function is a no-op and performs no checks.'''
formal_spec = '''(std::integral<AccumT> && std::integral<ElemT>) => performs_overflow_check | otherwise => no_operation'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "check_sum_overflow"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_common.hpp"
signature = '''constexpr void check_sum_overflow()'''
axiom_type = "constraint"
on_violation = '''N/A - constraint enforced at compile-time via constexpr if'''
depends_on = ['c11_cpp_conversion_syntax_convertType_7e132831']
reviewed = true

[[axioms]]
id = "check_sum_overflow_anti_pattern_size_mismatch_g3h4i5j6"
content = '''Using an accumulator type AccumT with sizeof(AccumT) < sizeof(ElemT) when both are integral types creates overflow risk during accumulation, as the accumulator cannot represent the full range of element values.'''
formal_spec = '''sizeof(AccumT) < sizeof(ElemT) && std::integral<AccumT> && std::integral<ElemT> => overflow_risk_high'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "check_sum_overflow"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_common.hpp"
signature = '''constexpr void check_sum_overflow()'''
axiom_type = "anti_pattern"
on_violation = '''Potential integer overflow during accumulation operations, leading to incorrect results'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4']
reviewed = true

[[axioms]]
id = "check_sum_overflow_precondition_none_k7l8m9n0"
content = '''No runtime preconditions required. The function is constexpr and performs compile-time checks only based on template parameters AccumT and ElemT.'''
formal_spec = '''pre(check_sum_overflow()) => true'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "check_sum_overflow"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_common.hpp"
signature = '''constexpr void check_sum_overflow()'''
axiom_type = "precondition"
on_violation = '''N/A - no preconditions to violate'''
depends_on = ['cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2', 'cpp20_temp_expl_spec_unspecialized_enclosing_template_param_a7b8c9d0', 'for_loop_range_typed_precond_n_valid_offset_b3c4d5e6']
reviewed = true

[[axioms]]
id = "check_sum_overflow_complexity_constant_p1q2r3s4"
content = '''Time complexity: O(1) - compile-time only evaluation with no runtime cost. Space complexity: O(1) - no additional memory allocated.'''
formal_spec = '''time_complexity(check_sum_overflow) = O(1) && space_complexity(check_sum_overflow) = O(1) && constexpr => compile_time_only'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "check_sum_overflow"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_common.hpp"
signature = '''constexpr void check_sum_overflow()'''
axiom_type = "complexity"
on_violation = '''N/A - complexity guarantee always met'''
reviewed = true

[[axioms]]
id = "check_sum_overflow_exception_noexcept_t5u6v7w8"
content = '''The function is constexpr and performs compile-time checks only. It cannot throw exceptions at runtime and is implicitly noexcept.'''
formal_spec = '''constexpr(check_sum_overflow) => noexcept(check_sum_overflow) = true'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "check_sum_overflow"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_common.hpp"
signature = '''constexpr void check_sum_overflow()'''
axiom_type = "exception"
on_violation = '''N/A - no exceptions can be thrown'''
depends_on = ['ilp_end_with_return_error_exception_no_throw_g2h5j8k1', 'cpp20_expr_type_composite_ptr_noexcept_func_m9h2k5i8', 'return_with_exception_noexcept_if_r_noexcept_6f8a3de4']
reviewed = true

[[axioms]]
id = "for_loop_untyped_impl_precond_body_callable"
content = '''body must be a callable object invocable with signature (T, ForCtrl&)'''
formal_spec = '''is_invocable_v<F, T, ForCtrl&>'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "for_loop_untyped_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResult for_loop_untyped_impl(T start, T end, F&& body)'''
axiom_type = "precondition"
on_violation = '''compilation error: body cannot be invoked with required arguments'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_untyped_impl_precond_n_positive"
content = '''Template parameter N must be >= 1'''
formal_spec = '''N >= 1'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_untyped_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResult for_loop_untyped_impl(T start, T end, F&& body)'''
axiom_type = "precondition"
on_violation = '''compilation error: validate_unroll_factor<N>() fails'''
depends_on = ['cpp20_temp_expl_spec_unspecialized_enclosing_template_param_a7b8c9d0', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'for_loop_range_typed_precond_n_valid_offset_b3c4d5e6', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'for_loop_typed_constraint_return_type_r_b1c2d3e4']
reviewed = true

[[axioms]]
id = "for_loop_untyped_impl_precond_t_arithmetic"
content = '''Type T must support arithmetic operations: addition (+=), comparison (<=, <), and static_cast from std::size_t'''
formal_spec = '''requires(T a, T b) { a += b; a <= b; a < b; static_cast<T>(std::size_t()); }'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "for_loop_untyped_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResult for_loop_untyped_impl(T start, T end, F&& body)'''
axiom_type = "precondition"
on_violation = '''compilation error: required operations not available'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_untyped_impl_precond_range_valid"
content = '''start must be <= end to avoid undefined behavior in loop iteration'''
formal_spec = '''start <= end'''
layer = "library"
confidence = 0.85
source_file = ""
source_module = ""
function = "for_loop_untyped_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResult for_loop_untyped_impl(T start, T end, F&& body)'''
axiom_type = "precondition"
on_violation = '''undefined behavior: loop may not terminate or may overflow'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_untyped_impl_constraint_addition_no_overflow"
content = '''For all iterations, i + static_cast<T>(j) must not overflow where j < N'''
formal_spec = '''forall i in [start, end), forall j in [0, N): no_overflow(i + static_cast<T>(j))'''
layer = "library"
confidence = 0.8
source_file = ""
source_module = ""
function = "for_loop_untyped_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResult for_loop_untyped_impl(T start, T end, F&& body)'''
axiom_type = "constraint"
on_violation = '''undefined behavior: integer overflow'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_untyped_impl_constraint_loop_increment_no_overflow"
content = '''Loop increment i += static_cast<T>(N) must not overflow for any iteration'''
formal_spec = '''forall i in range: no_overflow(i + static_cast<T>(N))'''
layer = "library"
confidence = 0.8
source_file = ""
source_module = ""
function = "for_loop_untyped_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResult for_loop_untyped_impl(T start, T end, F&& body)'''
axiom_type = "constraint"
on_violation = '''undefined behavior: integer overflow in loop counter'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_untyped_impl_effect_validate_first"
content = '''First operation validates unroll factor N via validate_unroll_factor<N>() before any loop execution'''
formal_spec = '''first_operation == validate_unroll_factor<N>() && precedes_all_body_invocations'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_untyped_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResult for_loop_untyped_impl(T start, T end, F&& body)'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by implementation'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_untyped_impl_effect_body_invocation_count"
content = '''body is invoked exactly (end - start) times if no early return occurs, with index values [start, end)'''
formal_spec = '''ctrl.ok remains true => body_invocation_count == (end - start) && forall i in [start, end): body(i, ctrl) invoked exactly once'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "for_loop_untyped_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResult for_loop_untyped_impl(T start, T end, F&& body)'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by implementation'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_untyped_impl_effect_early_return_on_ctrl_not_ok"
content = '''If body sets ctrl.ok to false, function returns immediately with ForResult{ctrl.return_set, std::move(ctrl.storage)}'''
formal_spec = '''body(i, ctrl) && !ctrl.ok => return ForResult{ctrl.return_set, std::move(ctrl.storage)} && no_further_body_invocations'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_untyped_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResult for_loop_untyped_impl(T start, T end, F&& body)'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by implementation'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_untyped_impl_effect_move_ctrl_storage"
content = '''On early return, ctrl.storage is moved into the returned ForResult, leaving ctrl.storage in a valid but unspecified state'''
formal_spec = '''!ctrl.ok => std::move(ctrl.storage) invoked && post(valid_but_unspecified(ctrl.storage))'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_untyped_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResult for_loop_untyped_impl(T start, T end, F&& body)'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by implementation'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_untyped_impl_postcond_normal_return"
content = '''If no early return occurs (ctrl.ok remains true for all iterations), returns ForResult{false, {}} with empty storage'''
formal_spec = '''forall i in [start, end): body(i, ctrl) && ctrl.ok => return ForResult{false, {}}'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_untyped_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResult for_loop_untyped_impl(T start, T end, F&& body)'''
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed by implementation'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_untyped_impl_postcond_early_return"
content = '''If early return occurs, returns ForResult{ctrl.return_set, moved(ctrl.storage)} with return_set reflecting the control state'''
formal_spec = '''exists i in [start, end): body(i, ctrl) && !ctrl.ok => return ForResult{ctrl.return_set, std::move(ctrl.storage)}'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_untyped_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResult for_loop_untyped_impl(T start, T end, F&& body)'''
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed by implementation'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_untyped_impl_invariant_ctrl_state_consistent"
content = '''Throughout execution, ctrl.ok == true implies continued iteration; ctrl.ok == false triggers immediate return'''
formal_spec = '''loop_invariant: ctrl.ok == true <=> continue_iteration && ctrl.ok == false => immediate_return'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "for_loop_untyped_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResult for_loop_untyped_impl(T start, T end, F&& body)'''
axiom_type = "invariant"
on_violation = '''N/A - guaranteed by implementation'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_untyped_impl_invariant_loop_counter_bounds"
content = '''Loop counter i satisfies start <= i <= end throughout execution'''
formal_spec = '''loop_invariant: start <= i <= end'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "for_loop_untyped_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResult for_loop_untyped_impl(T start, T end, F&& body)'''
axiom_type = "invariant"
on_violation = '''N/A - guaranteed by implementation'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_untyped_impl_exception_validate_propagates"
content = '''If validate_unroll_factor<N>() throws or fails, exception propagates before any loop execution or body invocations'''
formal_spec = '''validate_unroll_factor<N>() throws E => for_loop_untyped_impl throws E && body_invocation_count == 0'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_untyped_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResult for_loop_untyped_impl(T start, T end, F&& body)'''
axiom_type = "exception"
on_violation = '''N/A - exception handling mechanism'''
depends_on = ['cpp20_except_throw_destruction_ordering_d5e1c7b9', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_except_throw_destruction_after_handler_exit_c4a9f2e6', 'cpp20_except_throw_uncaught_after_init_before_activation_1c8e5a4b', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "for_loop_untyped_impl_exception_body_propagates"
content = '''If body(i, ctrl) throws an exception E, it propagates to the caller; no exception safety guarantees on ctrl state'''
formal_spec = '''body(i, ctrl) throws E => for_loop_untyped_impl throws E && ctrl state unspecified'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "for_loop_untyped_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResult for_loop_untyped_impl(T start, T end, F&& body)'''
axiom_type = "exception"
on_violation = '''N/A - exception handling mechanism'''
depends_on = ['cpp20_except_throw_destruction_ordering_d5e1c7b9', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_except_throw_destruction_after_handler_exit_c4a9f2e6', 'cpp20_except_throw_uncaught_after_init_before_activation_1c8e5a4b', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "for_loop_untyped_impl_anti_pattern_large_n"
content = '''Avoid using N > 16 without careful consideration; large unroll factors cause code bloat and may reduce performance'''
formal_spec = '''caution_recommended: N > 16'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "for_loop_untyped_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResult for_loop_untyped_impl(T start, T end, F&& body)'''
axiom_type = "anti_pattern"
on_violation = '''warning issued by validate_unroll_factor<N>(), potential performance degradation'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_untyped_impl_complexity_time_linear"
content = '''Time complexity is O(end - start) body invocations, plus O(1) overhead for validate_unroll_factor<N>()'''
formal_spec = '''T(n) = O(n) where n = (end - start), assuming O(1) body execution'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "for_loop_untyped_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResult for_loop_untyped_impl(T start, T end, F&& body)'''
axiom_type = "complexity"
on_violation = '''N/A - performance characteristic'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_untyped_impl_complexity_space_constant"
content = '''Space complexity is O(1) for local variables (ctrl, i, j), excluding space used by body callable or ctrl.storage'''
formal_spec = '''S(n) = O(1) excluding sizeof(F) and sizeof(ctrl.storage)'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "for_loop_untyped_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResult for_loop_untyped_impl(T start, T end, F&& body)'''
axiom_type = "complexity"
on_violation = '''N/A - performance characteristic'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_untyped_impl_constraint_static_cast_valid"
content = '''static_cast<T>(j) where j is std::size_t in [0, N) must be well-defined and produce values <= N-1'''
formal_spec = '''forall j in [0, N): static_cast<T>(j) well_formed && static_cast<T>(j) <= static_cast<T>(N-1)'''
layer = "library"
confidence = 0.85
source_file = ""
source_module = ""
function = "for_loop_untyped_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResult for_loop_untyped_impl(T start, T end, F&& body)'''
axiom_type = "constraint"
on_violation = '''compilation error or undefined conversion if T cannot represent values in [0, N)'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_untyped_impl_constraint_forwarding_reference"
content = '''Body parameter F&& is a forwarding reference accepting both lvalue and rvalue callable objects, enabling move semantics for temporary functors'''
formal_spec = '''is_forwarding_reference<F&&> && accepts_lvalue(F&&) && accepts_rvalue(F&&)'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "for_loop_untyped_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResult for_loop_untyped_impl(T start, T end, F&& body)'''
axiom_type = "constraint"
on_violation = '''N/A - template parameter property'''
depends_on = ['for_loop_range_impl_effect_forwards_body_parameter_e5f6a7b8', 'ctrl_r_conversion_operator_anti_pattern_use_after_move_a9d4f7e2', 'for_loop_range_impl_effect_forwards_range_parameter_a9b0c1d2', 'extract_constraint_type_r_moveable_f6c8d2e4', 'ctrl_r_conversion_operator_effect_move_semantics_143', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_expr_cast_lvalue_result_d4e8a1c3', 'cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_basic_lval_temp_materialization_b4e9f1c5']
reviewed = true

[[axioms]]
id = "for_loop_typed_impl_precond_body_callable_a1b2c3d4"
content = '''Body must be a callable object accepting (T, ForCtrlTyped<R>&) signature'''
formal_spec = '''is_invocable<F, T, ForCtrlTyped<R>&>'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "for_loop_typed_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_typed_impl(T start, T end, F&& body)'''
axiom_type = "precondition"
on_violation = '''Compilation error: cannot invoke body with required arguments'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_typed_impl_precond_valid_unroll_factor_e5f6a7b8"
content = '''Template parameter N must be >= 1 (validated at compile time)'''
formal_spec = '''N >= 1'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_typed_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_typed_impl(T start, T end, F&& body)'''
axiom_type = "precondition"
on_violation = '''Compilation error or warning from validate_unroll_factor<N>()'''
depends_on = ['cpp20_temp_expl_spec_unspecialized_enclosing_template_param_a7b8c9d0', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'for_loop_range_typed_precond_n_valid_offset_b3c4d5e6', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'for_loop_typed_constraint_return_type_r_b1c2d3e4']
reviewed = true

[[axioms]]
id = "for_loop_typed_impl_precond_range_valid_9c8d7e6f"
content = '''start <= end to ensure non-negative iteration count'''
formal_spec = '''start <= end'''
layer = "library"
confidence = 0.85
source_file = ""
source_module = ""
function = "for_loop_typed_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_typed_impl(T start, T end, F&& body)'''
axiom_type = "precondition"
on_violation = '''No iterations occur; function returns immediately with default ForResultTyped'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_typed_impl_precond_addition_no_overflow_4f5g6h7i"
content = '''i + static_cast<T>(j) must not overflow for all iterations where j < N'''
formal_spec = '''forall i in [start, end), forall j in [0, N): i + j <= numeric_limits<T>::max()'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "for_loop_typed_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_typed_impl(T start, T end, F&& body)'''
axiom_type = "precondition"
on_violation = '''Undefined behavior: signed integer overflow or wraparound for unsigned types'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_typed_impl_precond_increment_no_overflow_8i9j0k1l"
content = '''i += static_cast<T>(N) must not overflow during unrolled loop iterations'''
formal_spec = '''forall i in [start, end, step=N): i + N <= numeric_limits<T>::max()'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "for_loop_typed_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_typed_impl(T start, T end, F&& body)'''
axiom_type = "precondition"
on_violation = '''Undefined behavior: signed integer overflow or infinite loop for unsigned wraparound'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_typed_impl_effect_validate_first_2m3n4o5p"
content = '''First operation validates unroll factor N via validate_unroll_factor<N>() before any loop execution'''
formal_spec = '''first_operation == validate_unroll_factor<N>() && occurs_before_all_loops'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_typed_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_typed_impl(T start, T end, F&& body)'''
axiom_type = "effect"
on_violation = '''N/A - enforced by function structure'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_typed_impl_effect_body_invocation_count_6q7r8s9t"
content = '''Body is invoked exactly (end - start) times if ctrl.ok remains true throughout execution'''
formal_spec = '''ctrl.ok == true throughout => body_invocation_count == (end - start)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_typed_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_typed_impl(T start, T end, F&& body)'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by loop structure'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_typed_impl_effect_early_return_on_break_0u1v2w3x"
content = '''If body sets ctrl.ok = false, iteration stops immediately and returns ForResultTyped with ctrl.storage'''
formal_spec = '''ctrl.ok == false after body(i, ctrl) => return ForResultTyped{true, move(ctrl.storage)} && no_further_iterations'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_typed_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_typed_impl(T start, T end, F&& body)'''
axiom_type = "effect"
on_violation = '''N/A - enforced by guard checks'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_typed_impl_effect_unrolled_iteration_4y5z6a7b"
content = '''Unrolled loop invokes body N times per outer iteration with indices i, i+1, ..., i+N-1'''
formal_spec = '''forall outer_iteration i: body invoked with (i+0, ctrl), (i+1, ctrl), ..., (i+N-1, ctrl) sequentially'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_typed_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_typed_impl(T start, T end, F&& body)'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by nested loop structure'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_typed_impl_effect_remainder_iteration_8c9d0e1f"
content = '''Remainder loop handles final (end - i) iterations when (end - i) < N'''
formal_spec = '''after_unrolled_loop: i < end => body invoked for each index in [i, end) sequentially'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_typed_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_typed_impl(T start, T end, F&& body)'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by remainder loop structure'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_typed_impl_postcond_complete_iteration_2g3h4i5j"
content = '''If function returns ForResultTyped{false, {}}, all (end - start) iterations completed successfully with ctrl.ok == true'''
formal_spec = '''return.return_set == false => body_invoked_count == (end - start) && ctrl.ok == true throughout'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_typed_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_typed_impl(T start, T end, F&& body)'''
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed by logic flow'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_typed_impl_postcond_early_return_6k7l8m9n"
content = '''If function returns ForResultTyped{true, storage}, body set ctrl.ok = false at some iteration, and storage contains moved ctrl.storage'''
formal_spec = '''return.return_set == true => exists i in [start, end): body(i, ctrl) set ctrl.ok = false && return.storage == moved_from(ctrl.storage)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_typed_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_typed_impl(T start, T end, F&& body)'''
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed by early return logic'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_typed_impl_invariant_ctrl_state_consistent_0o1p2q3r"
content = '''ctrl.ok == true OR function has returned; once ctrl.ok becomes false, no further iterations occur'''
formal_spec = '''loop_invariant: ctrl.ok == true || function_returned'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_typed_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_typed_impl(T start, T end, F&& body)'''
axiom_type = "invariant"
on_violation = '''N/A - enforced by guard checks after each body invocation'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_typed_impl_invariant_index_bounds_4s5t6u7v"
content = '''Loop index i satisfies start <= i <= end throughout execution'''
formal_spec = '''loop_invariant: start <= i <= end'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_typed_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_typed_impl(T start, T end, F&& body)'''
axiom_type = "invariant"
on_violation = '''N/A - guaranteed by loop conditions'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_typed_impl_constraint_type_T_arithmetic_8w9x0y1z"
content = '''Type T must support arithmetic operations: addition, comparison (<=, <), and increment (+=)'''
formal_spec = '''requires std::is_arithmetic_v<T> || (has_operator_plus<T> && has_operator_compare<T> && has_operator_increment<T>)'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "for_loop_typed_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_typed_impl(T start, T end, F&& body)'''
axiom_type = "constraint"
on_violation = '''Compilation error: required operators not available for type T'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_typed_impl_constraint_static_cast_valid_2a3b4c5d"
content = '''static_cast<T>(j) and static_cast<T>(N) must be valid conversions from std::size_t to T'''
formal_spec = '''is_valid_static_cast<std::size_t, T> && (j < N => static_cast<T>(j) preserves_value(j))'''
layer = "library"
confidence = 0.85
source_file = ""
source_module = ""
function = "for_loop_typed_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_typed_impl(T start, T end, F&& body)'''
axiom_type = "constraint"
on_violation = '''Compilation error or value truncation/narrowing if T cannot represent size_t values'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_typed_impl_exception_validate_propagates_6e7f8g9h"
content = '''If validate_unroll_factor<N>() throws, exception propagates before any loop execution'''
formal_spec = '''validate_unroll_factor<N>() throws E => for_loop_typed_impl throws E && body_invocation_count == 0'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_typed_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_typed_impl(T start, T end, F&& body)'''
axiom_type = "exception"
on_violation = '''Exception propagates to caller'''
depends_on = ['cpp20_except_throw_destruction_ordering_d5e1c7b9', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_except_throw_destruction_after_handler_exit_c4a9f2e6', 'cpp20_except_throw_uncaught_after_init_before_activation_1c8e5a4b', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "for_loop_typed_impl_exception_body_throws_0i1j2k3l"
content = '''If body throws exception, it propagates immediately; ctrl.ok check is bypassed'''
formal_spec = '''body(i, ctrl) throws E => for_loop_typed_impl throws E && no_further_iterations'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "for_loop_typed_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_typed_impl(T start, T end, F&& body)'''
axiom_type = "exception"
on_violation = '''Exception propagates to caller'''
depends_on = ['cpp20_except_throw_destruction_ordering_d5e1c7b9', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_except_throw_destruction_after_handler_exit_c4a9f2e6', 'cpp20_except_throw_uncaught_after_init_before_activation_1c8e5a4b', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "for_loop_typed_impl_anti_pattern_large_N_4m5n6o7p"
content = '''Avoid using N > 16; large unroll factors cause code bloat and may reduce performance'''
formal_spec = '''caution_recommended: N > 16'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_typed_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_typed_impl(T start, T end, F&& body)'''
axiom_type = "anti_pattern"
on_violation = '''Warning issued by validate_unroll_factor; possible code bloat and cache pressure'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_typed_impl_anti_pattern_narrow_type_8q9r0s1t"
content = '''Avoid using narrow integer types (int8_t, uint8_t) when N is large or range is large; risk of overflow'''
formal_spec = '''caution_recommended: sizeof(T) < 4 && (N > 8 || (end - start) > 127)'''
layer = "library"
confidence = 0.8
source_file = ""
source_module = ""
function = "for_loop_typed_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_typed_impl(T start, T end, F&& body)'''
axiom_type = "anti_pattern"
on_violation = '''High risk of integer overflow leading to undefined behavior or infinite loops'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "for_loop_typed_impl_complexity_time_2u3v4w5x"
content = '''Time complexity is O(end - start) body invocations plus O(1) overhead from validate_unroll_factor'''
formal_spec = '''time_complexity = O(end - start) * cost(body) + O(1)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_typed_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_typed_impl(T start, T end, F&& body)'''
axiom_type = "complexity"
on_violation = '''N/A - complexity guarantee'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_typed_impl_complexity_space_6y7z8a9b"
content = '''Space complexity is O(1) for loop state plus sizeof(ForCtrlTyped<R>) plus space used by body'''
formal_spec = '''space_complexity = O(1) + sizeof(ForCtrlTyped<R>) + space(body)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_typed_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_typed_impl(T start, T end, F&& body)'''
axiom_type = "complexity"
on_violation = '''N/A - complexity guarantee'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_typed_impl_effect_move_semantics_0c1d2e3f"
content = '''When returning early, ctrl.storage is moved (not copied) into return value, leaving ctrl.storage in moved-from state'''
formal_spec = '''return_early => ForResultTyped.storage == moved_from(ctrl.storage) && valid_but_unspecified(ctrl.storage)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_typed_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_typed_impl(T start, T end, F&& body)'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by std::move semantics'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_typed_impl_constraint_forwarding_reference_4g5h6i7j"
content = '''Parameter F&& is a forwarding reference accepting both lvalue and rvalue callable objects'''
formal_spec = '''is_forwarding_reference<F&&> && accepts_lvalue(F&&) && accepts_rvalue(F&&)'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "for_loop_typed_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_typed_impl(T start, T end, F&& body)'''
axiom_type = "constraint"
on_violation = '''Compilation error if F is not a valid callable type'''
depends_on = ['for_loop_range_impl_effect_forwards_body_parameter_e5f6a7b8', 'ctrl_r_conversion_operator_anti_pattern_use_after_move_a9d4f7e2', 'for_loop_range_impl_effect_forwards_range_parameter_a9b0c1d2', 'extract_constraint_type_r_moveable_f6c8d2e4', 'ctrl_r_conversion_operator_effect_move_semantics_143', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_expr_cast_lvalue_result_d4e8a1c3', 'cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_basic_lval_temp_materialization_b4e9f1c5']
reviewed = true

[[axioms]]
id = "for_loop_range_impl_precond_range_valid_b3c4d5e6"
content = '''Range must be a valid range type satisfying std::ranges::sized_range and std::ranges::random_access_range, providing valid begin() and size() operations'''
formal_spec = '''valid_expr(std::ranges::begin(range)) && valid_expr(std::ranges::size(range)) && models<sized_range>(Range) && models<random_access_range>(Range)'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "for_loop_range_impl"
header = "ilp_for/detail/loops_ilp.hpp"
signature = '''void for_loop_range_impl(Range&& range, F&& body)'''
axiom_type = "precondition"
on_violation = '''Compilation error if range does not satisfy concept requirements'''
depends_on = ['for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'ilp_for_range_constraint_range_parenthesized_e9a2f4b6', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "for_loop_range_impl_precond_iterator_random_access_d7e8f9a0"
content = '''Iterator returned by std::ranges::begin(range) must support random access (subscript operator it[index])'''
formal_spec = '''it = std::ranges::begin(range) => models<random_access_iterator>(decltype(it)) && valid_expr(it[index])'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_range_impl"
header = "ilp_for/detail/loops_ilp.hpp"
signature = '''void for_loop_range_impl(Range&& range, F&& body)'''
axiom_type = "precondition"
on_violation = '''Compilation error if iterator does not support subscript operator'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_over_match_oper_no_class_enum_builtin_f1a2b3c4', 'for_loop_range_untyped_impl_precond_iterator_random_access_b2c3d4e5', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_over_match_oper_fallback_builtin_comma_addr_arrow_b3c4d5e6', 'c11_cpp_translation_name_syntax_operation_018c4422', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'for_loop_range_impl_anti_pattern_non_random_access_e5f6a7b8', 'for_loop_range_ret_simple_impl_precond_random_access_e5f6a7b8']
reviewed = true

[[axioms]]
id = "for_loop_range_impl_precond_body_callable_f0a1b2c3"
content = '''Body must be callable with signature (Ref) or (Ref, LoopCtrl<void>&) where Ref = std::ranges::range_reference_t<Range>'''
formal_spec = '''(is_invocable<F, Ref> || is_invocable<F, Ref, LoopCtrl<void>&>) && Ref = std::ranges::range_reference_t<Range>'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "for_loop_range_impl"
header = "ilp_for/detail/loops_ilp.hpp"
signature = '''void for_loop_range_impl(Range&& range, F&& body)'''
axiom_type = "precondition"
on_violation = '''Compilation error with static_assert message'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "for_loop_range_impl_precond_unroll_factor_valid_a5b6c7d8"
content = '''Template parameter N must be >= 1, validated at compile-time by validate_unroll_factor<N>()'''
formal_spec = '''N >= 1'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_range_impl"
header = "ilp_for/detail/loops_ilp.hpp"
signature = '''void for_loop_range_impl(Range&& range, F&& body)'''
axiom_type = "precondition"
on_violation = '''Compilation error if N < 1'''
depends_on = ['cpp20_temp_expl_spec_unspecialized_enclosing_template_param_a7b8c9d0', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'for_loop_range_typed_precond_n_valid_offset_b3c4d5e6', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'for_loop_typed_constraint_return_type_r_b1c2d3e4']
reviewed = true

[[axioms]]
id = "for_loop_range_impl_constraint_array_access_bounds_inner_loop_e9f0a1b2"
content = '''Array access it[i + j] requires i + j < size, guaranteed by loop guards (i + N <= size && j < N)'''
formal_spec = '''it[i + j] => (i + N <= size) && (j < N) => (i + j < i + N <= size) => (i + j < size)'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "for_loop_range_impl"
header = "ilp_for/detail/loops_ilp.hpp"
signature = '''void for_loop_range_impl(Range&& range, F&& body)'''
axiom_type = "constraint"
on_violation = '''Undefined behavior if bounds violated, but prevented by loop guards'''
depends_on = ['cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'for_loop_range_untyped_impl_constraint_array_bounds_remainder_b8c9d0e1', 'for_loop_range_typed_impl_constraint_array_access_inner_n7o8p9q0', 'for_loop_range_typed_impl_constraint_array_access_remainder_r1s2t3u4', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "for_loop_range_impl_constraint_array_access_bounds_inner_loop_no_ctrl_c3d4e5f6"
content = '''Array access it[i + j] in else branch requires i + j < size, guaranteed by loop guards (i + N <= size && j < N)'''
formal_spec = '''it[i + j] && !has_ctrl => (i + N <= size) && (j < N) => (i + j < size)'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "for_loop_range_impl"
header = "ilp_for/detail/loops_ilp.hpp"
signature = '''void for_loop_range_impl(Range&& range, F&& body)'''
axiom_type = "constraint"
on_violation = '''Undefined behavior if bounds violated, but prevented by loop guards'''
depends_on = ['cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'for_loop_range_untyped_impl_constraint_array_bounds_remainder_b8c9d0e1', 'for_loop_range_typed_impl_constraint_array_access_inner_n7o8p9q0', 'for_loop_range_typed_impl_constraint_array_access_remainder_r1s2t3u4', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "for_loop_range_impl_constraint_array_access_bounds_remainder_loop_a7b8c9d0"
content = '''Array access it[i] in remainder loop requires i < size, guaranteed by loop guard (i < size)'''
formal_spec = '''it[i] && has_ctrl => (i < size) && ctrl.ok'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "for_loop_range_impl"
header = "ilp_for/detail/loops_ilp.hpp"
signature = '''void for_loop_range_impl(Range&& range, F&& body)'''
axiom_type = "constraint"
on_violation = '''Undefined behavior if bounds violated, but prevented by loop guard'''
depends_on = ['cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'for_loop_range_typed_impl_constraint_array_access_inner_n7o8p9q0', 'for_loop_range_typed_impl_constraint_array_access_remainder_r1s2t3u4', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'for_loop_range_impl_constraint_array_access_bounds_inner_loop_e9f0a1b2']
reviewed = true

[[axioms]]
id = "for_loop_range_impl_constraint_array_access_bounds_remainder_loop_no_ctrl_e1f2a3b4"
content = '''Array access it[i] in else branch remainder loop requires i < size, guaranteed by loop guard (i < size)'''
formal_spec = '''it[i] && !has_ctrl => (i < size)'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "for_loop_range_impl"
header = "ilp_for/detail/loops_ilp.hpp"
signature = '''void for_loop_range_impl(Range&& range, F&& body)'''
axiom_type = "constraint"
on_violation = '''Undefined behavior if bounds violated, but prevented by loop guard'''
depends_on = ['cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'for_loop_range_untyped_impl_constraint_array_bounds_remainder_b8c9d0e1', 'for_loop_range_typed_impl_constraint_array_access_inner_n7o8p9q0', 'for_loop_range_typed_impl_constraint_array_access_remainder_r1s2t3u4', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "for_loop_range_impl_effect_validate_unroll_factor_first_b5c6d7e8"
content = '''Validates unroll factor N at compile-time as first operation before any loop execution'''
formal_spec = '''first_operation == validate_unroll_factor<N>() && occurs_before_all_other_operations'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_range_impl"
header = "ilp_for/detail/loops_ilp.hpp"
signature = '''void for_loop_range_impl(Range&& range, F&& body)'''
axiom_type = "effect"
on_violation = '''N/A - compile-time validation'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_range_impl_effect_range_single_evaluation_f9a0b1c2"
content = '''Range expression is evaluated exactly once at function entry via std::ranges::begin() and std::ranges::size()'''
formal_spec = '''eval_count(std::ranges::begin(range)) == 1 && eval_count(std::ranges::size(range)) == 1 && occurs_at_function_start'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_range_impl"
header = "ilp_for/detail/loops_ilp.hpp"
signature = '''void for_loop_range_impl(Range&& range, F&& body)'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by implementation'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "for_loop_range_impl_effect_body_invocation_unrolled_d3e4f5a6"
content = '''Body is invoked exactly size times, in N-element unrolled chunks followed by remainder elements, with elements it[0], it[1], ..., it[size-1]'''
formal_spec = '''invocation_count(body) == size && forall k in [0, size): body_invoked_with(it[k]) && unrolled_in_chunks_of(N)'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "for_loop_range_impl"
header = "ilp_for/detail/loops_ilp.hpp"
signature = '''void for_loop_range_impl(Range&& range, F&& body)'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by loop structure'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_range_impl_effect_early_termination_ctrl_ok_b7c8d9e0"
content = '''When has_ctrl is true, loop terminates early if ctrl.ok becomes false, potentially invoking body fewer than size times'''
formal_spec = '''has_ctrl && !ctrl.ok => loop_terminates && invocation_count(body) < size'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "for_loop_range_impl"
header = "ilp_for/detail/loops_ilp.hpp"
signature = '''void for_loop_range_impl(Range&& range, F&& body)'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by loop guard ctrl.ok'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_range_impl_effect_forwards_range_parameter_a9b0c1d2"
content = '''Perfectly forwards range parameter preserving its value category (lvalue/rvalue) through Range&& forwarding reference'''
formal_spec = '''forwards<Range>(range) => preserves_value_category<Range>(range)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_range_impl"
header = "ilp_for/detail/loops_ilp.hpp"
signature = '''void for_loop_range_impl(Range&& range, F&& body)'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by forwarding reference syntax'''
depends_on = ['for_loop_range_impl_effect_forwards_body_parameter_e5f6a7b8', 'for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'ctrl_r_conversion_operator_anti_pattern_use_after_move_a9d4f7e2', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4', 'ctrl_r_conversion_operator_effect_move_semantics_143', 'extract_constraint_type_r_moveable_f6c8d2e4', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_expr_cast_lvalue_result_d4e8a1c3', 'cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_basic_lval_temp_materialization_b4e9f1c5']
reviewed = true

[[axioms]]
id = "for_loop_range_impl_effect_forwards_body_parameter_e5f6a7b8"
content = '''Perfectly forwards body functor parameter preserving its value category through F&& forwarding reference'''
formal_spec = '''forwards<F>(body) => preserves_value_category<F>(body)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_range_impl"
header = "ilp_for/detail/loops_ilp.hpp"
signature = '''void for_loop_range_impl(Range&& range, F&& body)'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by forwarding reference syntax'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'for_loop_range_impl_effect_forwards_range_parameter_a9b0c1d2']
reviewed = true

[[axioms]]
id = "for_loop_range_impl_invariant_index_bounds_i_c1d2e3f4"
content = '''Loop invariant: 0 <= i <= size throughout all loop iterations'''
formal_spec = '''loop_invariant: 0 <= i && i <= size'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_range_impl"
header = "ilp_for/detail/loops_ilp.hpp"
signature = '''void for_loop_range_impl(Range&& range, F&& body)'''
axiom_type = "invariant"
on_violation = '''N/A - maintained by loop structure'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_range_impl_invariant_index_alignment_unrolled_f7a8b9c0"
content = '''In unrolled loop, i is always aligned to N-element boundary: i % N == 0'''
formal_spec = '''in_unrolled_loop => i % N == 0'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "for_loop_range_impl"
header = "ilp_for/detail/loops_ilp.hpp"
signature = '''void for_loop_range_impl(Range&& range, F&& body)'''
axiom_type = "invariant"
on_violation = '''N/A - maintained by i += N increment'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_range_impl_invariant_ctrl_state_monotonic_d9e0f1a2"
content = '''When has_ctrl is true, ctrl.ok can only transition from true to false, never back to true (monotonic)'''
formal_spec = '''has_ctrl && ctrl.ok == false => forall future_iterations: ctrl.ok == false'''
layer = "library"
confidence = 0.85
source_file = ""
source_module = ""
function = "for_loop_range_impl"
header = "ilp_for/detail/loops_ilp.hpp"
signature = '''void for_loop_range_impl(Range&& range, F&& body)'''
axiom_type = "invariant"
on_violation = '''N/A - depends on body implementation'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_range_impl_postcond_all_elements_processed_b3c4d5e6"
content = '''If ctrl.ok remains true (or has_ctrl is false), body has been invoked exactly size times with it[0] through it[size-1]'''
formal_spec = '''(!has_ctrl || ctrl.ok == true) => invocation_count(body) == size && forall k in [0, size): body_invoked_with(it[k])'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "for_loop_range_impl"
header = "ilp_for/detail/loops_ilp.hpp"
signature = '''void for_loop_range_impl(Range&& range, F&& body)'''
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed by loop completion'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_range_impl_postcond_partial_processing_ctrl_a7b8c9d0"
content = '''If has_ctrl is true and ctrl.ok becomes false, body has been invoked with it[0] through it[k] for some k < size where ctrl.ok became false'''
formal_spec = '''has_ctrl && ctrl.ok == false => exists k < size: invocation_count(body) == k+1 && body_invoked_with_caused_ctrl_false(it[k])'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "for_loop_range_impl"
header = "ilp_for/detail/loops_ilp.hpp"
signature = '''void for_loop_range_impl(Range&& range, F&& body)'''
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed by loop termination on ctrl.ok'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_range_impl_postcond_final_index_value_e1f2a3b4"
content = '''After function returns, i == size (if ctrl.ok remains true or has_ctrl is false)'''
formal_spec = '''(!has_ctrl || ctrl.ok == true) && function_returns => i == size'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "for_loop_range_impl"
header = "ilp_for/detail/loops_ilp.hpp"
signature = '''void for_loop_range_impl(Range&& range, F&& body)'''
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed by loop termination condition'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_range_impl_exception_validate_propagates_c5d6e7f8"
content = '''If validate_unroll_factor<N>() throws or fails compilation, exception/error propagates before any loop execution or body invocation'''
formal_spec = '''validate_unroll_factor<N>() throws E => function_throws(E) && invocation_count(body) == 0'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "for_loop_range_impl"
header = "ilp_for/detail/loops_ilp.hpp"
signature = '''void for_loop_range_impl(Range&& range, F&& body)'''
axiom_type = "exception"
on_violation = '''N/A - compile-time or early runtime failure'''
depends_on = ['cpp20_except_throw_destruction_ordering_d5e1c7b9', 'c11_libc_stdio_str_511422b8', 'c11_c_common_expr_bitwise_operation_54b48e73', 'c11_libc_stdio_hasRadix_a9ccb8f7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_except_throw_destruction_after_handler_exit_c4a9f2e6', 'cpp20_except_throw_uncaught_after_init_before_activation_1c8e5a4b', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "for_loop_range_impl_exception_body_propagates_a9b0c1d2"
content = '''If body throws exception E during invocation, exception propagates immediately and remaining iterations are not executed'''
formal_spec = '''body(it[k]) throws E => function_throws(E) && invocation_count(body) == k+1 && forall j > k: !body_invoked_with(it[j])'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_range_impl"
header = "ilp_for/detail/loops_ilp.hpp"
signature = '''void for_loop_range_impl(Range&& range, F&& body)'''
axiom_type = "exception"
on_violation = '''N/A - standard exception propagation'''
depends_on = ['cpp20_except_throw_destruction_ordering_d5e1c7b9', 'c11_libc_stdio_str_511422b8', 'c11_c_common_expr_bitwise_operation_54b48e73', 'c11_libc_stdio_hasRadix_a9ccb8f7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_except_throw_destruction_after_handler_exit_c4a9f2e6', 'cpp20_except_throw_uncaught_after_init_before_activation_1c8e5a4b', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "for_loop_range_impl_exception_ranges_begin_propagates_f3a4b5c6"
content = '''If std::ranges::begin(range) throws exception E, exception propagates before loop execution'''
formal_spec = '''std::ranges::begin(range) throws E => function_throws(E) && invocation_count(body) == 0'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_range_impl"
header = "ilp_for/detail/loops_ilp.hpp"
signature = '''void for_loop_range_impl(Range&& range, F&& body)'''
axiom_type = "exception"
on_violation = '''N/A - standard exception propagation'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'cpp20_except_throw_destruction_ordering_d5e1c7b9', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4', 'c11_libc_stdio_str_511422b8', 'c11_c_common_expr_bitwise_operation_54b48e73', 'c11_libc_stdio_hasRadix_a9ccb8f7', 'cpp20_except_throw_destruction_after_handler_exit_c4a9f2e6', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_except_throw_uncaught_after_init_before_activation_1c8e5a4b', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "for_loop_range_impl_exception_ranges_size_propagates_d7e8f9a0"
content = '''If std::ranges::size(range) throws exception E, exception propagates before loop execution'''
formal_spec = '''std::ranges::size(range) throws E => function_throws(E) && invocation_count(body) == 0'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_range_impl"
header = "ilp_for/detail/loops_ilp.hpp"
signature = '''void for_loop_range_impl(Range&& range, F&& body)'''
axiom_type = "exception"
on_violation = '''N/A - standard exception propagation'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4', 'cpp20_except_throw_destruction_ordering_d5e1c7b9', 'c11_libc_stdio_str_511422b8', 'c11_c_common_expr_bitwise_operation_54b48e73', 'c11_libc_stdio_hasRadix_a9ccb8f7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_except_throw_destruction_after_handler_exit_c4a9f2e6', 'cpp20_except_throw_uncaught_after_init_before_activation_1c8e5a4b', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "for_loop_range_impl_anti_pattern_large_N_warning_b1c2d3e4"
content = '''Avoid using N > 16 without careful consideration; large unroll factors cause code bloat and may reduce performance'''
formal_spec = '''caution_recommended: N > 16'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "for_loop_range_impl"
header = "ilp_for/detail/loops_ilp.hpp"
signature = '''void for_loop_range_impl(Range&& range, F&& body)'''
axiom_type = "anti_pattern"
on_violation = '''Warning issued by validate_unroll_factor<N>() at compile-time'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_range_impl_anti_pattern_non_random_access_e5f6a7b8"
content = '''Do not use with ranges whose iterators are not random access (e.g., std::list, forward_list); subscript operator it[i] required'''
formal_spec = '''!models<random_access_range>(Range) => compilation_error'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_range_impl"
header = "ilp_for/detail/loops_ilp.hpp"
signature = '''void for_loop_range_impl(Range&& range, F&& body)'''
axiom_type = "anti_pattern"
on_violation = '''Compilation error when attempting it[i] with non-random-access iterator'''
depends_on = ['cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_over_match_oper_no_class_enum_builtin_f1a2b3c4', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_over_match_oper_fallback_builtin_comma_addr_arrow_b3c4d5e6', 'c11_cpp_translation_name_syntax_operation_018c4422', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "for_loop_range_impl_complexity_time_linear_a3b4c5d6"
content = '''Time complexity is O(size) where size = std::ranges::size(range), with each element processed exactly once (or until ctrl.ok becomes false)'''
formal_spec = '''time_complexity = O(size) where size = std::ranges::size(range)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_range_impl"
header = "ilp_for/detail/loops_ilp.hpp"
signature = '''void for_loop_range_impl(Range&& range, F&& body)'''
axiom_type = "complexity"
on_violation = '''N/A - guaranteed by single-pass loop structure'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "for_loop_range_impl_complexity_space_constant_c7d8e9f0"
content = '''Space complexity is O(1) for local variables (it, size, i, j, ctrl); does not depend on range size'''
formal_spec = '''space_complexity = O(1)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_range_impl"
header = "ilp_for/detail/loops_ilp.hpp"
signature = '''void for_loop_range_impl(Range&& range, F&& body)'''
axiom_type = "complexity"
on_violation = '''N/A - fixed number of stack variables'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "for_loop_range_impl_constraint_range_lvalue_or_rvalue_f1a2b3c4"
content = '''Range parameter accepts both lvalue and rvalue references via forwarding reference Range&&, enabling use with temporary and named ranges'''
formal_spec = '''is_forwarding_reference<Range&&> && accepts_lvalue(Range&&) && accepts_rvalue(Range&&)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_range_impl"
header = "ilp_for/detail/loops_ilp.hpp"
signature = '''void for_loop_range_impl(Range&& range, F&& body)'''
axiom_type = "constraint"
on_violation = '''N/A - guaranteed by forwarding reference syntax'''
depends_on = ['for_loop_range_impl_effect_forwards_body_parameter_e5f6a7b8', 'for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'ctrl_r_conversion_operator_anti_pattern_use_after_move_a9d4f7e2', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4', 'for_loop_range_impl_effect_forwards_range_parameter_a9b0c1d2', 'ctrl_r_conversion_operator_effect_move_semantics_143', 'extract_constraint_type_r_moveable_f6c8d2e4', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_expr_cast_lvalue_result_d4e8a1c3', 'cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_basic_lval_temp_materialization_b4e9f1c5']
reviewed = true

[[axioms]]
id = "for_loop_range_impl_constraint_body_lvalue_or_rvalue_d5e6f7a8"
content = '''Body parameter accepts both lvalue and rvalue callable objects via forwarding reference F&&, enabling move semantics for temporary functors'''
formal_spec = '''is_forwarding_reference<F&&> && accepts_lvalue(F&&) && accepts_rvalue(F&&)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_range_impl"
header = "ilp_for/detail/loops_ilp.hpp"
signature = '''void for_loop_range_impl(Range&& range, F&& body)'''
axiom_type = "constraint"
on_violation = '''N/A - guaranteed by forwarding reference syntax'''
depends_on = ['for_loop_range_impl_effect_forwards_body_parameter_e5f6a7b8', 'ctrl_r_conversion_operator_anti_pattern_use_after_move_a9d4f7e2', 'for_loop_range_impl_effect_forwards_range_parameter_a9b0c1d2', 'extract_constraint_type_r_moveable_f6c8d2e4', 'ctrl_r_conversion_operator_effect_move_semantics_143', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_expr_cast_lvalue_result_d4e8a1c3', 'cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_basic_lval_temp_materialization_b4e9f1c5']
reviewed = true

[[axioms]]
id = "for_loop_range_impl_effect_unrolling_optimization_b9c0d1e2"
content = '''Loop is unrolled by factor N, processing N consecutive elements in inner loop before advancing by N, potentially improving instruction-level parallelism'''
formal_spec = '''unroll_factor = N && processes_consecutive_elements_in_chunks(N) && potential_ilp_improvement'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "for_loop_range_impl"
header = "ilp_for/detail/loops_ilp.hpp"
signature = '''void for_loop_range_impl(Range&& range, F&& body)'''
axiom_type = "effect"
on_violation = '''N/A - optimization guarantee, not correctness requirement'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_range_untyped_impl_precond_range_sized_a1b2c3d4"
content = '''Range must satisfy std::ranges::sized_range to support std::ranges::size(range)'''
formal_spec = '''valid_expr(std::ranges::size(range)) && models<sized_range>(Range)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_range_untyped_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResult for_loop_range_untyped_impl(Range&& range, F&& body)'''
axiom_type = "precondition"
on_violation = '''Compilation error: std::ranges::size(range) ill-formed'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "for_loop_range_untyped_impl_precond_iterator_random_access_b2c3d4e5"
content = '''Iterator returned by std::ranges::begin(range) must support random access (subscript operator)'''
formal_spec = '''it = std::ranges::begin(range) => models<random_access_iterator>(decltype(it)) && valid_expr(it[index])'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_range_untyped_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResult for_loop_range_untyped_impl(Range&& range, F&& body)'''
axiom_type = "precondition"
on_violation = '''Compilation error: subscript operator not supported'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_over_match_oper_no_class_enum_builtin_f1a2b3c4', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_over_match_oper_fallback_builtin_comma_addr_arrow_b3c4d5e6', 'c11_cpp_translation_name_syntax_operation_018c4422', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'for_loop_range_impl_precond_iterator_random_access_d7e8f9a0', 'for_loop_range_impl_anti_pattern_non_random_access_e5f6a7b8', 'for_loop_range_ret_simple_impl_precond_random_access_e5f6a7b8']
reviewed = true

[[axioms]]
id = "for_loop_range_untyped_impl_precond_body_callable_c3d4e5f6"
content = '''Body must be callable with signature (auto&&, ForCtrl&)'''
formal_spec = '''is_invocable<F, decltype(it[0]), ForCtrl&>'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "for_loop_range_untyped_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResult for_loop_range_untyped_impl(Range&& range, F&& body)'''
axiom_type = "precondition"
on_violation = '''Compilation error: body cannot be invoked with required arguments'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_range_untyped_impl_precond_n_valid_d4e5f6a7"
content = '''Template parameter N must be >= 1 (validated at compile-time)'''
formal_spec = '''N >= 1'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_range_untyped_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResult for_loop_range_untyped_impl(Range&& range, F&& body)'''
axiom_type = "precondition"
on_violation = '''Static assertion failure in validate_unroll_factor<N>()'''
depends_on = ['cpp20_temp_expl_spec_unspecialized_enclosing_template_param_a7b8c9d0', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'for_loop_range_typed_precond_n_valid_offset_b3c4d5e6', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'for_loop_typed_constraint_return_type_r_b1c2d3e4']
reviewed = true

[[axioms]]
id = "for_loop_range_untyped_impl_effect_validate_first_e5f6a7b8"
content = '''First operation validates unroll factor N before any loop execution'''
formal_spec = '''first_operation == validate_unroll_factor<N>()'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_range_untyped_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResult for_loop_range_untyped_impl(Range&& range, F&& body)'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by function structure'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_range_untyped_impl_effect_range_eval_once_f6a7b8c9"
content = '''Range is evaluated exactly once via std::ranges::begin and std::ranges::size before loop execution'''
formal_spec = '''eval_count(std::ranges::begin(range)) == 1 && eval_count(std::ranges::size(range)) == 1 && eval_time == before_loop_start'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_range_untyped_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResult for_loop_range_untyped_impl(Range&& range, F&& body)'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by function structure'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "for_loop_range_untyped_impl_constraint_array_bounds_unrolled_a7b8c9d0"
content = '''Array access it[i + j] requires 0 <= i + j < size, protected by loop guards i + N <= size && j < N'''
formal_spec = '''it[i + j] => (i + N <= size) && (j < N) && (0 <= j) && (0 <= i) => (i + j < size)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_range_untyped_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResult for_loop_range_untyped_impl(Range&& range, F&& body)'''
axiom_type = "constraint"
on_violation = '''Undefined behavior: out-of-bounds iterator subscript'''
depends_on = ['cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'for_loop_range_untyped_impl_constraint_array_bounds_remainder_b8c9d0e1', 'for_loop_range_typed_impl_constraint_array_access_inner_n7o8p9q0', 'for_loop_range_typed_impl_constraint_array_access_remainder_r1s2t3u4', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "for_loop_range_untyped_impl_constraint_array_bounds_remainder_b8c9d0e1"
content = '''Array access it[i] requires 0 <= i < size, protected by loop guard i < size'''
formal_spec = '''it[i] => (i < size) && (i >= 0) => valid_subscript(it, i)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_range_untyped_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResult for_loop_range_untyped_impl(Range&& range, F&& body)'''
axiom_type = "constraint"
on_violation = '''Undefined behavior: out-of-bounds iterator subscript'''
depends_on = ['cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'for_loop_range_typed_impl_constraint_array_access_inner_n7o8p9q0', 'for_loop_range_typed_impl_constraint_array_access_remainder_r1s2t3u4', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'for_loop_range_impl_constraint_array_access_bounds_inner_loop_e9f0a1b2']
reviewed = true

[[axioms]]
id = "for_loop_range_untyped_impl_effect_body_invocations_c9d0e1f2"
content = '''Body is invoked exactly size times (once per element) unless early return via ctrl.ok == false'''
formal_spec = '''size = std::ranges::size(range) => invocation_count(body) == size || (exists i: !ctrl.ok after body(it[i], ctrl))'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "for_loop_range_untyped_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResult for_loop_range_untyped_impl(Range&& range, F&& body)'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by loop structure'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_range_untyped_impl_effect_ctrl_mutation_d0e1f2a3"
content = '''ForCtrl object is passed by reference to body, allowing body to signal early termination via ctrl.ok = false'''
formal_spec = '''body(it[idx], ctrl) => can_mutate(ctrl) && (ctrl.ok == false => early_return)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_range_untyped_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResult for_loop_range_untyped_impl(Range&& range, F&& body)'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by parameter passing'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_range_untyped_impl_postcond_normal_return_e1f2a3b4"
content = '''If all body invocations complete with ctrl.ok == true, returns ForResult{false, {}}'''
formal_spec = '''forall i in [0, size): ctrl.ok == true after body(it[i], ctrl) => returns ForResult{return_set: false, storage: {}}'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_range_untyped_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResult for_loop_range_untyped_impl(Range&& range, F&& body)'''
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed by function logic'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_range_untyped_impl_postcond_early_return_f2a3b4c5"
content = '''If any body invocation sets ctrl.ok = false, returns ForResult{ctrl.return_set, std::move(ctrl.storage)} immediately'''
formal_spec = '''exists i: ctrl.ok == false after body(it[i], ctrl) => returns ForResult{ctrl.return_set, std::move(ctrl.storage)} && no further body invocations'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_range_untyped_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResult for_loop_range_untyped_impl(Range&& range, F&& body)'''
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed by conditional early return'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_range_untyped_impl_invariant_loop_bounds_a3b4c5d6"
content = '''Loop invariant: 0 <= i <= size throughout execution'''
formal_spec = '''at_any_point_in_execution => (0 <= i) && (i <= size)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_range_untyped_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResult for_loop_range_untyped_impl(Range&& range, F&& body)'''
axiom_type = "invariant"
on_violation = '''N/A - guaranteed by loop structure'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_range_untyped_impl_invariant_unrolled_bounds_b4c5d6e7"
content = '''In unrolled loop: i + N <= size at loop entry, ensuring all N iterations are valid'''
formal_spec = '''in_unrolled_loop => i + N <= size'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_range_untyped_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResult for_loop_range_untyped_impl(Range&& range, F&& body)'''
axiom_type = "invariant"
on_violation = '''N/A - guaranteed by loop condition'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_range_untyped_impl_effect_storage_move_c5d6e7f8"
content = '''On early return, ctrl.storage is moved into result, leaving ctrl.storage in valid but unspecified state'''
formal_spec = '''ctrl.ok == false => returns ForResult{ctrl.return_set, std::move(ctrl.storage)} && post(valid_but_unspecified(ctrl.storage))'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_range_untyped_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResult for_loop_range_untyped_impl(Range&& range, F&& body)'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by std::move semantics'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_range_untyped_impl_exception_validate_propagates_d6e7f8a9"
content = '''If validate_unroll_factor<N>() throws, exception propagates before any loop execution'''
formal_spec = '''validate_unroll_factor<N>() throws E => for_loop_range_untyped_impl throws E && no_body_invocations'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_range_untyped_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResult for_loop_range_untyped_impl(Range&& range, F&& body)'''
axiom_type = "exception"
on_violation = '''N/A - exception propagation guaranteed'''
depends_on = ['cpp20_except_throw_destruction_ordering_d5e1c7b9', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_except_throw_destruction_after_handler_exit_c4a9f2e6', 'cpp20_except_throw_uncaught_after_init_before_activation_1c8e5a4b', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "for_loop_range_untyped_impl_exception_body_propagates_e7f8a9b0"
content = '''If body throws exception, it propagates immediately to caller'''
formal_spec = '''body(it[i], ctrl) throws E => for_loop_range_untyped_impl throws E && no further body invocations'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "for_loop_range_untyped_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResult for_loop_range_untyped_impl(Range&& range, F&& body)'''
axiom_type = "exception"
on_violation = '''N/A - exception propagation guaranteed'''
depends_on = ['cpp20_except_throw_destruction_ordering_d5e1c7b9', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_except_throw_destruction_after_handler_exit_c4a9f2e6', 'cpp20_except_throw_uncaught_after_init_before_activation_1c8e5a4b', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "for_loop_range_untyped_impl_anti_pattern_large_n_f8a9b0c1"
content = '''Avoid using N > 16 without careful consideration; large unroll factors cause code bloat'''
formal_spec = '''caution_recommended: N > 16'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_range_untyped_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResult for_loop_range_untyped_impl(Range&& range, F&& body)'''
axiom_type = "anti_pattern"
on_violation = '''Warning issued at compile-time, potential performance degradation'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_range_untyped_impl_complexity_linear_a9b0c1d2"
content = '''Time complexity: O(size) where size = std::ranges::size(range), with exactly size body invocations (unless early termination)'''
formal_spec = '''time_complexity == O(size) && invocation_count(body) <= size'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_range_untyped_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResult for_loop_range_untyped_impl(Range&& range, F&& body)'''
axiom_type = "complexity"
on_violation = '''N/A - complexity guarantee'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "for_loop_range_untyped_impl_complexity_space_constant_b0c1d2e3"
content = '''Space complexity: O(1) excluding space used by body callable'''
formal_spec = '''space_complexity == O(1) + space(body)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_range_untyped_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResult for_loop_range_untyped_impl(Range&& range, F&& body)'''
axiom_type = "complexity"
on_violation = '''N/A - complexity guarantee'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_range_untyped_impl_constraint_forwarding_ref_c1d2e3f4"
content = '''Range&& is a forwarding reference accepting both lvalue and rvalue ranges'''
formal_spec = '''is_forwarding_reference<Range&&> && accepts_lvalue(Range&&) && accepts_rvalue(Range&&)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_range_untyped_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResult for_loop_range_untyped_impl(Range&& range, F&& body)'''
axiom_type = "constraint"
on_violation = '''N/A - template parameter deduction'''
depends_on = ['for_loop_range_impl_effect_forwards_body_parameter_e5f6a7b8', 'for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'ctrl_r_conversion_operator_anti_pattern_use_after_move_a9d4f7e2', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4', 'for_loop_range_impl_effect_forwards_range_parameter_a9b0c1d2', 'ctrl_r_conversion_operator_effect_move_semantics_143', 'extract_constraint_type_r_moveable_f6c8d2e4', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_expr_cast_lvalue_result_d4e8a1c3', 'cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_basic_lval_temp_materialization_b4e9f1c5']
reviewed = true

[[axioms]]
id = "for_loop_range_untyped_impl_constraint_body_forwarding_ref_d2e3f4a5"
content = '''F&& is a forwarding reference accepting both lvalue and rvalue callables'''
formal_spec = '''is_forwarding_reference<F&&> && accepts_lvalue(F&&) && accepts_rvalue(F&&)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_range_untyped_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResult for_loop_range_untyped_impl(Range&& range, F&& body)'''
axiom_type = "constraint"
on_violation = '''N/A - template parameter deduction'''
depends_on = ['for_loop_range_impl_effect_forwards_body_parameter_e5f6a7b8', 'ctrl_r_conversion_operator_anti_pattern_use_after_move_a9d4f7e2', 'for_loop_range_impl_effect_forwards_range_parameter_a9b0c1d2', 'extract_constraint_type_r_moveable_f6c8d2e4', 'ctrl_r_conversion_operator_effect_move_semantics_143', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_expr_cast_lvalue_result_d4e8a1c3', 'cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_basic_lval_temp_materialization_b4e9f1c5']
reviewed = true

[[axioms]]
id = "for_loop_range_untyped_impl_effect_unroll_optimization_e3f4a5b6"
content = '''Loop is unrolled by factor N: processes N elements per outer iteration where possible, with remainder loop for elements beyond last full unrolled block'''
formal_spec = '''unrolled_iterations = floor(size / N) && remainder_iterations = size % N && total_body_calls = size'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_range_untyped_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResult for_loop_range_untyped_impl(Range&& range, F&& body)'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by loop structure'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_range_typed_impl_precond_range_valid_a1b2c3d4"
content = '''Range must be a valid range type supporting std::ranges::begin and std::ranges::size'''
formal_spec = '''valid_expr(std::ranges::begin(range)) && valid_expr(std::ranges::size(range))'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "for_loop_range_typed_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_range_typed_impl(Range&& range, F&& body)'''
axiom_type = "precondition"
on_violation = '''Compilation error if range does not satisfy range concepts'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "for_loop_range_typed_impl_precond_iterator_random_access_e5f6a7b8"
content = '''Iterator returned by std::ranges::begin(range) must support subscript operator (random_access_iterator)'''
formal_spec = '''it = std::ranges::begin(range) => models<random_access_iterator>(decltype(it)) && valid_expr(it[index])'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "for_loop_range_typed_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_range_typed_impl(Range&& range, F&& body)'''
axiom_type = "precondition"
on_violation = '''Compilation error if iterator does not support operator[]'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_over_match_oper_no_class_enum_builtin_f1a2b3c4', 'for_loop_range_untyped_impl_precond_iterator_random_access_b2c3d4e5', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_over_match_oper_fallback_builtin_comma_addr_arrow_b3c4d5e6', 'c11_cpp_translation_name_syntax_operation_018c4422', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'for_loop_range_impl_precond_iterator_random_access_d7e8f9a0', 'for_loop_range_ret_simple_impl_precond_random_access_e5f6a7b8']
reviewed = true

[[axioms]]
id = "for_loop_range_typed_impl_precond_body_callable_typed_f9g0h1i2"
content = '''Body must be callable with signature (decltype(it[i]), ForCtrlTyped<R>&)'''
formal_spec = '''is_invocable<F, decltype(it[0]), ForCtrlTyped<R>&>'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "for_loop_range_typed_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_range_typed_impl(Range&& range, F&& body)'''
axiom_type = "precondition"
on_violation = '''Compilation error if body cannot be invoked with required parameters'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_range_typed_impl_precond_unroll_factor_valid_j3k4l5m6"
content = '''Template parameter N must be >= 1 (validated by validate_unroll_factor<N>())'''
formal_spec = '''N >= 1'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "for_loop_range_typed_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_range_typed_impl(Range&& range, F&& body)'''
axiom_type = "precondition"
on_violation = '''Static assertion failure if N < 1'''
depends_on = ['cpp20_temp_expl_spec_unspecialized_enclosing_template_param_a7b8c9d0', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'for_loop_range_typed_precond_n_valid_offset_b3c4d5e6', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'for_loop_typed_constraint_return_type_r_b1c2d3e4']
reviewed = true

[[axioms]]
id = "for_loop_range_typed_impl_constraint_array_access_inner_n7o8p9q0"
content = '''Array access it[i + j] requires (i + j) < size, protected by loop guards (i + N <= size) && (j < N)'''
formal_spec = '''it[i + j] && (i + N <= size) && (j < N) => (i + j < size)'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "for_loop_range_typed_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_range_typed_impl(Range&& range, F&& body)'''
axiom_type = "constraint"
on_violation = '''Undefined behavior if bounds violated (iterator subscript out of range)'''
depends_on = ['cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'for_loop_range_untyped_impl_constraint_array_bounds_remainder_b8c9d0e1', 'for_loop_range_typed_impl_constraint_array_access_remainder_r1s2t3u4', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'for_loop_range_impl_constraint_array_access_bounds_inner_loop_e9f0a1b2']
reviewed = true

[[axioms]]
id = "for_loop_range_typed_impl_constraint_array_access_remainder_r1s2t3u4"
content = '''Array access it[i] requires i < size, protected by loop guard (i < size)'''
formal_spec = '''it[i] && (i < size) => valid_access'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "for_loop_range_typed_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_range_typed_impl(Range&& range, F&& body)'''
axiom_type = "constraint"
on_violation = '''Undefined behavior if bounds violated (iterator subscript out of range)'''
depends_on = ['cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'for_loop_range_typed_impl_constraint_array_access_inner_n7o8p9q0', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'for_loop_range_impl_constraint_array_access_bounds_inner_loop_e9f0a1b2', 'for_loop_range_impl_constraint_array_access_bounds_remainder_loop_a7b8c9d0']
reviewed = true

[[axioms]]
id = "for_loop_range_typed_impl_invariant_ctrl_consistency_v5w6x7y8"
content = '''ForCtrlTyped<R> ctrl maintains consistent state: if !ctrl.ok, then ctrl.return_set is true and ctrl.storage contains valid return value'''
formal_spec = '''!ctrl.ok => ctrl.return_set && valid(ctrl.storage)'''
layer = "library"
confidence = 0.85
source_file = ""
source_module = ""
function = "for_loop_range_typed_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_range_typed_impl(Range&& range, F&& body)'''
axiom_type = "invariant"
on_violation = '''Logic error, invalid control flow state'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_range_typed_impl_invariant_loop_progress_z9a0b1c2"
content = '''Loop index i is monotonically increasing and satisfies 0 <= i <= size throughout execution'''
formal_spec = '''0 <= i <= size && (i_next >= i_prev)'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "for_loop_range_typed_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_range_typed_impl(Range&& range, F&& body)'''
axiom_type = "invariant"
on_violation = '''Logic error, invalid loop bounds'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_range_typed_impl_effect_validates_unroll_d3e4f5g6"
content = '''First operation validates unroll factor N via validate_unroll_factor<N>() before any loop execution'''
formal_spec = '''first_operation == validate_unroll_factor<N>() && executes_before_all_other_operations'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "for_loop_range_typed_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_range_typed_impl(Range&& range, F&& body)'''
axiom_type = "effect"
on_violation = '''N/A - compile-time validation'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_range_typed_impl_effect_evaluates_range_once_h7i8j9k0"
content = '''Range expression is evaluated exactly once via std::ranges::begin and std::ranges::size before loop begins'''
formal_spec = '''eval_count(std::ranges::begin(range)) == 1 && eval_count(std::ranges::size(range)) == 1 && eval_time == before_loop_start'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "for_loop_range_typed_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_range_typed_impl(Range&& range, F&& body)'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by implementation'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "for_loop_range_typed_impl_effect_invokes_body_unrolled_l1m2n3o4"
content = '''Body is invoked once per element in range with unrolling factor N in inner loop, stopping early if ctrl.ok becomes false'''
formal_spec = '''invocation_count(body) == min(size, first_i_where_not_ctrl_ok) && unroll_factor == N'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "for_loop_range_typed_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_range_typed_impl(Range&& range, F&& body)'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by implementation'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8"
content = '''Range parameter is perfectly forwarded preserving its value category (lvalue/rvalue)'''
formal_spec = '''forwards<Range>(range) => preserves_value_category<Range>(range)'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "for_loop_range_typed_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_range_typed_impl(Range&& range, F&& body)'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by implementation'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'ctrl_r_conversion_operator_anti_pattern_use_after_move_a9d4f7e2', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4', 'ctrl_r_conversion_operator_effect_move_semantics_143', 'extract_constraint_type_r_moveable_f6c8d2e4', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'ilp_for_range_constraint_range_parenthesized_e9a2f4b6', 'cpp20_expr_cast_lvalue_result_d4e8a1c3', 'cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_basic_lval_temp_materialization_b4e9f1c5']
reviewed = true

[[axioms]]
id = "for_loop_range_typed_impl_postcond_early_return_typed_t9u0v1w2"
content = '''If body sets ctrl.ok to false, function returns ForResultTyped<R>{true, moved ctrl.storage} immediately'''
formal_spec = '''!ctrl.ok => return ForResultTyped<R>{ctrl.return_set, std::move(ctrl.storage)}'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "for_loop_range_typed_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_range_typed_impl(Range&& range, F&& body)'''
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed by implementation'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_range_typed_impl_postcond_normal_completion_x3y4z5a6"
content = '''If all iterations complete without ctrl.ok becoming false, returns ForResultTyped<R>{false, {}}'''
formal_spec = '''forall i in [0, size): ctrl.ok_after_body(i) => return ForResultTyped<R>{false, {}}'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "for_loop_range_typed_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_range_typed_impl(Range&& range, F&& body)'''
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed by implementation'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_range_typed_impl_postcond_all_elements_processed_b7c8d9e0"
content = '''Body is invoked exactly once for each element in range [0, size) unless early termination via ctrl.ok'''
formal_spec = '''(ctrl.ok remains true) => (invocation_count(body) == size) && (forall i in [0, size): body_invoked_with(it[i]))'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "for_loop_range_typed_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_range_typed_impl(Range&& range, F&& body)'''
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed by implementation'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "for_loop_range_typed_impl_exception_validate_propagates_f1g2h3i4"
content = '''If validate_unroll_factor<N>() fails (static_assert), compilation fails before runtime'''
formal_spec = '''validate_unroll_factor<N>() fails => compilation_error && no_runtime_execution'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "for_loop_range_typed_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_range_typed_impl(Range&& range, F&& body)'''
axiom_type = "exception"
on_violation = '''Compilation error'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_range_typed_impl_exception_body_propagates_j5k6l7m8"
content = '''If body throws exception E, exception propagates to caller and loop terminates'''
formal_spec = '''body(it[i], ctrl) throws E => for_loop_range_typed_impl throws E && loop_terminates'''
layer = "library"
confidence = 0.85
source_file = ""
source_module = ""
function = "for_loop_range_typed_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_range_typed_impl(Range&& range, F&& body)'''
axiom_type = "exception"
on_violation = '''Exception propagates to caller'''
depends_on = ['cpp20_except_throw_destruction_ordering_d5e1c7b9', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_except_throw_destruction_after_handler_exit_c4a9f2e6', 'cpp20_except_throw_uncaught_after_init_before_activation_1c8e5a4b', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "for_loop_range_typed_impl_exception_range_ops_propagate_n9o0p1q2"
content = '''If std::ranges::begin or std::ranges::size throw, exception propagates before any loop execution'''
formal_spec = '''(std::ranges::begin(range) throws E || std::ranges::size(range) throws E) => for_loop_range_typed_impl throws E && no_body_invocations'''
layer = "library"
confidence = 0.85
source_file = ""
source_module = ""
function = "for_loop_range_typed_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_range_typed_impl(Range&& range, F&& body)'''
axiom_type = "exception"
on_violation = '''Exception propagates to caller'''
depends_on = ['cpp20_except_throw_destruction_ordering_d5e1c7b9', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_except_throw_destruction_after_handler_exit_c4a9f2e6', 'cpp20_except_throw_uncaught_after_init_before_activation_1c8e5a4b', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "for_loop_range_typed_impl_anti_pattern_large_unroll_r3s4t5u6"
content = '''Avoid using N > 16 without careful consideration; large unroll factors cause code bloat and may reduce performance'''
formal_spec = '''N > 16 => caution_recommended && warn_large_unroll_factor_issued'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "for_loop_range_typed_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_range_typed_impl(Range&& range, F&& body)'''
axiom_type = "anti_pattern"
on_violation = '''Compile-time warning issued, performance may degrade'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_range_typed_impl_complexity_time_linear_v7w8x9y0"
content = '''Time complexity is O(size) where size = std::ranges::size(range), with constant factor improvement from unrolling'''
formal_spec = '''time_complexity == O(size) && unroll_speedup_factor <= N'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "for_loop_range_typed_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_range_typed_impl(Range&& range, F&& body)'''
axiom_type = "complexity"
on_violation = '''N/A - complexity guarantee'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "for_loop_range_typed_impl_complexity_space_constant_z1a2b3c4"
content = '''Space complexity is O(1) excluding storage in ForCtrlTyped<R> which depends on R'''
formal_spec = '''space_complexity == O(1) + sizeof(ForCtrlTyped<R>)'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "for_loop_range_typed_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_range_typed_impl(Range&& range, F&& body)'''
axiom_type = "complexity"
on_violation = '''N/A - complexity guarantee'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_range_typed_impl_constraint_size_representable_d5e6f7g8"
content = '''Range size must be representable as std::size_t without overflow'''
formal_spec = '''size = std::ranges::size(range) => size <= std::numeric_limits<std::size_t>::max()'''
layer = "library"
confidence = 0.85
source_file = ""
source_module = ""
function = "for_loop_range_typed_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_range_typed_impl(Range&& range, F&& body)'''
axiom_type = "constraint"
on_violation = '''Undefined behavior or truncation if size exceeds std::size_t capacity'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "for_loop_range_typed_impl_constraint_addition_no_overflow_h9i0j1k2"
content = '''Addition i + j and i + N must not overflow std::size_t (guaranteed by loop guards)'''
formal_spec = '''(i + N <= size) && (j < N) => (i + j < std::numeric_limits<std::size_t>::max()) && no_overflow'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "for_loop_range_typed_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_range_typed_impl(Range&& range, F&& body)'''
axiom_type = "constraint"
on_violation = '''Undefined behavior if overflow occurs (prevented by loop structure)'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_range_ret_simple_impl_precond_range_valid_a1b2c3d4"
content = '''Range must be a valid range type supporting std::ranges::begin, std::ranges::end, and std::ranges::size'''
formal_spec = '''valid_expr(std::ranges::begin(range)) && valid_expr(std::ranges::end(range)) && valid_expr(std::ranges::size(range))'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "for_loop_range_ret_simple_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''auto for_loop_range_ret_simple_impl(Range&& range, F&& body)'''
axiom_type = "precondition"
on_violation = '''compilation error: ill-formed if range does not satisfy requirements'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "for_loop_range_ret_simple_impl_precond_random_access_e5f6a7b8"
content = '''Iterator returned by std::ranges::begin(range) must support random access (subscript operator it[index])'''
formal_spec = '''models<random_access_iterator>(decltype(std::ranges::begin(range))) && valid_expr(it[i]) for all valid i'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_range_ret_simple_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''auto for_loop_range_ret_simple_impl(Range&& range, F&& body)'''
axiom_type = "precondition"
on_violation = '''compilation error: ill-formed subscript expression'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_over_match_oper_no_class_enum_builtin_f1a2b3c4', 'for_loop_range_untyped_impl_precond_iterator_random_access_b2c3d4e5', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_over_match_oper_fallback_builtin_comma_addr_arrow_b3c4d5e6', 'c11_cpp_translation_name_syntax_operation_018c4422', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'for_loop_range_impl_precond_iterator_random_access_d7e8f9a0', 'for_loop_range_impl_anti_pattern_non_random_access_e5f6a7b8']
reviewed = true

[[axioms]]
id = "for_loop_range_ret_simple_impl_precond_body_callable_f7g8h9i0"
content = '''Body must be callable with signature (range_reference_t<Range>, Sentinel) returning R'''
formal_spec = '''is_invocable<F, std::ranges::range_reference_t<Range>, Sentinel> && std::is_same_v<std::invoke_result_t<F, std::ranges::range_reference_t<Range>, Sentinel>, R>'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "for_loop_range_ret_simple_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''auto for_loop_range_ret_simple_impl(Range&& range, F&& body)'''
axiom_type = "precondition"
on_violation = '''compilation error: ill-formed function invocation'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "for_loop_range_ret_simple_impl_precond_n_valid_j1k2l3m4"
content = '''Template parameter N must be >= 1 (validated by validate_unroll_factor<N>())'''
formal_spec = '''N >= 1'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_range_ret_simple_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''auto for_loop_range_ret_simple_impl(Range&& range, F&& body)'''
axiom_type = "precondition"
on_violation = '''compilation error: static_assert failure in validate_unroll_factor'''
depends_on = ['cpp20_temp_expl_spec_unspecialized_enclosing_template_param_a7b8c9d0', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'for_loop_range_typed_precond_n_valid_offset_b3c4d5e6', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'for_loop_typed_constraint_return_type_r_b1c2d3e4']
reviewed = true

[[axioms]]
id = "for_loop_range_ret_simple_impl_effect_validates_n_n5o6p7q8"
content = '''First operation validates unroll factor N via validate_unroll_factor<N>(), potentially issuing warning if N > 16'''
formal_spec = '''first_operation == validate_unroll_factor<N>() && (N > 16 => warn_large_unroll_factor<N>() invoked)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_range_ret_simple_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''auto for_loop_range_ret_simple_impl(Range&& range, F&& body)'''
axiom_type = "effect"
on_violation = '''N/A - always executed'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_range_ret_simple_impl_effect_forwards_range_r9s0t1u2"
content = '''Perfectly forwards range parameter preserving value category (rvalue ranges moved, lvalue ranges referenced)'''
formal_spec = '''std::forward<Range>(range) => (is_rvalue_ref<Range> ? move(range) : lvalue_ref(range))'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "for_loop_range_ret_simple_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''auto for_loop_range_ret_simple_impl(Range&& range, F&& body)'''
axiom_type = "effect"
on_violation = '''N/A - forwarding reference semantics'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'ctrl_r_conversion_operator_anti_pattern_use_after_move_a9d4f7e2', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4', 'ctrl_r_conversion_operator_effect_move_semantics_143', 'extract_constraint_type_r_moveable_f6c8d2e4', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_expr_cast_lvalue_result_d4e8a1c3', 'cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_basic_lval_temp_materialization_b4e9f1c5']
reviewed = true

[[axioms]]
id = "for_loop_range_ret_simple_impl_effect_evaluates_range_once_v3w4x5y6"
content = '''Range expression is evaluated exactly once before loop begins (range-for semantics)'''
formal_spec = '''eval_count(range) == 1 && eval_time(range) == before_loop_start'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "for_loop_range_ret_simple_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''auto for_loop_range_ret_simple_impl(Range&& range, F&& body)'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by design'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "for_loop_range_ret_simple_impl_constraint_array_access_i_j_z7a8b9c0"
content = '''Array access it[i + j] requires 0 <= i + j < size, guaranteed by loop guard i + N <= size && j < N'''
formal_spec = '''(i + N <= size) && (j < N) => (i + j < size) && (i + j >= 0)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_range_ret_simple_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''auto for_loop_range_ret_simple_impl(Range&& range, F&& body)'''
axiom_type = "constraint"
on_violation = '''undefined behavior: out-of-bounds access (prevented by loop guards)'''
depends_on = ['cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'for_loop_range_untyped_impl_constraint_array_bounds_remainder_b8c9d0e1', 'for_loop_range_typed_impl_constraint_array_access_inner_n7o8p9q0', 'for_loop_range_typed_impl_constraint_array_access_remainder_r1s2t3u4', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "for_loop_range_ret_simple_impl_constraint_array_access_i_d1e2f3g4"
content = '''Array access it[i] in remainder loop requires 0 <= i < size, guaranteed by loop guard i < size'''
formal_spec = '''(i < size) && (i >= 0) => valid_access(it[i])'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_range_ret_simple_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''auto for_loop_range_ret_simple_impl(Range&& range, F&& body)'''
axiom_type = "constraint"
on_violation = '''undefined behavior: out-of-bounds access (prevented by loop guard)'''
depends_on = ['cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'for_loop_range_untyped_impl_constraint_array_bounds_remainder_b8c9d0e1', 'for_loop_range_typed_impl_constraint_array_access_inner_n7o8p9q0', 'for_loop_range_typed_impl_constraint_array_access_remainder_r1s2t3u4', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "for_loop_range_ret_simple_impl_constraint_matches_bounds_h5i6j7k8"
content = '''Array access matches[j] requires 0 <= j < N, guaranteed by loop guard j < N'''
formal_spec = '''(j < N) && (j >= 0) => valid_access(matches[j])'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_range_ret_simple_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''auto for_loop_range_ret_simple_impl(Range&& range, F&& body)'''
axiom_type = "constraint"
on_violation = '''undefined behavior: out-of-bounds access (prevented by loop guard)'''
depends_on = ['cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'for_loop_range_untyped_impl_constraint_array_bounds_remainder_b8c9d0e1', 'for_loop_range_typed_impl_constraint_array_access_inner_n7o8p9q0', 'for_loop_range_typed_impl_constraint_array_access_remainder_r1s2t3u4', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "for_loop_range_ret_simple_impl_constraint_results_bounds_l9m0n1o2"
content = '''Array access results[j] requires 0 <= j < N, guaranteed by loop guard j < N'''
formal_spec = '''(j < N) && (j >= 0) => valid_access(results[j])'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_range_ret_simple_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''auto for_loop_range_ret_simple_impl(Range&& range, F&& body)'''
axiom_type = "constraint"
on_violation = '''undefined behavior: out-of-bounds access (prevented by loop guard)'''
depends_on = ['cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'for_loop_range_untyped_impl_constraint_array_bounds_remainder_b8c9d0e1', 'for_loop_range_typed_impl_constraint_array_access_inner_n7o8p9q0', 'for_loop_range_typed_impl_constraint_array_access_remainder_r1s2t3u4', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "for_loop_range_ret_simple_impl_invariant_i_bounds_p3q4r5s6"
content = '''Loop invariant: at loop entry and after each iteration, 0 <= i <= size && i % N == 0 (for main loop)'''
formal_spec = '''at_loop_iteration(i) => (0 <= i) && (i <= size) && ((i % N == 0) || (i + N > size))'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "for_loop_range_ret_simple_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''auto for_loop_range_ret_simple_impl(Range&& range, F&& body)'''
axiom_type = "invariant"
on_violation = '''N/A - maintained by loop structure'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_range_ret_simple_impl_invariant_j_bounds_t7u8v9w0"
content = '''Loop invariant: inner loop counter j satisfies 0 <= j < N throughout execution'''
formal_spec = '''at_inner_loop_iteration(j) => (0 <= j) && (j < N)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_range_ret_simple_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''auto for_loop_range_ret_simple_impl(Range&& range, F&& body)'''
axiom_type = "invariant"
on_violation = '''N/A - maintained by loop structure'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_range_ret_simple_impl_effect_unrolled_execution_x1y2z3a4"
content = '''Executes body in unrolled batches of N iterations, then handles remainder sequentially'''
formal_spec = '''total_body_calls = size && unrolled_calls = (size / N) * N && sequential_calls = size % N'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "for_loop_range_ret_simple_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''auto for_loop_range_ret_simple_impl(Range&& range, F&& body)'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed behavior'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_range_ret_simple_impl_effect_early_return_bool_b5c6d7e8"
content = '''When R is bool, returns iterator to first element where body returns true, or end_it if none found'''
formal_spec = '''(std::is_same_v<R, bool>) => (exists j: body(it[j], end_it) == true => return it + j) || (all j: body(it[j], end_it) == false => return end_it)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_range_ret_simple_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''auto for_loop_range_ret_simple_impl(Range&& range, F&& body)'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed behavior'''
depends_on = ['for_loop_range_typed_impl_precond_iterator_random_access_e5f6a7b8', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'for_loop_range_untyped_impl_precond_iterator_random_access_b2c3d4e5', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'for_loop_range_impl_anti_pattern_non_random_access_e5f6a7b8', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "for_loop_range_ret_simple_impl_effect_early_return_optional_f9g0h1i2"
content = '''When R is optional-like, returns first non-empty optional result from body, or empty R{} if none found'''
formal_spec = '''(is_optional_v<R>) => (exists j: body(it[j], end_it).has_value() => return body(it[j], end_it)) || (all j: !body(it[j], end_it).has_value() => return R{})'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_range_ret_simple_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''auto for_loop_range_ret_simple_impl(Range&& range, F&& body)'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed behavior'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_range_ret_simple_impl_effect_early_return_sentinel_j3k4l5m6"
content = '''When R is neither bool nor optional, returns first result != end_it, or static_cast<R>(end_it) if none found'''
formal_spec = '''(!std::is_same_v<R, bool> && !is_optional_v<R>) => (exists j: body(it[j], end_it) != end_it => return body(it[j], end_it)) || (all j: body(it[j], end_it) == end_it => return static_cast<R>(end_it))'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_range_ret_simple_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''auto for_loop_range_ret_simple_impl(Range&& range, F&& body)'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed behavior'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_range_ret_simple_impl_effect_move_semantics_n7o8p9q0"
content = '''Returns matching result using std::move for efficiency when returning from unrolled batch'''
formal_spec = '''return_from_unrolled => return std::move(results[j])'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "for_loop_range_ret_simple_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''auto for_loop_range_ret_simple_impl(Range&& range, F&& body)'''
axiom_type = "effect"
on_violation = '''N/A - optimization, no correctness impact'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_range_ret_simple_impl_effect_static_cast_sentinel_r1s2t3u4"
content = '''Performs static_cast<R>(end_it) to convert sentinel to return type R when no match found'''
formal_spec = '''no_match && !is_optional_v<R> && !std::is_same_v<R, bool> => return static_cast<R>(end_it)'''
layer = "library"
confidence = 0.85
source_file = ""
source_module = ""
function = "for_loop_range_ret_simple_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''auto for_loop_range_ret_simple_impl(Range&& range, F&& body)'''
axiom_type = "effect"
on_violation = '''compilation error if static_cast<R>(Sentinel) is ill-formed'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_range_ret_simple_impl_postcond_result_valid_v5w6x7y8"
content = '''Returned value is either a successful match result or a sentinel/empty value indicating no match'''
formal_spec = '''return_value == (successful_match || no_match_sentinel) where no_match_sentinel = (is_bool ? end_it : is_optional ? R{} : static_cast<R>(end_it))'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "for_loop_range_ret_simple_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''auto for_loop_range_ret_simple_impl(Range&& range, F&& body)'''
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed by control flow'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_range_ret_simple_impl_postcond_body_invoked_z9a0b1c2"
content = '''Body has been invoked for all elements from index 0 to matching index (inclusive), or all elements if no match'''
formal_spec = '''(match_at_index(k) => body_invoked_for_indices(0, k)) || (no_match => body_invoked_for_indices(0, size - 1))'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "for_loop_range_ret_simple_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''auto for_loop_range_ret_simple_impl(Range&& range, F&& body)'''
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed by loop semantics'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_range_ret_simple_impl_exception_validate_propagates_d3e4f5g6"
content = '''If validate_unroll_factor<N>() throws exception E, it propagates before any loop execution'''
formal_spec = '''validate_unroll_factor<N>() throws E => for_loop_range_ret_simple_impl throws E && no_body_invocations_occur'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "for_loop_range_ret_simple_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''auto for_loop_range_ret_simple_impl(Range&& range, F&& body)'''
axiom_type = "exception"
on_violation = '''N/A - exception safety guarantee'''
depends_on = ['cpp20_except_throw_destruction_ordering_d5e1c7b9', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_except_throw_destruction_after_handler_exit_c4a9f2e6', 'cpp20_except_throw_uncaught_after_init_before_activation_1c8e5a4b', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "for_loop_range_ret_simple_impl_exception_body_propagates_h7i8j9k0"
content = '''If body throws exception E during iteration i, exception propagates immediately without processing remaining elements'''
formal_spec = '''body(it[i], end_it) throws E => for_loop_range_ret_simple_impl throws E && elements_after_i_not_processed'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "for_loop_range_ret_simple_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''auto for_loop_range_ret_simple_impl(Range&& range, F&& body)'''
axiom_type = "exception"
on_violation = '''N/A - exception safety guarantee'''
depends_on = ['cpp20_except_throw_destruction_ordering_d5e1c7b9', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_except_throw_destruction_after_handler_exit_c4a9f2e6', 'cpp20_except_throw_uncaught_after_init_before_activation_1c8e5a4b', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "for_loop_range_ret_simple_impl_exception_range_ops_propagate_l1m2n3o4"
content = '''If std::ranges::begin, end, or size throw exceptions, they propagate before loop execution'''
formal_spec = '''(std::ranges::begin(range) throws E || std::ranges::end(range) throws E || std::ranges::size(range) throws E) => for_loop_range_ret_simple_impl throws E && no_body_invocations'''
layer = "library"
confidence = 0.85
source_file = ""
source_module = ""
function = "for_loop_range_ret_simple_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''auto for_loop_range_ret_simple_impl(Range&& range, F&& body)'''
axiom_type = "exception"
on_violation = '''N/A - exception safety guarantee'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_range_ret_simple_impl_anti_pattern_excessive_n_p5q6r7s8"
content = '''Avoid using N > 16 without careful consideration; large unroll factors cause code bloat and may reduce performance'''
formal_spec = '''caution_recommended: N > 16'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_range_ret_simple_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''auto for_loop_range_ret_simple_impl(Range&& range, F&& body)'''
axiom_type = "anti_pattern"
on_violation = '''warning issued by validate_unroll_factor<N>()'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_range_ret_simple_impl_complexity_time_t9u0v1w2"
content = '''Time complexity is O(size) in worst case (no early return), best case O(1) (immediate match)'''
formal_spec = '''time_complexity = O(size) worst_case && O(1) best_case where size = std::ranges::size(range)'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "for_loop_range_ret_simple_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''auto for_loop_range_ret_simple_impl(Range&& range, F&& body)'''
axiom_type = "complexity"
on_violation = '''N/A - performance characteristic'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_range_ret_simple_impl_complexity_space_x3y4z5a6"
content = '''Space complexity is O(N) for temporary storage arrays (matches or results), independent of range size'''
formal_spec = '''space_complexity = O(N) where N is template parameter (unroll factor)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_range_ret_simple_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''auto for_loop_range_ret_simple_impl(Range&& range, F&& body)'''
axiom_type = "complexity"
on_violation = '''N/A - performance characteristic'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "for_loop_range_ret_simple_impl_constraint_static_cast_valid_b7c8d9e0"
content = '''When R is neither bool nor optional, static_cast<R>(end_it) must be well-formed (Sentinel must be convertible to R)'''
formal_spec = '''(!std::is_same_v<R, bool> && !is_optional_v<R>) => std::is_convertible_v<Sentinel, R> || static_cast_valid<R>(Sentinel)'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "for_loop_range_ret_simple_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''auto for_loop_range_ret_simple_impl(Range&& range, F&& body)'''
axiom_type = "constraint"
on_violation = '''compilation error: ill-formed static_cast'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_range_ret_simple_impl_constraint_return_type_convertible_f1g2h3i4"
content = '''All return paths must yield same type R (invoke_result_t matches return type for all branches)'''
formal_spec = '''std::is_same_v<decltype(return_bool_branch), decltype(return_optional_branch)> && std::is_same_v<decltype(return_optional_branch), decltype(return_sentinel_branch)>'''
layer = "library"
confidence = 0.85
source_file = ""
source_module = ""
function = "for_loop_range_ret_simple_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''auto for_loop_range_ret_simple_impl(Range&& range, F&& body)'''
axiom_type = "constraint"
on_violation = '''compilation error: inconsistent return types'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_range_ret_simple_impl_effect_ilp_optimization_j5k6l7m8"
content = '''Enables instruction-level parallelism by computing N results before checking any, allowing CPU to execute body calls in parallel'''
formal_spec = '''computation_phase_separated_from_checking_phase => enables_ilp && potential_speedup_from_parallel_execution'''
layer = "library"
confidence = 0.8
source_file = ""
source_module = ""
function = "for_loop_range_ret_simple_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''auto for_loop_range_ret_simple_impl(Range&& range, F&& body)'''
axiom_type = "effect"
on_violation = '''N/A - optimization technique'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_range_ret_simple_impl_invariant_no_overflow_n9o0p1q2"
content = '''Addition i + j and i + N cannot overflow: guaranteed by loop guards i + N <= size and j < N'''
formal_spec = '''(i + N <= size) && (j < N) => no_overflow(i + j) && no_overflow(i + N)'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "for_loop_range_ret_simple_impl"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''auto for_loop_range_ret_simple_impl(Range&& range, F&& body)'''
axiom_type = "invariant"
on_violation = '''undefined behavior if size_t overflows (prevented by guards)'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_precond_valid_range_a1b2c3d4"
content = '''start and end must form a valid range for the loop type, with start <= end for forward iteration'''
formal_spec = '''valid_range(start, end) && (start <= end)'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "for_loop"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResult for_loop(T start, T end, F&& body)'''
axiom_type = "precondition"
on_violation = '''undefined behavior or empty iteration'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "for_loop_precond_body_callable_b2c3d4e5"
content = '''body must be a valid callable object that can be invoked with loop iteration parameters'''
formal_spec = '''is_invocable<F, iteration_args...>(body)'''
layer = "library"
confidence = 0.85
source_file = ""
source_module = ""
function = "for_loop"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResult for_loop(T start, T end, F&& body)'''
axiom_type = "precondition"
on_violation = '''compilation error or undefined behavior'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_precond_n_positive_c3d4e5f6"
content = '''Template parameter N must be a positive integer >= 1 for loop unrolling factor'''
formal_spec = '''N >= 1'''
layer = "library"
confidence = 0.8
source_file = ""
source_module = ""
function = "for_loop"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResult for_loop(T start, T end, F&& body)'''
axiom_type = "precondition"
on_violation = '''compilation error or infinite loop'''
depends_on = ['cpp20_temp_expl_spec_unspecialized_enclosing_template_param_a7b8c9d0', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'for_loop_range_typed_precond_n_valid_offset_b3c4d5e6', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'for_loop_typed_constraint_return_type_r_b1c2d3e4']
reviewed = true

[[axioms]]
id = "for_loop_effect_delegates_to_impl_d4e5f6a7"
content = '''Delegates all iteration logic to detail::for_loop_untyped_impl<N> with perfect forwarding of body parameter'''
formal_spec = '''for_loop(start, end, body) => detail::for_loop_untyped_impl<N>(start, end, std::forward<F>(body))'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResult for_loop(T start, T end, F&& body)'''
axiom_type = "effect"
on_violation = '''N/A - implementation detail'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_effect_perfect_forward_body_e5f6g7h8"
content = '''Uses std::forward<F> to preserve the value category of body, enabling move semantics for rvalue references and maintaining lvalue references'''
formal_spec = '''is_rvalue_reference<F&&>(body) => std::forward<F>(body) preserves rvalue-ness; is_lvalue_reference<F&>(body) => std::forward<F>(body) preserves lvalue-ness'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResult for_loop(T start, T end, F&& body)'''
axiom_type = "effect"
on_violation = '''N/A - always applies'''
depends_on = ['ctrl_r_conversion_operator_anti_pattern_use_after_move_a9d4f7e2', 'ctrl_r_conversion_operator_effect_move_semantics_143', 'extract_constraint_type_r_moveable_f6c8d2e4', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_expr_cast_lvalue_result_d4e8a1c3', 'cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_basic_lval_temp_materialization_b4e9f1c5']
reviewed = true

[[axioms]]
id = "for_loop_postcond_returns_for_result_f6g7h8i9"
content = '''Returns ForResult object indicating loop completion status; if all iterations complete successfully, return_set is false and storage is default-constructed'''
formal_spec = '''all_iterations_successful => result.return_set == false && result.storage == default_constructed'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "for_loop"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResult for_loop(T start, T end, F&& body)'''
axiom_type = "postcondition"
on_violation = '''N/A - always returns ForResult'''
depends_on = ['cpp20_basic_life_vacuous_initialization_def_7c4e5d6a', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_list_copy_list_init_explicit_ctor_f2a3b4c5', 'cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "for_loop_effect_unroll_optimization_g7h8i9j0"
content = '''Loop unrolling by factor N enables instruction-level parallelism by processing iterations in blocks of N'''
formal_spec = '''iterations_processed = floor((end - start) / N) * N + ((end - start) % N)'''
layer = "library"
confidence = 0.85
source_file = ""
source_module = ""
function = "for_loop"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResult for_loop(T start, T end, F&& body)'''
axiom_type = "effect"
on_violation = '''N/A - optimization behavior'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_constraint_type_t_comparable_h8i9j0k1"
content = '''Type T must support comparison operators (<, <=, >, >=) for range validation and iteration'''
formal_spec = '''supports_comparison<T>(operator<, operator<=, operator>, operator>=)'''
layer = "library"
confidence = 0.8
source_file = ""
source_module = ""
function = "for_loop"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResult for_loop(T start, T end, F&& body)'''
axiom_type = "constraint"
on_violation = '''compilation error'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "for_loop_complexity_linear_iterations_i9j0k1l2"
content = '''Time complexity is O((end - start) * complexity(body)), where each iteration from start to end invokes body once'''
formal_spec = '''time_complexity = O((end - start) * T_body)'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "for_loop"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResult for_loop(T start, T end, F&& body)'''
axiom_type = "complexity"
on_violation = '''N/A - complexity guarantee'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_typed_precond_valid_range_a1b2c3d4"
content = '''start must be less than or equal to end to form a valid iteration range'''
formal_spec = '''start <= end'''
layer = "library"
confidence = 0.7
source_file = ""
source_module = ""
function = "for_loop_typed"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_typed(T start, T end, F&& body)'''
axiom_type = "precondition"
on_violation = '''Implementation-defined behavior: may iterate zero times if end < start, or may overflow if range is invalid'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "for_loop_typed_precond_no_overflow_a2b3c4d5"
content = '''The iteration range must not cause overflow when computing i + N during unrolled loop iterations'''
formal_spec = '''forall i in [start, end): i + static_cast<T>(N) does not overflow T'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "for_loop_typed"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_typed(T start, T end, F&& body)'''
axiom_type = "precondition"
on_violation = '''undefined behavior: signed integer overflow, or wrap-around for unsigned types'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "for_loop_typed_precond_body_callable_a3b4c5d6"
content = '''body must be callable with signature compatible with void(T) or return LoopControl'''
formal_spec = '''std::is_invocable_v<F, T> && (std::is_void_v<std::invoke_result_t<F, T>> || std::is_same_v<std::invoke_result_t<F, T>, LoopControl>)'''
layer = "library"
confidence = 0.85
source_file = ""
source_module = ""
function = "for_loop_typed"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_typed(T start, T end, F&& body)'''
axiom_type = "precondition"
on_violation = '''compilation error: callable constraint not satisfied'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_typed_effect_delegates_impl_a4b5c6d7"
content = '''Delegates all iteration logic to for_loop_typed_impl with template parameters R and N, forwarding start, end, and body'''
formal_spec = '''for_loop_typed<R, N>(start, end, body) => for_loop_typed_impl<R, N>(start, end, std::forward<F>(body))'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_typed"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_typed(T start, T end, F&& body)'''
axiom_type = "effect"
on_violation = '''N/A - always satisfied'''
depends_on = ['cpp20_temp_expl_spec_unspecialized_enclosing_template_param_a7b8c9d0', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'for_loop_range_typed_precond_n_valid_offset_b3c4d5e6', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "for_loop_typed_effect_perfect_forward_a5b6c7d8"
content = '''Perfectly forwards body parameter to preserve its value category (lvalue/rvalue) using std::forward<F>'''
formal_spec = '''std::forward<F>(body) preserves value_category(body): is_rvalue_reference<F&&> => move(body), is_lvalue_reference<F&> => copy(body)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_typed"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_typed(T start, T end, F&& body)'''
axiom_type = "effect"
on_violation = '''N/A - always satisfied'''
depends_on = ['ctrl_r_conversion_operator_anti_pattern_use_after_move_a9d4f7e2', 'ctrl_r_conversion_operator_effect_move_semantics_143', 'extract_constraint_type_r_moveable_f6c8d2e4', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_expr_cast_lvalue_result_d4e8a1c3', 'cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_basic_lval_temp_materialization_b4e9f1c5']
reviewed = true

[[axioms]]
id = "for_loop_typed_effect_unroll_optimization_a6b7c8d9"
content = '''Invokes body for each value in [start, end) using loop unrolling by factor N for instruction-level parallelism'''
formal_spec = '''iterations = floor((end - start) / N) * N + ((end - start) % N); forall i in [start, end): body(i) is invoked exactly once'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "for_loop_typed"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_typed(T start, T end, F&& body)'''
axiom_type = "effect"
on_violation = '''N/A - implementation detail'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_typed_postcond_success_return_a7b8c9d0"
content = '''If all iterations complete successfully without early return, returns ForResultTyped<R>{false, R{}}: return_set is false and storage is default-constructed'''
formal_spec = '''(forall i in [start, end): body(i).ok == true) => result.return_set == false && result.storage == R{}'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "for_loop_typed"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_typed(T start, T end, F&& body)'''
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed if preconditions met'''
depends_on = ['cpp20_basic_life_vacuous_initialization_def_7c4e5d6a', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_list_copy_list_init_explicit_ctor_f2a3b4c5', 'cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "for_loop_typed_postcond_early_return_a8b9c0d1"
content = '''If body returns LoopControl with early_return set, returns ForResultTyped<R>{true, value}: return_set is true and storage contains the returned value'''
formal_spec = '''(exists i in [start, end): body(i).early_return == true && body(i).value == v) => result.return_set == true && result.storage == v'''
layer = "library"
confidence = 0.85
source_file = ""
source_module = ""
function = "for_loop_typed"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_typed(T start, T end, F&& body)'''
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed if preconditions met'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_typed_constraint_template_params_a9b0c1d2"
content = '''Template parameter N must be a positive compile-time constant representing the unroll factor'''
formal_spec = '''N > 0 && std::is_integral_v<decltype(N)>'''
layer = "library"
confidence = 0.8
source_file = ""
source_module = ""
function = "for_loop_typed"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_typed(T start, T end, F&& body)'''
axiom_type = "constraint"
on_violation = '''compilation error: invalid template argument'''
depends_on = ['cpp20_temp_expl_spec_unspecialized_enclosing_template_param_a7b8c9d0', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'for_loop_range_typed_precond_n_valid_offset_b3c4d5e6', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'for_loop_typed_constraint_return_type_r_b1c2d3e4']
reviewed = true

[[axioms]]
id = "for_loop_typed_constraint_type_t_requirements_b0c1d2e3"
content = '''Type T must support comparison operators (<=), increment (++), and addition (+) for loop iteration'''
formal_spec = '''requires(T a, T b) { {a <= b} -> std::convertible_to<bool>; ++a; {a + N} -> std::convertible_to<T>; }'''
layer = "library"
confidence = 0.85
source_file = ""
source_module = ""
function = "for_loop_typed"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_typed(T start, T end, F&& body)'''
axiom_type = "constraint"
on_violation = '''compilation error: type does not satisfy constraints'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_typed_constraint_return_type_r_b1c2d3e4"
content = '''Template parameter R must be default-constructible and stored in ForResultTyped<R> for early return values'''
formal_spec = '''std::is_default_constructible_v<R>'''
layer = "library"
confidence = 0.8
source_file = ""
source_module = ""
function = "for_loop_typed"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_typed(T start, T end, F&& body)'''
axiom_type = "constraint"
on_violation = '''compilation error: type R does not satisfy constraints'''
depends_on = ['cpp20_basic_life_vacuous_initialization_def_7c4e5d6a', 'cpp20_temp_expl_spec_unspecialized_enclosing_template_param_a7b8c9d0', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'for_loop_range_typed_precond_n_valid_offset_b3c4d5e6', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_list_copy_list_init_explicit_ctor_f2a3b4c5', 'cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2', 'cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "for_loop_typed_complexity_time_b2c3d4e5"
content = '''Time complexity is O((end - start) * C) where C is the complexity of body invocation, with constant factor improvement from unrolling by N'''
formal_spec = '''T(n) = O(n * C_body) where n = end - start'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "for_loop_typed"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_typed(T start, T end, F&& body)'''
axiom_type = "complexity"
on_violation = '''N/A - performance characteristic'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_typed_complexity_space_b3c4d5e6"
content = '''Space complexity is O(1) excluding the space used by body callable and return value storage'''
formal_spec = '''S(n) = O(1) + sizeof(F) + sizeof(ForResultTyped<R>)'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "for_loop_typed"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_typed(T start, T end, F&& body)'''
axiom_type = "complexity"
on_violation = '''N/A - performance characteristic'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_range_precond_range_sized_e7f8g9h0"
content = '''Range parameter must be a valid sized range satisfying std::ranges::sized_range, providing valid std::ranges::size() and std::ranges::begin() expressions'''
formal_spec = '''std::ranges::sized_range<Range> && valid_expr(std::ranges::size(range)) && valid_expr(std::ranges::begin(range))'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "for_loop_range"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResult for_loop_range(Range&& range, F&& body)'''
axiom_type = "precondition"
on_violation = '''Compilation error or undefined behavior if range does not satisfy sized_range concept'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "for_loop_range_precond_range_has_iterator_i1j2k3l4"
content = '''Range must provide an iterator satisfying input_or_output_iterator concept for std::ranges::begin(range)'''
formal_spec = '''valid_expr(std::ranges::begin(range)) && models<input_or_output_iterator>(decltype(std::ranges::begin(range)))'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "for_loop_range"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResult for_loop_range(Range&& range, F&& body)'''
axiom_type = "precondition"
on_violation = '''Compilation error if range does not satisfy iterator requirements'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4', 'for_loop_range_typed_impl_precond_iterator_random_access_e5f6a7b8', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'for_loop_range_untyped_impl_precond_iterator_random_access_b2c3d4e5', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_concept_same_reflexive_e8a4c7d9', 'cpp20_concept_same_definition_symmetric_a7c3e1f2', 'for_loop_range_impl_anti_pattern_non_random_access_e5f6a7b8', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_concept_same_symmetric_f1b2a3c4']
reviewed = true

[[axioms]]
id = "for_loop_range_precond_body_invocable_m4n5o6p7"
content = '''Body parameter must be a callable object that can be invoked with elements from the range'''
formal_spec = '''std::invocable<F, std::ranges::range_reference_t<Range>>'''
layer = "library"
confidence = 0.85
source_file = ""
source_module = ""
function = "for_loop_range"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResult for_loop_range(Range&& range, F&& body)'''
axiom_type = "precondition"
on_violation = '''Compilation error if body cannot be called with range elements'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "for_loop_range_effect_perfect_forward_range_q7r8s9t0"
content = '''Perfectly forwards the range parameter using std::forward<Range>, preserving its value category (lvalue ranges are preserved as lvalue references, rvalue ranges are moved)'''
formal_spec = '''std::forward<Range>(range) => (is_rvalue_reference<Range&&> ? move(range) : lvalue_ref(range))'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_range"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResult for_loop_range(Range&& range, F&& body)'''
axiom_type = "effect"
on_violation = '''N/A - language-level guarantee'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'ctrl_r_conversion_operator_anti_pattern_use_after_move_a9d4f7e2', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4', 'ctrl_r_conversion_operator_effect_move_semantics_143', 'extract_constraint_type_r_moveable_f6c8d2e4', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_expr_cast_lvalue_result_d4e8a1c3', 'cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_basic_lval_temp_materialization_b4e9f1c5']
reviewed = true

[[axioms]]
id = "for_loop_range_effect_perfect_forward_body_u0v1w2x3"
content = '''Perfectly forwards the body parameter using std::forward<F>, preserving its value category to enable move semantics for rvalue callables and avoid unnecessary copies'''
formal_spec = '''std::forward<F>(body) => (is_rvalue_reference<F&&> ? move(body) : lvalue_ref(body))'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_range"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResult for_loop_range(Range&& range, F&& body)'''
axiom_type = "effect"
on_violation = '''N/A - language-level guarantee'''
depends_on = ['ctrl_r_conversion_operator_anti_pattern_use_after_move_a9d4f7e2', 'ctrl_r_conversion_operator_effect_move_semantics_143', 'extract_constraint_type_r_moveable_f6c8d2e4', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "for_loop_range_effect_delegates_to_impl_y3z4a5b6"
content = '''Delegates execution to detail::for_loop_range_untyped_impl<N> which performs the actual iteration over the range, invoking body for each element'''
formal_spec = '''returns detail::for_loop_range_untyped_impl<N>(std::forward<Range>(range), std::forward<F>(body))'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "for_loop_range"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResult for_loop_range(Range&& range, F&& body)'''
axiom_type = "effect"
on_violation = '''N/A - wrapper function behavior'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "for_loop_range_postcond_returns_forresult_c6d7e8f9"
content = '''Returns ForResult object containing the result of the range-based loop execution from the underlying implementation'''
formal_spec = '''returns<ForResult> && result == detail::for_loop_range_untyped_impl<N>(std::forward<Range>(range), std::forward<F>(body))'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_range"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResult for_loop_range(Range&& range, F&& body)'''
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed by return type'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "for_loop_range_constraint_template_n_compile_time_g0h1i2j3"
content = '''Template parameter N must be a compile-time constant value specifying loop parallelization or unrolling factor'''
formal_spec = '''std::is_integral_v<decltype(N)> && is_constant_expression(N)'''
layer = "library"
confidence = 0.8
source_file = ""
source_module = ""
function = "for_loop_range"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResult for_loop_range(Range&& range, F&& body)'''
axiom_type = "constraint"
on_violation = '''Compilation error if N is not a compile-time constant'''
depends_on = ['cpp20_temp_expl_spec_unspecialized_enclosing_template_param_a7b8c9d0', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'for_loop_range_typed_precond_n_valid_offset_b3c4d5e6', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'for_loop_typed_constraint_return_type_r_b1c2d3e4']
reviewed = true

[[axioms]]
id = "for_loop_range_constraint_rvalue_ref_params_k3l4m5n6"
content = '''Both Range and F parameters are forwarding references (Range&& and F&&), accepting both lvalue and rvalue arguments with perfect forwarding semantics'''
formal_spec = '''is_forwarding_reference<Range&&> && is_forwarding_reference<F&&>'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_range"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResult for_loop_range(Range&& range, F&& body)'''
axiom_type = "constraint"
on_violation = '''N/A - enforced by function signature'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'ctrl_r_conversion_operator_anti_pattern_use_after_move_a9d4f7e2', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4', 'ctrl_r_conversion_operator_effect_move_semantics_143', 'extract_constraint_type_r_moveable_f6c8d2e4', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_expr_cast_lvalue_result_d4e8a1c3', 'cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_basic_lval_temp_materialization_b4e9f1c5']
reviewed = true

[[axioms]]
id = "for_loop_range_anti_pattern_pass_by_value_o6p7q8r9"
content = '''Do not explicitly move or copy arguments when calling this function; use direct pass-through to preserve value category and enable perfect forwarding'''
formal_spec = '''avoid: for_loop_range(std::move(r), std::move(b)) when r and b are lvalues'''
layer = "library"
confidence = 0.75
source_file = ""
source_module = ""
function = "for_loop_range"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResult for_loop_range(Range&& range, F&& body)'''
axiom_type = "anti_pattern"
on_violation = '''Unnecessary moves or copies, potential dangling references'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_range_typed_precond_range_valid_c4d5e6f7"
content = '''Range parameter must be a valid sized range type providing valid begin() and size() operations'''
formal_spec = '''valid_expr(std::ranges::begin(range)) && valid_expr(std::ranges::size(range))'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "for_loop_range_typed"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_range_typed(Range&& range, F&& body)'''
axiom_type = "precondition"
on_violation = '''Compilation failure if Range does not satisfy sized range concept requirements'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "for_loop_range_typed_precond_n_valid_offset_b3c4d5e6"
content = '''Template parameter N must be greater than or equal to any internal offset used in implementation'''
formal_spec = '''N >= Offset'''
layer = "library"
confidence = 0.75
source_file = ""
source_module = ""
function = "for_loop_range_typed"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_range_typed(Range&& range, F&& body)'''
axiom_type = "precondition"
on_violation = '''Compilation failure or undefined behavior in template instantiation'''
depends_on = ['cpp20_temp_expl_spec_unspecialized_enclosing_template_param_a7b8c9d0', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'for_loop_typed_constraint_return_type_r_b1c2d3e4']
reviewed = true

[[axioms]]
id = "for_loop_range_typed_precond_body_callable_d4e5f6a7"
content = '''Body parameter must be a callable accepting appropriate iteration parameters and returning type compatible with R'''
formal_spec = '''is_invocable<F, iteration_args...> && convertible_to<invoke_result_t<F, iteration_args...>, R>'''
layer = "library"
confidence = 0.85
source_file = ""
source_module = ""
function = "for_loop_range_typed"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_range_typed(Range&& range, F&& body)'''
axiom_type = "precondition"
on_violation = '''Compilation failure if body is not callable with correct signature or return type'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_range_typed_effect_delegates_impl_e5f6a7b8"
content = '''Delegates all iteration logic to detail::for_loop_range_typed_impl<R, N> with perfectly forwarded parameters'''
formal_spec = '''for_loop_range_typed(range, body) => detail::for_loop_range_typed_impl<R, N>(std::forward<Range>(range), std::forward<F>(body))'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_range_typed"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_range_typed(Range&& range, F&& body)'''
axiom_type = "effect"
on_violation = '''N/A - this is the implementation behavior'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_range_typed_effect_perfect_forward_range_f6a7b8c9"
content = '''Perfectly forwards range parameter preserving value category: rvalue ranges are moved, lvalue ranges are copied/referenced'''
formal_spec = '''std::forward<Range>(range) => (is_rvalue_reference<Range&&> ? move(range) : lvalue_ref(range))'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_range_typed"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_range_typed(Range&& range, F&& body)'''
axiom_type = "effect"
on_violation = '''N/A - this is the implementation behavior'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'ctrl_r_conversion_operator_anti_pattern_use_after_move_a9d4f7e2', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4', 'ctrl_r_conversion_operator_effect_move_semantics_143', 'extract_constraint_type_r_moveable_f6c8d2e4', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_expr_cast_lvalue_result_d4e8a1c3', 'cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_basic_lval_temp_materialization_b4e9f1c5']
reviewed = true

[[axioms]]
id = "for_loop_range_typed_effect_perfect_forward_body_a7b8c9d0"
content = '''Perfectly forwards body parameter preserving value category, enabling move semantics for rvalue callables'''
formal_spec = '''std::forward<F>(body) => (is_rvalue_reference<F&&> ? move(body) : lvalue_ref(body))'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_range_typed"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_range_typed(Range&& range, F&& body)'''
axiom_type = "effect"
on_violation = '''N/A - this is the implementation behavior'''
depends_on = ['ctrl_r_conversion_operator_anti_pattern_use_after_move_a9d4f7e2', 'ctrl_r_conversion_operator_effect_move_semantics_143', 'extract_constraint_type_r_moveable_f6c8d2e4', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "for_loop_range_typed_postcond_returns_typed_result_b8c9d0e1"
content = '''Returns ForResultTyped<R> containing results of all body invocations over the range'''
formal_spec = '''result_type == ForResultTyped<R> && result.size() == std::ranges::size(range)'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "for_loop_range_typed"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_range_typed(Range&& range, F&& body)'''
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed by return type and implementation delegation'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "for_loop_range_typed_constraint_range_rvalue_ref_c9d0e1f2"
content = '''Range parameter must be a forwarding reference (Range&&) accepting both lvalues and rvalues'''
formal_spec = '''is_forwarding_reference<Range&&>'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "for_loop_range_typed"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_range_typed(Range&& range, F&& body)'''
axiom_type = "constraint"
on_violation = '''Compilation failure if Range is not deducible as forwarding reference'''
depends_on = ['for_loop_range_impl_effect_forwards_body_parameter_e5f6a7b8', 'for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4', 'for_loop_range_impl_effect_forwards_range_parameter_a9b0c1d2', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "for_loop_range_typed_constraint_body_rvalue_ref_d0e1f2a3"
content = '''Body parameter must be a forwarding reference (F&&) accepting both lvalue and rvalue callables'''
formal_spec = '''is_forwarding_reference<F&&>'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "for_loop_range_typed"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_range_typed(Range&& range, F&& body)'''
axiom_type = "constraint"
on_violation = '''Compilation failure if F is not deducible as forwarding reference'''
depends_on = ['for_loop_range_impl_effect_forwards_body_parameter_e5f6a7b8', 'ctrl_r_conversion_operator_anti_pattern_use_after_move_a9d4f7e2', 'for_loop_range_impl_effect_forwards_range_parameter_a9b0c1d2', 'extract_constraint_type_r_moveable_f6c8d2e4', 'ctrl_r_conversion_operator_effect_move_semantics_143', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_expr_cast_lvalue_result_d4e8a1c3', 'cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_basic_lval_temp_materialization_b4e9f1c5']
reviewed = true

[[axioms]]
id = "for_loop_range_typed_exception_propagates_impl_e1f2a3b4"
content = '''Propagates any exceptions thrown by detail::for_loop_range_typed_impl, including exceptions from body invocations or range operations'''
formal_spec = '''throws(detail::for_loop_range_typed_impl<R, N>(std::forward<Range>(range), std::forward<F>(body))) => throws(for_loop_range_typed(range, body))'''
layer = "library"
confidence = 0.85
source_file = ""
source_module = ""
function = "for_loop_range_typed"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_range_typed(Range&& range, F&& body)'''
axiom_type = "exception"
on_violation = '''N/A - exception propagation is guaranteed'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "for_loop_range_typed_anti_pattern_no_guard_f2a3b4c5"
content = '''Do not pass temporary ranges that would be destroyed before iteration completes if implementation stores iterators/references'''
formal_spec = '''lifetime(range) >= lifetime(iteration)'''
layer = "library"
confidence = 0.7
source_file = ""
source_module = ""
function = "for_loop_range_typed"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_range_typed(Range&& range, F&& body)'''
axiom_type = "anti_pattern"
on_violation = '''Undefined behavior if range is destroyed while implementation holds references to it'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_range_typed_complexity_delegates_impl_a3b4c5d6"
content = '''Time complexity is O(1) for wrapper delegation plus complexity of detail::for_loop_range_typed_impl; space complexity O(1) for forwarding references'''
formal_spec = '''time_complexity = O(1) + complexity(detail::for_loop_range_typed_impl); space_complexity = O(1)'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "for_loop_range_typed"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_range_typed(Range&& range, F&& body)'''
axiom_type = "complexity"
on_violation = '''N/A - complexity is guaranteed by implementation structure'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_range_ret_simple_precond_range_valid_5a7b3c9d"
content = '''Range parameter must satisfy range concept requirements: must have begin() and end() iterators that define a valid range'''
formal_spec = '''valid_range(range) && has_begin(Range) && has_end(Range)'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "for_loop_range_ret_simple"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''auto for_loop_range_ret_simple(Range&& range, F&& body)'''
axiom_type = "precondition"
on_violation = '''Compilation error or undefined behavior if range type does not satisfy range requirements'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'ilp_for_range_constraint_range_parenthesized_e9a2f4b6', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_concept_same_reflexive_e8a4c7d9', 'cpp20_concept_same_definition_symmetric_a7c3e1f2', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_concept_same_symmetric_f1b2a3c4']
reviewed = true

[[axioms]]
id = "for_loop_range_ret_simple_precond_body_callable_8d4e2f1a"
content = '''Body parameter must be a callable object that can be invoked with elements from the range'''
formal_spec = '''is_invocable<F, range_element_t<Range>>'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "for_loop_range_ret_simple"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''auto for_loop_range_ret_simple(Range&& range, F&& body)'''
axiom_type = "precondition"
on_violation = '''Compilation error if body cannot be called with range elements'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "for_loop_range_ret_simple_effect_perfect_forward_range_3c8d1e5f"
content = '''Perfectly forwards the range parameter to implementation function, preserving its value category (lvalue vs rvalue) using std::forward<Range>'''
formal_spec = '''std::forward<Range>(range) => (is_rvalue(range) ? move(range) : lvalue_ref(range))'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_range_ret_simple"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''auto for_loop_range_ret_simple(Range&& range, F&& body)'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by std::forward semantics'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'ctrl_r_conversion_operator_anti_pattern_use_after_move_a9d4f7e2', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4', 'ctrl_r_conversion_operator_effect_move_semantics_143', 'extract_constraint_type_r_moveable_f6c8d2e4', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_expr_cast_lvalue_result_d4e8a1c3', 'cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_basic_lval_temp_materialization_b4e9f1c5']
reviewed = true

[[axioms]]
id = "for_loop_range_ret_simple_effect_perfect_forward_body_7b2c9d4e"
content = '''Perfectly forwards the body parameter to implementation function, preserving its value category (lvalue vs rvalue) using std::forward<F>'''
formal_spec = '''std::forward<F>(body) => (is_rvalue(body) ? move(body) : lvalue_ref(body))'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_range_ret_simple"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''auto for_loop_range_ret_simple(Range&& range, F&& body)'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by std::forward semantics'''
depends_on = ['ctrl_r_conversion_operator_anti_pattern_use_after_move_a9d4f7e2', 'ctrl_r_conversion_operator_effect_move_semantics_143', 'extract_constraint_type_r_moveable_f6c8d2e4', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_expr_cast_lvalue_result_d4e8a1c3', 'cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_basic_lval_temp_materialization_b4e9f1c5']
reviewed = true

[[axioms]]
id = "for_loop_range_ret_simple_effect_delegates_to_impl_6e3f8a1c"
content = '''Delegates to detail::for_loop_range_ret_simple_impl<N> with perfectly forwarded range and body parameters'''
formal_spec = '''invokes(detail::for_loop_range_ret_simple_impl<N>, std::forward<Range>(range), std::forward<F>(body))'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_range_ret_simple"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''auto for_loop_range_ret_simple(Range&& range, F&& body)'''
axiom_type = "effect"
on_violation = '''N/A - wrapper function guarantee'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "for_loop_range_ret_simple_postcond_returns_impl_result_9f4d2e7b"
content = '''Returns the result of detail::for_loop_range_ret_simple_impl<N> without modification; return type is auto-deduced from implementation function'''
formal_spec = '''decltype(for_loop_range_ret_simple(range, body)) == decltype(detail::for_loop_range_ret_simple_impl<N>(std::forward<Range>(range), std::forward<F>(body)))'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_range_ret_simple"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''auto for_loop_range_ret_simple(Range&& range, F&& body)'''
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed by direct return statement'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_range_ret_simple_constraint_template_param_n_1e8c4f2d"
content = '''Template parameter N must be a valid compile-time constant suitable for detail::for_loop_range_ret_simple_impl<N>'''
formal_spec = '''is_valid_template_arg<N, detail::for_loop_range_ret_simple_impl>'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "for_loop_range_ret_simple"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''auto for_loop_range_ret_simple(Range&& range, F&& body)'''
axiom_type = "constraint"
on_violation = '''Compilation error if N is invalid for implementation function'''
depends_on = ['cpp20_temp_expl_spec_unspecialized_enclosing_template_param_a7b8c9d0', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'for_loop_range_typed_precond_n_valid_offset_b3c4d5e6', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'for_loop_typed_constraint_return_type_r_b1c2d3e4']
reviewed = true

[[axioms]]
id = "for_loop_range_ret_simple_effect_no_side_effects_2a5d9c3e"
content = '''This wrapper function has no side effects itself; all effects are delegated to detail::for_loop_range_ret_simple_impl<N>'''
formal_spec = '''side_effects(for_loop_range_ret_simple) == side_effects(detail::for_loop_range_ret_simple_impl<N>)'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "for_loop_range_ret_simple"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''auto for_loop_range_ret_simple(Range&& range, F&& body)'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by pure delegation'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_range_ret_simple_exception_propagates_impl_exceptions_4c7e1f8a"
content = '''Propagates any exceptions thrown by detail::for_loop_range_ret_simple_impl<N>, std::forward, or operations within body callable'''
formal_spec = '''throws(for_loop_range_ret_simple) ⊇ throws(detail::for_loop_range_ret_simple_impl<N>) ∪ throws(std::forward<Range>) ∪ throws(std::forward<F>)'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "for_loop_range_ret_simple"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''auto for_loop_range_ret_simple(Range&& range, F&& body)'''
axiom_type = "exception"
on_violation = '''N/A - exception propagation is automatic'''
depends_on = ['cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'for_loop_range_ret_simple_impl_precond_range_valid_a1b2c3d4', 'for_loop_range_ret_simple_precond_range_valid_5a7b3c9d', 'for_loop_range_ret_simple_impl_invariant_i_bounds_p3q4r5s6', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "for_loop_auto_precond_valid_range_a1b2c3d4"
content = '''Precondition: start and end must form a valid range according to loop type LT, satisfying the preconditions of the delegated for_loop<optimal_N<LT, ElementT>> function'''
formal_spec = '''valid_range<LT>(start, end) && satisfies_preconditions<for_loop<optimal_N<LT, ElementT>>>(start, end, body)'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "for_loop_auto"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResult for_loop_auto(T start, T end, F&& body)'''
axiom_type = "precondition"
on_violation = '''undefined behavior or propagates violation from for_loop'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "for_loop_auto_constraint_optimal_n_valid_b2c3d4e5"
content = '''Constraint: optimal_N<LT, ElementT> must resolve to a valid positive compile-time constant usable as a template parameter for for_loop instantiation'''
formal_spec = '''is_valid_template_param<optimal_N<LT, ElementT>> && optimal_N<LT, ElementT> > 0'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_auto"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResult for_loop_auto(T start, T end, F&& body)'''
axiom_type = "constraint"
on_violation = '''compilation error'''
depends_on = ['cpp20_temp_expl_spec_unspecialized_enclosing_template_param_a7b8c9d0', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'for_loop_range_typed_precond_n_valid_offset_b3c4d5e6', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'for_loop_typed_constraint_return_type_r_b1c2d3e4']
reviewed = true

[[axioms]]
id = "for_loop_auto_constraint_body_callable_c3d4e5f6"
content = '''Constraint: body must be a callable object compatible with the signature expected by for_loop<optimal_N<LT, ElementT>>, accepting loop iteration parameters'''
formal_spec = '''is_invocable<F, loop_iteration_params<T, LT>> && is_forwarding_compatible<F&&>'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "for_loop_auto"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResult for_loop_auto(T start, T end, F&& body)'''
axiom_type = "constraint"
on_violation = '''compilation error'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_auto_effect_delegates_to_for_loop_d4e5f6g7"
content = '''Effect: Delegates execution to for_loop<optimal_N<LT, ElementT>>(start, end, std::forward<F>(body)), automatically determining optimal iteration unrolling factor N based on loop type LT and element type ElementT'''
formal_spec = '''for_loop_auto(start, end, body) => for_loop<optimal_N<LT, ElementT>>(start, end, std::forward<F>(body))'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_auto"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResult for_loop_auto(T start, T end, F&& body)'''
axiom_type = "effect"
on_violation = '''not applicable'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_auto_effect_perfect_forwarding_e5f6g7h8"
content = '''Effect: Uses std::forward<F>(body) to preserve the value category of body parameter, enabling perfect forwarding of both lvalue and rvalue callable objects without unnecessary copies'''
formal_spec = '''is_rvalue_reference<F&&> => std::forward<F>(body) preserves rvalue-ness && enables move semantics; is_lvalue_reference<F&> => std::forward<F>(body) preserves lvalue-ness'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_auto"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResult for_loop_auto(T start, T end, F&& body)'''
axiom_type = "effect"
on_violation = '''not applicable'''
depends_on = ['ctrl_r_conversion_operator_anti_pattern_use_after_move_a9d4f7e2', 'ctrl_r_conversion_operator_effect_move_semantics_143', 'extract_constraint_type_r_moveable_f6c8d2e4', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_expr_cast_lvalue_result_d4e8a1c3', 'cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_basic_lval_temp_materialization_b4e9f1c5']
reviewed = true

[[axioms]]
id = "for_loop_auto_postcond_returns_for_result_f6g7h8i9"
content = '''Postcondition: Returns a ForResult object containing the result of loop execution, semantically equivalent to the result returned by for_loop<optimal_N<LT, ElementT>>(start, end, body)'''
formal_spec = '''return(for_loop_auto(start, end, body)) == return(for_loop<optimal_N<LT, ElementT>>(start, end, std::forward<F>(body)))'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "for_loop_auto"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResult for_loop_auto(T start, T end, F&& body)'''
axiom_type = "postcondition"
on_violation = '''not applicable'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_auto_constraint_type_compatibility_g7h8i9j0"
content = '''Constraint: Type parameters T, F, R, LT, and ElementT must be compatible such that T is suitable for loop iteration according to LT, and ElementT correctly describes the element type for optimal_N computation'''
formal_spec = '''is_loop_compatible<T, LT> && is_element_type_compatible<ElementT, T> && is_integral_constant<optimal_N<LT, ElementT>>'''
layer = "library"
confidence = 0.85
source_file = ""
source_module = ""
function = "for_loop_auto"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResult for_loop_auto(T start, T end, F&& body)'''
axiom_type = "constraint"
on_violation = '''compilation error'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_auto_exception_propagates_from_delegate_h8i9j0k1"
content = '''Exception: Any exception thrown by for_loop<optimal_N<LT, ElementT>> or std::forward<F> is propagated to the caller without modification'''
formal_spec = '''throws(for_loop<optimal_N<LT, ElementT>>(start, end, std::forward<F>(body))) => throws(for_loop_auto(start, end, body))'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "for_loop_auto"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResult for_loop_auto(T start, T end, F&& body)'''
axiom_type = "exception"
on_violation = '''not applicable'''
depends_on = ['cpp20_except_throw_destruction_ordering_d5e1c7b9', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_except_throw_destruction_after_handler_exit_c4a9f2e6', 'cpp20_except_throw_uncaught_after_init_before_activation_1c8e5a4b', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "for_loop_auto_complexity_delegates_complexity_i9j0k1l2"
content = '''Complexity: Time and space complexity is identical to for_loop<optimal_N<LT, ElementT>>, as this function is a zero-overhead delegation wrapper that only performs compile-time template parameter computation'''
formal_spec = '''time_complexity(for_loop_auto(start, end, body)) == time_complexity(for_loop<optimal_N<LT, ElementT>>(start, end, body)) && space_complexity(for_loop_auto(start, end, body)) == space_complexity(for_loop<optimal_N<LT, ElementT>>(start, end, body))'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "for_loop_auto"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResult for_loop_auto(T start, T end, F&& body)'''
axiom_type = "complexity"
on_violation = '''not applicable'''
depends_on = ['cpp20_temp_expl_spec_unspecialized_enclosing_template_param_a7b8c9d0', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'for_loop_range_typed_precond_n_valid_offset_b3c4d5e6', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'for_loop_typed_constraint_return_type_r_b1c2d3e4']
reviewed = true

[[axioms]]
id = "for_loop_typed_auto_precond_valid_range_a1b2c3d4"
content = '''start and end must form a valid range according to loop type LT semantics (start <= end for forward iteration)'''
formal_spec = '''valid_range<LT>(start, end)'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "for_loop_typed_auto"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_typed_auto(T start, T end, F&& body)'''
axiom_type = "precondition"
on_violation = '''undefined behavior or incorrect iteration count in delegated for_loop_typed call'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "for_loop_typed_auto_constraint_optimal_n_valid_b2c3d4e5"
content = '''optimal_N<LT, ElementT> must evaluate to a valid positive compile-time constant suitable as template parameter'''
formal_spec = '''is_valid_template_param<optimal_N<LT, ElementT>> && optimal_N<LT, ElementT> > 0'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_typed_auto"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_typed_auto(T start, T end, F&& body)'''
axiom_type = "constraint"
on_violation = '''compilation failure due to invalid template instantiation'''
depends_on = ['cpp20_temp_expl_spec_unspecialized_enclosing_template_param_a7b8c9d0', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'for_loop_range_typed_precond_n_valid_offset_b3c4d5e6', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'for_loop_typed_constraint_return_type_r_b1c2d3e4']
reviewed = true

[[axioms]]
id = "for_loop_typed_auto_constraint_t_integral_c3d4e5f6"
content = '''Type T must support loop operations required by LT (comparison, increment) and be compatible with optimal_N instantiation'''
formal_spec = '''supports_loop_operations<T, LT> && is_compatible_with<T, optimal_N<LT, ElementT>>'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "for_loop_typed_auto"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_typed_auto(T start, T end, F&& body)'''
axiom_type = "constraint"
on_violation = '''compilation failure due to missing operations or type incompatibility'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_typed_auto_constraint_f_callable_d4e5f6a7"
content = '''F must be a callable type (function, lambda, functor) compatible with the signature expected by for_loop_typed'''
formal_spec = '''is_callable<F> && is_invocable_with_loop_params<F>'''
layer = "library"
confidence = 0.85
source_file = ""
source_module = ""
function = "for_loop_typed_auto"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_typed_auto(T start, T end, F&& body)'''
axiom_type = "constraint"
on_violation = '''compilation failure due to non-callable type or signature mismatch'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_typed_auto_effect_delegates_typed_e5f6a7b8"
content = '''Delegates to for_loop_typed<R, optimal_N<LT, ElementT>> with automatic unroll factor determination, forwarding body with perfect forwarding'''
formal_spec = '''return for_loop_typed<R, optimal_N<LT, ElementT>>(start, end, std::forward<F>(body))'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_typed_auto"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_typed_auto(T start, T end, F&& body)'''
axiom_type = "effect"
on_violation = '''N/A - this is the specified behavior'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_typed_auto_effect_perfect_forward_f6a7b8c9"
content = '''Uses std::forward<F>(body) to preserve value category: rvalue references enable move semantics, lvalue references preserve copying semantics'''
formal_spec = '''is_rvalue_reference<F&&> => std::forward<F>(body) enables move(body); is_lvalue_reference<F&> => std::forward<F>(body) preserves lvalue(body)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_typed_auto"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_typed_auto(T start, T end, F&& body)'''
axiom_type = "effect"
on_violation = '''N/A - this is the specified behavior'''
depends_on = ['ctrl_r_conversion_operator_anti_pattern_use_after_move_a9d4f7e2', 'ctrl_r_conversion_operator_effect_move_semantics_143', 'extract_constraint_type_r_moveable_f6c8d2e4', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_expr_cast_lvalue_result_d4e8a1c3', 'cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_basic_lval_temp_materialization_b4e9f1c5']
reviewed = true

[[axioms]]
id = "for_loop_typed_auto_postcond_returns_typed_a7b8c9d0"
content = '''Returns ForResultTyped<R> containing the result of the loop execution as determined by for_loop_typed'''
formal_spec = '''returns(ForResultTyped<R>) && result == for_loop_typed<R, optimal_N<LT, ElementT>>(start, end, std::forward<F>(body))'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_typed_auto"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_typed_auto(T start, T end, F&& body)'''
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed by return type and delegation'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_typed_auto_exception_propagates_from_delegate_b8c9d0e1"
content = '''Propagates any exceptions thrown by for_loop_typed<R, optimal_N<LT, ElementT>> or during body execution'''
formal_spec = '''throws(E) iff for_loop_typed<R, optimal_N<LT, ElementT>>(start, end, std::forward<F>(body)) throws(E)'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "for_loop_typed_auto"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_typed_auto(T start, T end, F&& body)'''
axiom_type = "exception"
on_violation = '''exception propagates to caller'''
depends_on = ['c11_libc_stdio_str_511422b8', 'c11_c_common_expr_bitwise_operation_54b48e73', 'c11_libc_stdio_hasRadix_a9ccb8f7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "for_loop_typed_auto_complexity_delegates_c9d0e1f2"
content = '''Time complexity is O(1) for this wrapper plus the complexity of for_loop_typed<R, optimal_N<LT, ElementT>>(start, end, body), which depends on (end - start) and body execution cost'''
formal_spec = '''T(n) = O(1) + T_for_loop_typed(n) where n = (end - start)'''
layer = "library"
confidence = 0.85
source_file = ""
source_module = ""
function = "for_loop_typed_auto"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_typed_auto(T start, T end, F&& body)'''
axiom_type = "complexity"
on_violation = '''N/A - complexity guarantee'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_range_auto_precond_range_valid_8a3f2e9d"
content = '''Range parameter must be a valid range type supporting std::forward<Range>, with valid begin() and end() iterators that satisfy the requirements of the underlying for_loop_range template.'''
formal_spec = '''is_valid_range_type<Range> && has_begin_end<Range> && satisfies_preconditions<for_loop_range<optimal_N<LT, ElementT>>>(range)'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "for_loop_range_auto"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResult for_loop_range_auto(Range&& range, F&& body)'''
axiom_type = "precondition"
on_violation = '''Compilation error if Range doesn't satisfy range requirements; undefined behavior if iterators are invalid'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4', 'cpp20_temp_expl_spec_unspecialized_enclosing_template_param_a7b8c9d0', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'for_loop_range_typed_precond_n_valid_offset_b3c4d5e6', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "for_loop_range_auto_precond_body_callable_7b4e1c8f"
content = '''Body parameter must be a callable object (function, lambda, functor) that can be invoked with elements from the range, compatible with the for_loop_range template's requirements.'''
formal_spec = '''is_callable<F> && is_invocable<F, ElementT> && satisfies_preconditions<for_loop_range<optimal_N<LT, ElementT>>>(body)'''
layer = "library"
confidence = 0.85
source_file = ""
source_module = ""
function = "for_loop_range_auto"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResult for_loop_range_auto(Range&& range, F&& body)'''
axiom_type = "precondition"
on_violation = '''Compilation error if body is not callable with range elements'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4', 'cpp20_temp_expl_spec_unspecialized_enclosing_template_param_a7b8c9d0', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'for_loop_range_typed_precond_n_valid_offset_b3c4d5e6', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "for_loop_range_auto_constraint_optimal_n_valid_9c2d5a7e"
content = '''Template parameter optimal_N<LT, ElementT> must resolve to a valid compile-time constant greater than zero, representing the instruction-level parallelism factor for loop unrolling.'''
formal_spec = '''is_constant_expression(optimal_N<LT, ElementT>::value) && optimal_N<LT, ElementT>::value > 0 && is_valid_template_param<optimal_N<LT, ElementT>>'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_range_auto"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResult for_loop_range_auto(Range&& range, F&& body)'''
axiom_type = "constraint"
on_violation = '''Compilation error if optimal_N cannot be instantiated or is not a valid constant expression'''
depends_on = ['cpp20_temp_expl_spec_unspecialized_enclosing_template_param_a7b8c9d0', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'for_loop_range_typed_precond_n_valid_offset_b3c4d5e6', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'for_loop_typed_constraint_return_type_r_b1c2d3e4']
reviewed = true

[[axioms]]
id = "for_loop_range_auto_effect_perfect_forward_range_6e9a3b2c"
content = '''Perfectly forwards the range parameter using std::forward<Range>, preserving its value category: rvalue ranges are moved, lvalue ranges are copied or referenced.'''
formal_spec = '''std::forward<Range>(range) => (is_rvalue_reference<Range&&> ? move(range) : lvalue_ref(range)) && preserves_value_category(range)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_range_auto"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResult for_loop_range_auto(Range&& range, F&& body)'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by std::forward semantics'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'ctrl_r_conversion_operator_anti_pattern_use_after_move_a9d4f7e2', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4', 'ctrl_r_conversion_operator_effect_move_semantics_143', 'extract_constraint_type_r_moveable_f6c8d2e4', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_expr_cast_lvalue_result_d4e8a1c3', 'cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_basic_lval_temp_materialization_b4e9f1c5']
reviewed = true

[[axioms]]
id = "for_loop_range_auto_effect_perfect_forward_body_4d7f8a1e"
content = '''Perfectly forwards the body parameter using std::forward<F>, preserving its value category to enable move semantics for rvalue callables and avoid unnecessary copies.'''
formal_spec = '''std::forward<F>(body) => (is_rvalue_reference<F&&> ? move(body) && !copies(body) : lvalue_ref(body)) && preserves_value_category(body)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_range_auto"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResult for_loop_range_auto(Range&& range, F&& body)'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by std::forward semantics'''
depends_on = ['ctrl_r_conversion_operator_anti_pattern_use_after_move_a9d4f7e2', 'ctrl_r_conversion_operator_effect_move_semantics_143', 'extract_constraint_type_r_moveable_f6c8d2e4', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "for_loop_range_auto_effect_delegates_to_impl_3c8b5d2a"
content = '''Delegates execution to for_loop_range<optimal_N<LT, ElementT>> with perfectly forwarded parameters, automatically determining the optimal ILP unrolling factor based on loop type LT and element type ElementT.'''
formal_spec = '''for_loop_range_auto(range, body) => for_loop_range<optimal_N<LT, ElementT>>(std::forward<Range>(range), std::forward<F>(body))'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_range_auto"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResult for_loop_range_auto(Range&& range, F&& body)'''
axiom_type = "effect"
on_violation = '''N/A - delegation is unconditional'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_range_auto_postcond_returns_for_result_5a9e2c7b"
content = '''Returns a ForResult object containing the result of the loop execution, semantically equivalent to the result returned by for_loop_range<optimal_N<LT, ElementT>> with the same parameters.'''
formal_spec = '''return(for_loop_range_auto(range, body)) == return(for_loop_range<optimal_N<LT, ElementT>>(std::forward<Range>(range), std::forward<F>(body)))'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_range_auto"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResult for_loop_range_auto(Range&& range, F&& body)'''
axiom_type = "postcondition"
on_violation = '''N/A - postcondition is guaranteed by direct delegation'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_range_auto_exception_propagates_from_impl_2b6d9e4f"
content = '''Any exceptions thrown by for_loop_range<optimal_N<LT, ElementT>>, range operations (begin/end), or body invocations are propagated to the caller without modification.'''
formal_spec = '''throws(for_loop_range_auto(range, body)) <=> throws(for_loop_range<optimal_N<LT, ElementT>>(range, body)) || throws(std::forward<Range>(range)) || throws(std::forward<F>(body))'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "for_loop_range_auto"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResult for_loop_range_auto(Range&& range, F&& body)'''
axiom_type = "exception"
on_violation = '''Exception propagates to caller'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "for_loop_range_auto_complexity_depends_on_impl_1f3a7c8d"
content = '''Time complexity is O(1) for the wrapper itself (just forwarding), plus the complexity of for_loop_range<optimal_N<LT, ElementT>> which depends on range size and body complexity. Space complexity is O(1) excluding the delegated call.'''
formal_spec = '''T(for_loop_range_auto) = O(1) + T(for_loop_range<optimal_N<LT, ElementT>>) && S(for_loop_range_auto) = O(1) + S(for_loop_range<optimal_N<LT, ElementT>>)'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "for_loop_range_auto"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResult for_loop_range_auto(Range&& range, F&& body)'''
axiom_type = "complexity"
on_violation = '''N/A - complexity guarantee'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "for_loop_range_typed_auto_precond_range_valid_a1b2c3d4"
content = '''Range must be a valid range type that satisfies the requirements of std::forward<Range>, providing valid begin() and end() iterators that can be used with for_loop_range_typed.'''
formal_spec = '''is_valid_range_type<Range> && has_begin_end<Range> && satisfies_preconditions<for_loop_range_typed<R, optimal_N<LT, ElementT>>>(range)'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "for_loop_range_typed_auto"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_range_typed_auto(Range&& range, F&& body)'''
axiom_type = "precondition"
on_violation = '''Compilation error if Range doesn't satisfy range requirements; undefined behavior if begin/end are invalid'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'ilp_for_range_constraint_range_parenthesized_e9a2f4b6', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "for_loop_range_typed_auto_precond_body_callable_e5f6a7b8"
content = '''Body parameter F must be a callable object (function, lambda, functor) that accepts elements from the range and satisfies the requirements of for_loop_range_typed.'''
formal_spec = '''is_callable<F> && accepts_range_element<F, ElementT> && satisfies_body_requirements<for_loop_range_typed<R, optimal_N<LT, ElementT>>>(body)'''
layer = "library"
confidence = 0.85
source_file = ""
source_module = ""
function = "for_loop_range_typed_auto"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_range_typed_auto(Range&& range, F&& body)'''
axiom_type = "precondition"
on_violation = '''Compilation error if F is not callable or has incompatible signature'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "for_loop_range_typed_auto_constraint_optimal_n_valid_c2d3e4f5"
content = '''The template parameter optimal_N<LT, ElementT> must resolve to a valid compile-time constant representing the ILP unrolling factor, compatible with for_loop_range_typed instantiation.'''
formal_spec = '''is_constant_expression(optimal_N<LT, ElementT>::value) && optimal_N<LT, ElementT>::value > 0 && is_valid_template_param<optimal_N<LT, ElementT>>'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "for_loop_range_typed_auto"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_range_typed_auto(Range&& range, F&& body)'''
axiom_type = "constraint"
on_violation = '''Compilation error if optimal_N cannot be instantiated or produces invalid value'''
depends_on = ['cpp20_temp_expl_spec_unspecialized_enclosing_template_param_a7b8c9d0', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'for_loop_range_typed_precond_n_valid_offset_b3c4d5e6', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_temp_inst_constraint_no_valid_specialization_ndr_f9a0b1c2', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'for_loop_typed_constraint_return_type_r_b1c2d3e4']
reviewed = true

[[axioms]]
id = "for_loop_range_typed_auto_constraint_element_type_compatible_d4e5f6a7"
content = '''ElementT must be the element type of Range and must be compatible with the loop type LT for optimal_N instantiation.'''
formal_spec = '''ElementT == range_element_type<Range> && supports_loop_operations<ElementT, LT> && is_compatible_with<ElementT, optimal_N<LT, ElementT>>'''
layer = "library"
confidence = 0.85
source_file = ""
source_module = ""
function = "for_loop_range_typed_auto"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_range_typed_auto(Range&& range, F&& body)'''
axiom_type = "constraint"
on_violation = '''Compilation error if element type is incompatible with loop operations'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "for_loop_range_typed_auto_effect_perfect_forward_range_a8b9c0d1"
content = '''Perfectly forwards the range parameter using std::forward<Range>, preserving its value category (lvalue vs rvalue) to enable move semantics for rvalue ranges.'''
formal_spec = '''std::forward<Range>(range) => (is_rvalue_reference<Range&&> ? move(range) : lvalue_ref(range)) && preserves_value_category<Range>(range)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_range_typed_auto"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_range_typed_auto(Range&& range, F&& body)'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by std::forward semantics'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'ctrl_r_conversion_operator_anti_pattern_use_after_move_a9d4f7e2', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4', 'ctrl_r_conversion_operator_effect_move_semantics_143', 'extract_constraint_type_r_moveable_f6c8d2e4', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_expr_cast_lvalue_result_d4e8a1c3', 'cpp20_dcl_init_ref_lvalue_ref_direct_bind_6e7f8a9b', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_basic_lval_temp_materialization_b4e9f1c5']
reviewed = true

[[axioms]]
id = "for_loop_range_typed_auto_effect_perfect_forward_body_b9c0d1e2"
content = '''Perfectly forwards the body parameter using std::forward<F>, preserving its value category to enable move semantics for rvalue callables and avoid unnecessary copies.'''
formal_spec = '''std::forward<F>(body) => (is_rvalue_reference<F&&> ? move(body) : lvalue_ref(body)) && preserves_value_category<F>(body)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_range_typed_auto"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_range_typed_auto(Range&& range, F&& body)'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by std::forward semantics'''
depends_on = ['ctrl_r_conversion_operator_anti_pattern_use_after_move_a9d4f7e2', 'ctrl_r_conversion_operator_effect_move_semantics_143', 'extract_constraint_type_r_moveable_f6c8d2e4', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "for_loop_range_typed_auto_effect_delegates_to_typed_f2a3b4c5"
content = '''Delegates to for_loop_range_typed<R, optimal_N<LT, ElementT>> with automatically determined ILP factor, executing the loop body over the range with the optimal unrolling.'''
formal_spec = '''invokes(for_loop_range_typed<R, optimal_N<LT, ElementT>>(std::forward<Range>(range), std::forward<F>(body)))'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "for_loop_range_typed_auto"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_range_typed_auto(Range&& range, F&& body)'''
axiom_type = "effect"
on_violation = '''N/A - direct delegation'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "for_loop_range_typed_auto_postcond_returns_for_result_typed_e3f4a5b6"
content = '''Returns a ForResultTyped<R> object containing the result of the loop execution, equivalent to the result returned by for_loop_range_typed<R, optimal_N<LT, ElementT>>.'''
formal_spec = '''return(for_loop_range_typed_auto(range, body)) == return(for_loop_range_typed<R, optimal_N<LT, ElementT>>(std::forward<Range>(range), std::forward<F>(body)))'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "for_loop_range_typed_auto"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_range_typed_auto(Range&& range, F&& body)'''
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed by direct return'''
depends_on = ['cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r']
reviewed = true

[[axioms]]
id = "for_loop_range_typed_auto_exception_propagates_from_delegate_d5e6f7a8"
content = '''Propagates any exceptions thrown by for_loop_range_typed<R, optimal_N<LT, ElementT>>, including exceptions from range iteration or body invocation.'''
formal_spec = '''throws(for_loop_range_typed_auto) => throws(for_loop_range_typed<R, optimal_N<LT, ElementT>>) || throws(std::forward<Range>) || throws(std::forward<F>)'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "for_loop_range_typed_auto"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_range_typed_auto(Range&& range, F&& body)'''
axiom_type = "exception"
on_violation = '''Exception propagates to caller'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "for_loop_range_typed_auto_complexity_delegates_complexity_c6d7e8f9"
content = '''Time complexity is O(1) wrapper overhead plus the complexity of for_loop_range_typed<R, optimal_N<LT, ElementT>>, which depends on range size and body execution time.'''
formal_spec = '''time_complexity(for_loop_range_typed_auto) = O(1) + time_complexity(for_loop_range_typed<R, optimal_N<LT, ElementT>>)'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "for_loop_range_typed_auto"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/loops_ilp.hpp"
signature = '''ForResultTyped<R> for_loop_range_typed_auto(Range&& range, F&& body)'''
axiom_type = "complexity"
on_violation = '''N/A - complexity guarantee'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "ilp_for_macro_precond_loop_var_valid_decl_a1b2c3d4"
content = '''loop_var_decl must be a valid variable declaration (e.g., 'int i', 'auto x') suitable for range-based for loop'''
formal_spec = '''is_valid_range_for_declaration(loop_var_decl)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_FOR"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
signature = '''ILP_FOR(loop_var_decl, start, end, N)'''
axiom_type = "precondition"
on_violation = '''compilation error: invalid syntax in range-based for loop'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'ilp_for_range_t_range_single_eval', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4']
reviewed = true

[[axioms]]
id = "ilp_for_macro_precond_iota_callable_e5f6g7h8"
content = '''::ilp::iota must be accessible and callable with (start, end) arguments'''
formal_spec = '''is_callable(::ilp::iota, typeof(start), typeof(end))'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_FOR"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
signature = '''ILP_FOR(loop_var_decl, start, end, N)'''
axiom_type = "precondition"
on_violation = '''compilation error: iota not found or not callable with given argument types'''
reviewed = true

[[axioms]]
id = "ilp_for_macro_constraint_start_end_compatible_i9j0k1l2"
content = '''start and end must have types compatible with ::ilp::iota's parameter types (typically integral or iterator types)'''
formal_spec = '''is_compatible_with_iota_params(typeof(start), typeof(end))'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "ILP_FOR"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
signature = '''ILP_FOR(loop_var_decl, start, end, N)'''
axiom_type = "constraint"
on_violation = '''compilation error: type mismatch in iota call'''
depends_on = ['for_loop_range_untyped_impl_precond_iterator_random_access_b2c3d4e5', 'for_loop_range_impl_anti_pattern_non_random_access_e5f6a7b8', 'for_loop_range_typed_impl_precond_iterator_random_access_e5f6a7b8']
reviewed = true

[[axioms]]
id = "ilp_for_macro_effect_single_eval_m3n4o5p6"
content = '''The start and end arguments are each evaluated exactly once due to parenthesization in the expansion, making this macro safe with side-effect expressions'''
formal_spec = '''eval_count(start) == 1 && eval_count(end) == 1'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_FOR"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
signature = '''ILP_FOR(loop_var_decl, start, end, N)'''
axiom_type = "effect"
on_violation = '''N/A - this is the safe behavior'''
depends_on = ['ilp_for_auto_macro_param_eval_multiple_a7f3d2e1', 'ilp_for_t_auto_anti_pattern_side_effects_safe']
reviewed = true

[[axioms]]
id = "ilp_for_macro_effect_param_n_unused_q7r8s9t0"
content = '''The parameter N is completely unused in the macro expansion and has no effect on behavior'''
formal_spec = '''N not in expansion(ILP_FOR)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_FOR"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
signature = '''ILP_FOR(loop_var_decl, start, end, N)'''
axiom_type = "effect"
on_violation = '''N/A - parameter is ignored'''
reviewed = true

[[axioms]]
id = "ilp_for_macro_postcond_range_for_expansion_u1v2w3x4"
content = '''Macro expands to a range-based for loop: for (loop_var_decl : ::ilp::iota((start), (end)))'''
formal_spec = '''expansion(ILP_FOR(loop_var_decl, start, end, N)) == 'for (loop_var_decl : ::ilp::iota((start), (end)))''''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_FOR"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
signature = '''ILP_FOR(loop_var_decl, start, end, N)'''
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed by preprocessor'''
depends_on = ['ilp_for_range_t_range_single_eval', 'for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4']
reviewed = true

[[axioms]]
id = "ilp_for_macro_constraint_iota_returns_range_y5z6a7b8"
content = '''::ilp::iota(start, end) must return a range-compatible object (with begin() and end() iterators) for use in range-based for loop'''
formal_spec = '''has_begin_end(typeof(::ilp::iota(start, end)))'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_FOR"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
signature = '''ILP_FOR(loop_var_decl, start, end, N)'''
axiom_type = "constraint"
on_violation = '''compilation error: range-based for loop requires begin() and end()'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'ilp_for_range_t_range_single_eval', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4']
reviewed = true

[[axioms]]
id = "ilp_for_macro_constraint_loop_var_type_compatible_c9d0e1f2"
content = '''The type declared in loop_var_decl must be compatible with the element type of the range returned by iota'''
formal_spec = '''is_assignable(loop_var_decl_type, element_type(::ilp::iota(start, end)))'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "ILP_FOR"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
signature = '''ILP_FOR(loop_var_decl, start, end, N)'''
axiom_type = "constraint"
on_violation = '''compilation error: type mismatch in range-based for loop initialization'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4']
reviewed = true

[[axioms]]
id = "ilp_for_macro_anti_pattern_n_param_misleading_g3h4i5j6"
content = '''Anti-pattern: Passing a value for N parameter expecting it to control loop behavior - N is completely ignored in this macro version'''
formal_spec = '''expects_n_to_affect_behavior(user_intent) && N not in expansion => misleading_api'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "ILP_FOR"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
signature = '''ILP_FOR(loop_var_decl, start, end, N)'''
axiom_type = "anti_pattern"
on_violation = '''logic error: user expects N to have effect but it is ignored'''
reviewed = true

[[axioms]]
id = "ilp_for_macro_complexity_iota_range_construction_k7l8m9n0"
content = '''Macro expansion involves constructing a range object via iota(start, end); complexity depends on iota's implementation (typically O(1) for range construction)'''
formal_spec = '''complexity(ILP_FOR) = complexity(::ilp::iota) = O(1) // assuming lazy range'''
layer = "library"
confidence = 0.85
source_file = ""
source_module = ""
function = "ILP_FOR"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
signature = '''ILP_FOR(loop_var_decl, start, end, N)'''
axiom_type = "complexity"
on_violation = '''N/A - informational'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'cpp20_basic_life_vacuous_initialization_def_7c4e5d6a', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4', 'cpp20_dcl_init_list_copy_list_init_explicit_ctor_f2a3b4c5', 'cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8']
reviewed = true

[[axioms]]
id = "ilp_for_range_macro_param_unused_n_e4a7b3c2"
content = '''The parameter N is declared in the macro signature but never used in the expansion, suggesting either incomplete implementation or API design issue'''
formal_spec = '''params(ILP_FOR_RANGE) = {loop_var_decl, range, N} && expansion_uses(N) = false'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_FOR_RANGE"
header = "ilp_for/detail/macros_simple.hpp"
signature = '''ILP_FOR_RANGE(loop_var_decl, range, N)'''
axiom_type = "anti_pattern"
on_violation = '''Parameter N is silently ignored, potentially leading to user confusion about expected behavior'''
reviewed = true

[[axioms]]
id = "ilp_for_range_macro_single_eval_range_f2d8e1a9"
content = '''The range argument is evaluated exactly once as it appears once in the expansion within a range-based for loop'''
formal_spec = '''eval_count(range) == 1'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_FOR_RANGE"
header = "ilp_for/detail/macros_simple.hpp"
signature = '''ILP_FOR_RANGE(loop_var_decl, range, N)'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by single occurrence in expansion'''
depends_on = ['ilp_for_range_t_range_single_eval', 'for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4']
reviewed = true

[[axioms]]
id = "ilp_for_range_macro_no_side_effects_b9c4d7e2"
content = '''Macro expansion performs simple textual substitution with no evaluation or side effects at preprocessing time'''
formal_spec = '''noSideEffects(ILP_FOR_RANGE) && evaluationTime(ILP_FOR_RANGE) == runtime'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_FOR_RANGE"
header = "ilp_for/detail/macros_simple.hpp"
signature = '''ILP_FOR_RANGE(loop_var_decl, range, N)'''
axiom_type = "effect"
on_violation = '''N/A - macro expansion is purely textual'''
depends_on = ['ilp_n_transform_8_effect_no_side_effects', 'ilp_cpu_profile_macro_no_side_effects', 'ilp_cpu_profile_macro_context_independence']
reviewed = true

[[axioms]]
id = "ilp_for_range_constraint_loop_var_syntax_a3f9d2c8"
content = '''The loop_var_decl parameter must be a valid variable declaration syntax for range-based for loops (e.g., 'auto x', 'int& val', 'const auto& item')'''
formal_spec = '''is_valid_range_for_declaration(loop_var_decl)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_FOR_RANGE"
header = "ilp_for/detail/macros_simple.hpp"
signature = '''ILP_FOR_RANGE(loop_var_decl, range, N)'''
axiom_type = "constraint"
on_violation = '''Compilation error due to malformed range-based for loop syntax'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'ilp_for_range_t_range_single_eval', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4']
reviewed = true

[[axioms]]
id = "ilp_for_range_constraint_range_expr_c7e2a4f1"
content = '''The range parameter must be a valid range expression supporting begin() and end() operations or array type suitable for range-based for loops'''
formal_spec = '''is_range_expression(range) || is_array(range)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_FOR_RANGE"
header = "ilp_for/detail/macros_simple.hpp"
signature = '''ILP_FOR_RANGE(loop_var_decl, range, N)'''
axiom_type = "constraint"
on_violation = '''Compilation error: range expression does not support begin/end iteration'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'ilp_for_range_t_range_single_eval', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4', 'for_loop_range_untyped_impl_constraint_array_bounds_remainder_b8c9d0e1', 'for_loop_range_typed_impl_constraint_array_access_inner_n7o8p9q0', 'for_loop_range_typed_impl_constraint_array_access_remainder_r1s2t3u4']
reviewed = true

[[axioms]]
id = "ilp_for_range_postcondition_for_loop_generation_d8b3c5e7"
content = '''Macro expansion produces a syntactically valid range-based for loop: 'for (loop_var_decl : (range))''''
formal_spec = '''expand(ILP_FOR_RANGE(loop_var_decl, range, N)) = for(loop_var_decl : (range))'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_FOR_RANGE"
header = "ilp_for/detail/macros_simple.hpp"
signature = '''ILP_FOR_RANGE(loop_var_decl, range, N)'''
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed by macro definition'''
depends_on = ['ilp_for_range_t_range_single_eval', 'for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4']
reviewed = true

[[axioms]]
id = "ilp_for_range_constraint_range_parenthesized_e9a2f4b6"
content = '''The range expression is parenthesized in the expansion, protecting against operator precedence issues if range contains comma operators or low-precedence operators'''
formal_spec = '''expansion_form(range) = (range) => operator_precedence_safe(range)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_FOR_RANGE"
header = "ilp_for/detail/macros_simple.hpp"
signature = '''ILP_FOR_RANGE(loop_var_decl, range, N)'''
axiom_type = "effect"
on_violation = '''N/A - parenthesization provides protection'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4', 'cpp20_over_match_oper_no_class_enum_builtin_f1a2b3c4', 'cpp20_over_match_oper_fallback_builtin_comma_addr_arrow_b3c4d5e6', 'c11_cpp_translation_name_syntax_operation_018c4422']
reviewed = true

[[axioms]]
id = "ilp_for_range_anti_pattern_incomplete_impl_f1c8d3a7"
content = '''The macro signature suggests ILP (Instruction-Level Parallelism) with parameter N (likely unroll factor), but expansion is a simple range-based for loop with no parallelization or unrolling, indicating incomplete or placeholder implementation'''
formal_spec = '''semantic_intent(N) = unroll_factor && actual_behavior(expansion) = sequential_iteration => implementation_incomplete'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "ILP_FOR_RANGE"
header = "ilp_for/detail/macros_simple.hpp"
signature = '''ILP_FOR_RANGE(loop_var_decl, range, N)'''
axiom_type = "anti_pattern"
on_violation = '''Users expecting ILP behavior will get sequential execution, leading to incorrect performance assumptions'''
depends_on = ['ilp_for_range_t_range_single_eval', 'for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4']
reviewed = true

[[axioms]]
id = "ilp_for_range_complexity_sequential_o_n_b4e7c2f9"
content = '''Despite the ILP naming, the macro expands to a sequential range-based for loop with O(n) time complexity where n is the size of the range'''
formal_spec = '''time_complexity(ILP_FOR_RANGE) = O(|range|) && parallelism_factor = 1'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_FOR_RANGE"
header = "ilp_for/detail/macros_simple.hpp"
signature = '''ILP_FOR_RANGE(loop_var_decl, range, N)'''
axiom_type = "complexity"
on_violation = '''N/A - this is the actual behavior'''
depends_on = ['ilp_for_range_t_range_single_eval', 'for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4']
reviewed = true

[[axioms]]
id = "ilp_for_auto_precondition_start_end_valid"
content = '''The start and end parameters must be valid arguments to ilp::iota, which typically requires they are compatible integer-like or iterator-like types'''
formal_spec = '''valid_iota_args(start, end) && compatible_types(start, end)'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "ILP_FOR_AUTO"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
signature = '''ILP_FOR_AUTO(loop_var_decl, start, end, loop_type, element_type)'''
axiom_type = "precondition"
on_violation = '''Compilation error from ilp::iota instantiation'''
depends_on = ['for_loop_range_untyped_impl_precond_iterator_random_access_b2c3d4e5', 'for_loop_range_impl_anti_pattern_non_random_access_e5f6a7b8', 'for_loop_range_typed_impl_precond_iterator_random_access_e5f6a7b8']
reviewed = true

[[axioms]]
id = "ilp_for_auto_precondition_loop_var_valid_decl"
content = '''The loop_var_decl parameter must be a valid variable declaration suitable for range-based for loop (e.g., 'auto i', 'int i', 'const auto& i')'''
formal_spec = '''valid_range_for_declaration(loop_var_decl)'''
layer = "library"
confidence = 0.98
source_file = ""
source_module = ""
function = "ILP_FOR_AUTO"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
signature = '''ILP_FOR_AUTO(loop_var_decl, start, end, loop_type, element_type)'''
axiom_type = "precondition"
on_violation = '''Syntax error during macro expansion'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'ilp_for_range_t_range_single_eval', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4']
reviewed = true

[[axioms]]
id = "ilp_for_auto_effect_single_evaluation"
content = '''The start and end arguments are parenthesized in the expansion, protecting against precedence issues, but they are still passed to ilp::iota which may copy or evaluate them according to its semantics'''
formal_spec = '''parenthesized(start) && parenthesized(end) && evaluation_determined_by(ilp::iota)'''
layer = "library"
confidence = 0.92
source_file = ""
source_module = ""
function = "ILP_FOR_AUTO"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
signature = '''ILP_FOR_AUTO(loop_var_decl, start, end, loop_type, element_type)'''
axiom_type = "effect"
on_violation = '''N/A - this describes safe behavior'''
depends_on = ['ilp_for_t_auto_anti_pattern_side_effects_safe', 'ilp_for_auto_macro_param_eval_multiple_a7f3d2e1']
reviewed = true

[[axioms]]
id = "ilp_for_auto_constraint_unused_params"
content = '''The loop_type and element_type parameters are not used in the macro expansion - they may be present for compatibility with other macro variants or future extensions'''
formal_spec = '''unused_in_expansion(loop_type) && unused_in_expansion(element_type)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_FOR_AUTO"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
signature = '''ILP_FOR_AUTO(loop_var_decl, start, end, loop_type, element_type)'''
axiom_type = "constraint"
on_violation = '''No effect - parameters are simply ignored'''
reviewed = true

[[axioms]]
id = "ilp_for_auto_postcondition_range_for_loop"
content = '''Macro expands to a C++ range-based for loop iterating over the range produced by ilp::iota(start, end)'''
formal_spec = '''expands_to(for (loop_var_decl : ::ilp::iota((start), (end))))'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_FOR_AUTO"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
signature = '''ILP_FOR_AUTO(loop_var_decl, start, end, loop_type, element_type)'''
axiom_type = "postcondition"
on_violation = '''N/A - this describes the guaranteed expansion'''
depends_on = ['ilp_for_range_t_range_single_eval', 'for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4']
reviewed = true

[[axioms]]
id = "ilp_for_auto_anti_pattern_side_effects_in_args"
content = '''While parenthesization protects against precedence issues, using expressions with side effects in start or end (e.g., i++, func()) may still have those effects evaluated during iota's construction or iteration setup'''
formal_spec = '''has_side_effects(start) || has_side_effects(end) => potential_unexpected_evaluation'''
layer = "library"
confidence = 0.88
source_file = ""
source_module = ""
function = "ILP_FOR_AUTO"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
signature = '''ILP_FOR_AUTO(loop_var_decl, start, end, loop_type, element_type)'''
axiom_type = "anti_pattern"
on_violation = '''Side effects may occur at iota construction time, potentially causing unexpected behavior'''
depends_on = ['cpp20_dcl_init_list_copy_list_init_explicit_ctor_f2a3b4c5', 'cpp20_basic_life_vacuous_initialization_def_7c4e5d6a', 'cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8']
reviewed = true

[[axioms]]
id = "ilp_for_auto_constraint_element_type_compatibility"
content = '''The type of loop_var_decl should be compatible with the value_type produced by ilp::iota's iterator, typically an integer-like type'''
formal_spec = '''compatible_with(type(loop_var_decl), value_type(ilp::iota(start, end)))'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "ILP_FOR_AUTO"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
signature = '''ILP_FOR_AUTO(loop_var_decl, start, end, loop_type, element_type)'''
axiom_type = "constraint"
on_violation = '''Compilation error or implicit conversion during iteration'''
depends_on = ['for_loop_range_untyped_impl_precond_iterator_random_access_b2c3d4e5', 'for_loop_range_impl_anti_pattern_non_random_access_e5f6a7b8', 'for_loop_range_typed_impl_precond_iterator_random_access_e5f6a7b8']
reviewed = true

[[axioms]]
id = "ilp_for_auto_complexity_linear"
content = '''The macro expands to a loop that iterates (end - start) times, resulting in linear time complexity O(end - start)'''
formal_spec = '''time_complexity(ILP_FOR_AUTO) = O(end - start)'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "ILP_FOR_AUTO"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
signature = '''ILP_FOR_AUTO(loop_var_decl, start, end, loop_type, element_type)'''
axiom_type = "complexity"
on_violation = '''N/A - this describes performance characteristics'''
reviewed = true

[[axioms]]
id = "ilp_for_auto_effect_namespace_qualified"
content = '''The macro uses fully qualified name ::ilp::iota to avoid ambiguity with other iota functions (e.g., std::iota) or namespace pollution'''
formal_spec = '''uses_fully_qualified_name(::ilp::iota)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_FOR_AUTO"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
signature = '''ILP_FOR_AUTO(loop_var_decl, start, end, loop_type, element_type)'''
axiom_type = "effect"
on_violation = '''N/A - this prevents potential name collision issues'''
reviewed = true

[[axioms]]
id = "ilp_for_range_auto_precond_range_valid_7a3e9f21"
content = '''The range argument must be a valid expression that supports range-based for loop semantics (has begin()/end() or is an array)'''
formal_spec = '''has_begin_end(range) || is_array(range)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_FOR_RANGE_AUTO"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
signature = '''ILP_FOR_RANGE_AUTO(loop_var_decl, range, loop_type, element_type)'''
axiom_type = "precondition"
on_violation = '''Compilation error: range-based for loop requires begin()/end() or array type'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'ilp_for_range_t_range_single_eval', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4', 'for_loop_range_untyped_impl_constraint_array_bounds_remainder_b8c9d0e1', 'for_loop_range_typed_impl_constraint_array_access_inner_n7o8p9q0', 'for_loop_range_typed_impl_constraint_array_access_remainder_r1s2t3u4']
reviewed = true

[[axioms]]
id = "ilp_for_range_auto_effect_single_eval_2d8b4c31"
content = '''The range argument is evaluated exactly once during loop initialization due to range-based for semantics, protecting against multiple evaluation side effects'''
formal_spec = '''eval_count(range) == 1'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_FOR_RANGE_AUTO"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
signature = '''ILP_FOR_RANGE_AUTO(loop_var_decl, range, loop_type, element_type)'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by range-based for loop semantics'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'ilp_for_range_t_range_single_eval', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4', 'cpp20_basic_life_vacuous_initialization_def_7c4e5d6a', 'cpp20_dcl_init_list_no_applicable_rule_a4b5c6d7']
reviewed = true

[[axioms]]
id = "ilp_for_range_auto_constraint_unused_params_5f1c7e92"
content = '''The loop_type and element_type parameters are not used in the macro expansion - they exist for API consistency but have no effect'''
formal_spec = '''unused(loop_type) && unused(element_type)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_FOR_RANGE_AUTO"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
signature = '''ILP_FOR_RANGE_AUTO(loop_var_decl, range, loop_type, element_type)'''
axiom_type = "constraint"
on_violation = '''N/A - unused parameters have no semantic effect'''
depends_on = ['ilp_cpu_profile_macro_no_side_effects', 'ilp_n_transform_8_effect_no_side_effects']
reviewed = true

[[axioms]]
id = "ilp_for_range_auto_constraint_loop_var_type_3b6d8a41"
content = '''The loop_var_decl must be a valid variable declaration suitable for range-based for loop (typically 'auto var' or 'auto& var' or 'const auto& var')'''
formal_spec = '''is_valid_range_for_declaration(loop_var_decl)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_FOR_RANGE_AUTO"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
signature = '''ILP_FOR_RANGE_AUTO(loop_var_decl, range, loop_type, element_type)'''
axiom_type = "constraint"
on_violation = '''Compilation error: invalid variable declaration in range-based for loop'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'ilp_for_range_t_range_single_eval', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4']
reviewed = true

[[axioms]]
id = "ilp_for_range_auto_postcond_loop_scope_4e2a9c71"
content = '''After macro expansion, a range-based for loop is created where the loop variable is scoped to the loop body'''
formal_spec = '''scope(loop_var) == loop_body'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_FOR_RANGE_AUTO"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
signature = '''ILP_FOR_RANGE_AUTO(loop_var_decl, range, loop_type, element_type)'''
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed by for loop semantics'''
depends_on = ['ilp_for_range_t_range_single_eval', 'for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4']
reviewed = true

[[axioms]]
id = "ilp_for_range_auto_effect_no_preproc_side_effects_8c4f1d23"
content = '''Macro expansion performs simple textual substitution with no side effects at preprocessing time'''
formal_spec = '''has_side_effects_at_preprocessing(ILP_FOR_RANGE_AUTO) == false'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_FOR_RANGE_AUTO"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
signature = '''ILP_FOR_RANGE_AUTO(loop_var_decl, range, loop_type, element_type)'''
axiom_type = "effect"
on_violation = '''N/A - textual substitution has no side effects'''
depends_on = ['ilp_cpu_profile_macro_context_independence', 'ilp_n_divide_4f_macro_effect_no_side_effects']
reviewed = true

[[axioms]]
id = "ilp_for_range_auto_anti_pattern_dangling_ref_9a7e3b52"
content = '''If range is a temporary object and loop_var_decl uses a reference type, the reference may dangle if the temporary is not lifetime-extended'''
formal_spec = '''is_temporary(range) && is_reference(loop_var_decl) => potential_dangling_reference'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "ILP_FOR_RANGE_AUTO"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
signature = '''ILP_FOR_RANGE_AUTO(loop_var_decl, range, loop_type, element_type)'''
axiom_type = "anti_pattern"
on_violation = '''Undefined behavior: accessing dangling reference in loop body'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4', 'cpp20_dcl_init_ref_reference_related_def_c8d9e0f1', 'cpp20_dcl_init_ref_rvalue_or_func_lvalue_bind_2o3p4q5r', 'cpp20_dcl_init_ref_assign_to_referent_e4f5a6b7']
reviewed = true

[[axioms]]
id = "ilp_for_range_auto_complexity_range_iteration_2c5e8d91"
content = '''Performance characteristics depend on the range type's iterator operations - macro itself adds no overhead beyond standard range-based for loop'''
formal_spec = '''complexity(ILP_FOR_RANGE_AUTO) == complexity(standard_range_for) + O(1)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_FOR_RANGE_AUTO"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
signature = '''ILP_FOR_RANGE_AUTO(loop_var_decl, range, loop_type, element_type)'''
axiom_type = "complexity"
on_violation = '''N/A - performance characteristic, not a correctness issue'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'ilp_for_range_t_range_single_eval', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4', 'for_loop_range_typed_impl_precond_iterator_random_access_e5f6a7b8', 'for_loop_range_untyped_impl_precond_iterator_random_access_b2c3d4e5', 'for_loop_range_impl_anti_pattern_non_random_access_e5f6a7b8']
reviewed = true

[[axioms]]
id = "ilp_for_t_precondition_type_unused_3a8f9d1c"
content = '''The 'type' parameter is unused in the macro expansion - it exists for API consistency but has no effect'''
formal_spec = '''∀ type T: expand(ILP_FOR_T(T, ...)) == expand(ILP_FOR_T(U, ...)) for any types T, U'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_FOR_T"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
signature = '''ILP_FOR_T(type, loop_var_decl, start, end, N)'''
axiom_type = "anti_pattern"
on_violation = '''No violation - parameter is ignored'''
reviewed = true

[[axioms]]
id = "ilp_for_t_precondition_n_unused_7b2e4c9f"
content = '''The 'N' parameter is unused in the macro expansion - likely intended for ILP unrolling factor but not implemented'''
formal_spec = '''∀ N: expand(ILP_FOR_T(..., N)) is independent of N'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_FOR_T"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
signature = '''ILP_FOR_T(type, loop_var_decl, start, end, N)'''
axiom_type = "anti_pattern"
on_violation = '''No violation - parameter is ignored, but may mislead users about unrolling'''
reviewed = true

[[axioms]]
id = "ilp_for_t_precondition_valid_range_e4d7a2b8"
content = '''The start and end parameters must form a valid range for ::ilp::iota - typically start <= end for non-empty iteration'''
formal_spec = '''valid_range(start, end) => ∃ well_formed_range_for_iota'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "ILP_FOR_T"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
signature = '''ILP_FOR_T(type, loop_var_decl, start, end, N)'''
axiom_type = "precondition"
on_violation = '''Behavior depends on ::ilp::iota implementation - may result in empty range or undefined behavior'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4']
reviewed = true

[[axioms]]
id = "ilp_for_t_precondition_loop_var_decl_syntax_9c3f1e5a"
content = '''The loop_var_decl must be a valid range-for loop variable declaration (e.g., 'auto i', 'int& x', 'const auto& val')'''
formal_spec = '''is_valid_range_for_decl(loop_var_decl) => well_formed_for_loop'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_FOR_T"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
signature = '''ILP_FOR_T(type, loop_var_decl, start, end, N)'''
axiom_type = "precondition"
on_violation = '''Compilation error - invalid range-based for loop syntax'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4']
reviewed = true

[[axioms]]
id = "ilp_for_t_effect_single_eval_parenthesized_6f8d2a1b"
content = '''The start and end arguments are parenthesized in the expansion, protecting them from operator precedence issues, but actual evaluation count depends on ::ilp::iota constructor/iterator behavior'''
formal_spec = '''precedence_safe(start) && precedence_safe(end) && eval_count(start) >= 1 && eval_count(end) >= 1'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "ILP_FOR_T"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
signature = '''ILP_FOR_T(type, loop_var_decl, start, end, N)'''
axiom_type = "effect"
on_violation = '''N/A - this is a safety guarantee, not a requirement'''
depends_on = ['cpp20_basic_life_vacuous_initialization_def_7c4e5d6a', 'for_loop_range_typed_impl_precond_iterator_random_access_e5f6a7b8', 'cpp20_over_match_oper_no_class_enum_builtin_f1a2b3c4', 'for_loop_range_untyped_impl_precond_iterator_random_access_b2c3d4e5', 'cpp20_dcl_init_list_copy_list_init_explicit_ctor_f2a3b4c5', 'cpp20_over_match_oper_fallback_builtin_comma_addr_arrow_b3c4d5e6', 'cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8', 'c11_cpp_translation_name_syntax_operation_018c4422', 'for_loop_range_impl_anti_pattern_non_random_access_e5f6a7b8']
reviewed = true

[[axioms]]
id = "ilp_for_t_postcondition_range_for_expansion_2d9e7c4f"
content = '''Macro expands to a C++11 range-based for loop over the range produced by ::ilp::iota(start, end)'''
formal_spec = '''expand(ILP_FOR_T(type, loop_var_decl, start, end, N)) == 'for (loop_var_decl : ::ilp::iota((start), (end)))''''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_FOR_T"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
signature = '''ILP_FOR_T(type, loop_var_decl, start, end, N)'''
axiom_type = "postcondition"
on_violation = '''N/A - this is the definition'''
depends_on = ['ilp_for_range_t_range_single_eval', 'for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4']
reviewed = true

[[axioms]]
id = "ilp_for_t_constraint_iota_availability_8a5c3f2d"
content = '''The function ::ilp::iota must be defined and accessible at the point of macro expansion'''
formal_spec = '''is_defined(::ilp::iota) && is_accessible(::ilp::iota) => well_formed_expansion'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_FOR_T"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
signature = '''ILP_FOR_T(type, loop_var_decl, start, end, N)'''
axiom_type = "precondition"
on_violation = '''Compilation error - undefined or inaccessible function'''
reviewed = true

[[axioms]]
id = "ilp_for_t_anti_pattern_side_effects_caution_4e7b9a3c"
content = '''While start and end are parenthesized, if ::ilp::iota copies its arguments or stores them, side effects in these expressions may still be observable; avoid expressions with side effects unless iota behavior is well understood'''
formal_spec = '''has_side_effects(start) || has_side_effects(end) => behavior_depends_on_iota_implementation'''
layer = "library"
confidence = 0.85
source_file = ""
source_module = ""
function = "ILP_FOR_T"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
signature = '''ILP_FOR_T(type, loop_var_decl, start, end, N)'''
axiom_type = "anti_pattern"
on_violation = '''Potentially unexpected evaluation of side effects - undefined evaluation order or count'''
depends_on = ['ilp_for_t_auto_anti_pattern_side_effects_safe']
reviewed = true

[[axioms]]
id = "ilp_for_t_constraint_start_end_compatible_types_5c2d8e9a"
content = '''The types of start and end must be compatible with ::ilp::iota's parameter types for successful overload resolution'''
formal_spec = '''is_compatible(type(start), iota_param_type) && is_compatible(type(end), iota_param_type) => valid_call'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_FOR_T"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
signature = '''ILP_FOR_T(type, loop_var_decl, start, end, N)'''
axiom_type = "constraint"
on_violation = '''Compilation error - no matching function for call to ::ilp::iota'''
depends_on = ['cpp20_expr_pre_builtin_conversion_before_operation_a8d7c5b2', 'cpp20_over_match_general_inaccessible_best_viable_7b4e9d2a', 'cpp20_over_match_general_illfomed_no_best_viable_3a8f2c1d']
reviewed = true

[[axioms]]
id = "ilp_for_t_complexity_depends_on_iota_9f3a7e2c"
content = '''Loop iteration complexity is O(end - start) iterations, but actual performance depends on ::ilp::iota implementation and optimizer's ability to vectorize/unroll'''
formal_spec = '''iterations(ILP_FOR_T) = O(end - start) + complexity(::ilp::iota)'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "ILP_FOR_T"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
signature = '''ILP_FOR_T(type, loop_var_decl, start, end, N)'''
axiom_type = "complexity"
on_violation = '''N/A - this is a performance characteristic'''
reviewed = true

[[axioms]]
id = "ilp_for_t_effect_no_expansion_side_effects_1a4b8c6d"
content = '''Macro expansion itself performs simple textual substitution with no evaluation or side effects at preprocessing time'''
formal_spec = '''preprocessing_side_effects(ILP_FOR_T) == ∅ && evaluation_time(ILP_FOR_T) == runtime'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_FOR_T"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
signature = '''ILP_FOR_T(type, loop_var_decl, start, end, N)'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by C++ preprocessor semantics'''
depends_on = ['ilp_cpu_profile_macro_no_side_effects', 'ilp_n_transform_8_effect_no_side_effects', 'ilp_n_divide_4f_macro_effect_no_side_effects']
reviewed = true

[[axioms]]
id = "ilp_for_range_t_type_param_unused_constraint"
content = '''The 'type' parameter is not used in the macro expansion and has no effect on the generated code'''
formal_spec = '''∀ T1, T2, loop_var_decl, range, N: expand(ILP_FOR_RANGE_T(T1, loop_var_decl, range, N)) == expand(ILP_FOR_RANGE_T(T2, loop_var_decl, range, N))'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_FOR_RANGE_T"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
signature = '''ILP_FOR_RANGE_T(type, loop_var_decl, range, N)'''
axiom_type = "constraint"
on_violation = '''No violation possible - parameter is ignored'''
depends_on = ['ilp_cpu_profile_macro_no_side_effects']
reviewed = true

[[axioms]]
id = "ilp_for_range_t_n_param_unused_constraint"
content = '''The 'N' parameter is not used in the macro expansion and has no effect on the generated code'''
formal_spec = '''∀ type, loop_var_decl, range, N1, N2: expand(ILP_FOR_RANGE_T(type, loop_var_decl, range, N1)) == expand(ILP_FOR_RANGE_T(type, loop_var_decl, range, N2))'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_FOR_RANGE_T"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
signature = '''ILP_FOR_RANGE_T(type, loop_var_decl, range, N)'''
axiom_type = "constraint"
on_violation = '''No violation possible - parameter is ignored'''
depends_on = ['ilp_cpu_profile_macro_no_side_effects']
reviewed = true

[[axioms]]
id = "ilp_for_range_t_loop_var_decl_precondition"
content = '''The 'loop_var_decl' parameter must be a valid variable declaration (with or without type) suitable for a range-based for loop'''
formal_spec = '''is_valid_range_for_declaration(loop_var_decl)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_FOR_RANGE_T"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
signature = '''ILP_FOR_RANGE_T(type, loop_var_decl, range, N)'''
axiom_type = "precondition"
on_violation = '''Compilation error - invalid range-based for loop syntax'''
depends_on = ['ilp_for_range_t_range_single_eval', 'for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4']
reviewed = true

[[axioms]]
id = "ilp_for_range_t_range_precondition"
content = '''The 'range' parameter must be an expression that satisfies the requirements of a range-based for loop (has begin() and end(), or is an array)'''
formal_spec = '''is_range_expression(range) && (has_begin_end(range) || is_array(range))'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_FOR_RANGE_T"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
signature = '''ILP_FOR_RANGE_T(type, loop_var_decl, range, N)'''
axiom_type = "precondition"
on_violation = '''Compilation error - invalid range expression in range-based for loop'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'ilp_for_range_t_range_single_eval', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4', 'for_loop_range_untyped_impl_constraint_array_bounds_remainder_b8c9d0e1', 'for_loop_range_typed_impl_constraint_array_access_inner_n7o8p9q0', 'for_loop_range_typed_impl_constraint_array_access_remainder_r1s2t3u4']
reviewed = true

[[axioms]]
id = "ilp_for_range_t_range_single_eval"
content = '''The 'range' argument is evaluated exactly once during range-based for loop initialization, protecting against multiple evaluation side effects'''
formal_spec = '''eval_count(range) == 1'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_FOR_RANGE_T"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
signature = '''ILP_FOR_RANGE_T(type, loop_var_decl, range, N)'''
axiom_type = "effect"
on_violation = '''Not applicable - guaranteed by C++ range-based for semantics'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'cpp20_basic_life_vacuous_initialization_def_7c4e5d6a', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4', 'cpp20_dcl_init_list_no_applicable_rule_a4b5c6d7']
reviewed = true

[[axioms]]
id = "ilp_for_range_t_expansion_no_preprocessing_side_effects"
content = '''Macro expansion performs simple textual substitution with no evaluation or side effects at preprocessing time'''
formal_spec = '''noSideEffects(ILP_FOR_RANGE_T) && evaluationTime(ILP_FOR_RANGE_T) == runtime'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_FOR_RANGE_T"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
signature = '''ILP_FOR_RANGE_T(type, loop_var_decl, range, N)'''
axiom_type = "effect"
on_violation = '''Not applicable - preprocessing is pure textual substitution'''
depends_on = ['ilp_n_transform_8_effect_no_side_effects', 'ilp_cpu_profile_macro_context_independence']
reviewed = true

[[axioms]]
id = "ilp_for_range_t_postcondition_range_for_loop"
content = '''The macro expands to a standard C++ range-based for loop: 'for (loop_var_decl : (range))''''
formal_spec = '''expand(ILP_FOR_RANGE_T(type, loop_var_decl, range, N)) == 'for (loop_var_decl : (range))''''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_FOR_RANGE_T"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
signature = '''ILP_FOR_RANGE_T(type, loop_var_decl, range, N)'''
axiom_type = "postcondition"
on_violation = '''Not applicable - guaranteed by macro definition'''
depends_on = ['ilp_for_range_t_range_single_eval', 'for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4']
reviewed = true

[[axioms]]
id = "ilp_for_range_t_range_parenthesization"
content = '''The 'range' parameter is parenthesized in the expansion, protecting against operator precedence issues with comma operators'''
formal_spec = '''∀ expr: expand(ILP_FOR_RANGE_T(type, var, expr, N)) contains '(expr)' && protects_from_comma_operator(parenthesization)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_FOR_RANGE_T"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
signature = '''ILP_FOR_RANGE_T(type, loop_var_decl, range, N)'''
axiom_type = "effect"
on_violation = '''Not applicable - guaranteed by parentheses in macro definition'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4', 'cpp20_over_match_oper_no_class_enum_builtin_f1a2b3c4', 'cpp20_over_match_oper_fallback_builtin_comma_addr_arrow_b3c4d5e6', 'c11_cpp_translation_name_syntax_operation_018c4422']
reviewed = true

[[axioms]]
id = "ilp_for_range_t_anti_pattern_unused_params"
content = '''Passing complex expressions or expressions with side effects for the unused 'type' and 'N' parameters is wasteful and misleading, as they are completely ignored'''
formal_spec = '''has_side_effects(type) || has_side_effects(N) => anti_pattern(wasteful_computation)'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "ILP_FOR_RANGE_T"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
signature = '''ILP_FOR_RANGE_T(type, loop_var_decl, range, N)'''
axiom_type = "anti_pattern"
on_violation = '''No runtime violation - arguments are never evaluated, but code is misleading'''
reviewed = true

[[axioms]]
id = "ilp_for_range_t_complexity_constant"
content = '''Macro expansion has O(1) preprocessing complexity - simple textual substitution with no computation'''
formal_spec = '''preprocessing_complexity(ILP_FOR_RANGE_T) == O(1)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_FOR_RANGE_T"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
signature = '''ILP_FOR_RANGE_T(type, loop_var_decl, range, N)'''
axiom_type = "complexity"
on_violation = '''Not applicable'''
reviewed = true

[[axioms]]
id = "ilp_for_t_auto_precond_start_end_valid"
content = '''The start and end arguments must be valid expressions that can be passed to ilp::iota, forming a valid range [start, end)'''
formal_spec = '''valid_expr(start) && valid_expr(end) && valid_range(start, end)'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "ILP_FOR_T_AUTO"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
signature = '''ILP_FOR_T_AUTO(ret_type, loop_var_decl, start, end, loop_type, element_type)'''
axiom_type = "precondition"
on_violation = '''Compilation error or runtime error from ilp::iota if range is invalid'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4']
reviewed = true

[[axioms]]
id = "ilp_for_t_auto_precond_loop_var_decl_valid"
content = '''The loop_var_decl must be a valid variable declaration compatible with range-based for loop syntax (e.g., 'auto i' or 'int i')'''
formal_spec = '''valid_var_decl(loop_var_decl) && compatible_with_range_for(loop_var_decl)'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "ILP_FOR_T_AUTO"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
signature = '''ILP_FOR_T_AUTO(ret_type, loop_var_decl, start, end, loop_type, element_type)'''
axiom_type = "precondition"
on_violation = '''Compilation error due to invalid for-loop syntax'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'ilp_for_range_t_range_single_eval', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4']
reviewed = true

[[axioms]]
id = "ilp_for_t_auto_constraint_element_type_compatible"
content = '''The element_type parameter must be compatible with the type returned by ilp::iota iterator dereference, though it is unused in the expansion'''
formal_spec = '''compatible_types(element_type, decltype(*begin(ilp::iota(start, end))))'''
layer = "library"
confidence = 0.85
source_file = ""
source_module = ""
function = "ILP_FOR_T_AUTO"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
signature = '''ILP_FOR_T_AUTO(ret_type, loop_var_decl, start, end, loop_type, element_type)'''
axiom_type = "constraint"
on_violation = '''Parameter is ignored in expansion; mismatch may indicate API misuse'''
depends_on = ['for_loop_range_untyped_impl_precond_iterator_random_access_b2c3d4e5', 'for_loop_range_impl_anti_pattern_non_random_access_e5f6a7b8', 'for_loop_range_typed_impl_precond_iterator_random_access_e5f6a7b8']
reviewed = true

[[axioms]]
id = "ilp_for_t_auto_constraint_ret_type_unused"
content = '''The ret_type parameter is unused in macro expansion and serves only for API compatibility'''
formal_spec = '''unused_param(ret_type)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_FOR_T_AUTO"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
signature = '''ILP_FOR_T_AUTO(ret_type, loop_var_decl, start, end, loop_type, element_type)'''
axiom_type = "constraint"
on_violation = '''No violation; parameter has no effect on expansion'''
reviewed = true

[[axioms]]
id = "ilp_for_t_auto_constraint_loop_type_unused"
content = '''The loop_type parameter is unused in macro expansion and serves only for API compatibility'''
formal_spec = '''unused_param(loop_type)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_FOR_T_AUTO"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
signature = '''ILP_FOR_T_AUTO(ret_type, loop_var_decl, start, end, loop_type, element_type)'''
axiom_type = "constraint"
on_violation = '''No violation; parameter has no effect on expansion'''
reviewed = true

[[axioms]]
id = "ilp_for_t_auto_effect_single_eval_parenthesized"
content = '''The start and end arguments are parenthesized in the expansion, protecting against precedence issues, and are passed to ilp::iota which evaluates them once during range construction'''
formal_spec = '''eval_count(start) == 1 && eval_count(end) == 1 && parenthesized(start) && parenthesized(end)'''
layer = "library"
confidence = 0.95
source_file = ""
source_module = ""
function = "ILP_FOR_T_AUTO"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
signature = '''ILP_FOR_T_AUTO(ret_type, loop_var_decl, start, end, loop_type, element_type)'''
axiom_type = "effect"
on_violation = '''Not applicable; macro is safely designed'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'cpp20_basic_life_vacuous_initialization_def_7c4e5d6a', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4', 'cpp20_dcl_init_list_copy_list_init_explicit_ctor_f2a3b4c5', 'cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8']
reviewed = true

[[axioms]]
id = "ilp_for_t_auto_postcond_range_for_expansion"
content = '''Macro expands to a C++11 range-based for loop iterating over the range returned by ilp::iota(start, end)'''
formal_spec = '''expands_to(ILP_FOR_T_AUTO(...), 'for (loop_var_decl : ::ilp::iota((start), (end)))')'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_FOR_T_AUTO"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
signature = '''ILP_FOR_T_AUTO(ret_type, loop_var_decl, start, end, loop_type, element_type)'''
axiom_type = "postcondition"
on_violation = '''Not applicable; guaranteed by preprocessor'''
depends_on = ['ilp_for_range_t_range_single_eval', 'for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4']
reviewed = true

[[axioms]]
id = "ilp_for_t_auto_anti_pattern_unused_params"
content = '''Three of six parameters (ret_type, loop_type, element_type) are unused in the expansion, suggesting this macro may be part of a parameterized macro family where different variants use different parameters'''
formal_spec = '''unused_param(ret_type) && unused_param(loop_type) && unused_param(element_type)'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "ILP_FOR_T_AUTO"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
signature = '''ILP_FOR_T_AUTO(ret_type, loop_var_decl, start, end, loop_type, element_type)'''
axiom_type = "anti_pattern"
on_violation = '''Not applicable; indicates API design pattern, not a bug'''
reviewed = true

[[axioms]]
id = "ilp_for_t_auto_complexity_iota_construction"
content = '''Macro expansion constructs an ilp::iota range object; complexity depends on iota implementation (typically O(1) for range construction)'''
formal_spec = '''complexity(ILP_FOR_T_AUTO) == O(1) + complexity(ilp::iota(start, end))'''
layer = "library"
confidence = 0.85
source_file = ""
source_module = ""
function = "ILP_FOR_T_AUTO"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
signature = '''ILP_FOR_T_AUTO(ret_type, loop_var_decl, start, end, loop_type, element_type)'''
axiom_type = "complexity"
on_violation = '''Not applicable; performance characteristic'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'cpp20_basic_life_vacuous_initialization_def_7c4e5d6a', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4', 'cpp20_dcl_init_list_copy_list_init_explicit_ctor_f2a3b4c5', 'cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8']
reviewed = true

[[axioms]]
id = "ilp_for_t_auto_constraint_requires_cpp11"
content = '''Macro requires C++11 or later due to use of range-based for loop syntax'''
formal_spec = '''cpp_standard >= cpp11'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_FOR_T_AUTO"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
signature = '''ILP_FOR_T_AUTO(ret_type, loop_var_decl, start, end, loop_type, element_type)'''
axiom_type = "constraint"
on_violation = '''Compilation error in pre-C++11 mode'''
depends_on = ['ilp_for_range_t_range_single_eval', 'for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4']
reviewed = true

[[axioms]]
id = "ilp_for_t_auto_precond_iota_visible"
content = '''The ::ilp::iota function must be visible and callable at the point of macro expansion'''
formal_spec = '''callable(::ilp::iota) && visible(::ilp::iota)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_FOR_T_AUTO"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
signature = '''ILP_FOR_T_AUTO(ret_type, loop_var_decl, start, end, loop_type, element_type)'''
axiom_type = "precondition"
on_violation = '''Compilation error: ilp::iota not found'''
reviewed = true

[[axioms]]
id = "ilp_for_range_t_auto_range_eval_once_e8a4b7c2"
content = '''The range argument is evaluated exactly once during macro expansion due to parenthesization, protecting against multiple evaluation side effects'''
formal_spec = '''eval_count(range) == 1'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_FOR_RANGE_T_AUTO"
header = "ilp_for/detail/macros_simple.hpp"
signature = '''ILP_FOR_RANGE_T_AUTO(ret_type, loop_var_decl, range, loop_type, element_type)'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by macro structure'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4']
reviewed = true

[[axioms]]
id = "ilp_for_range_t_auto_loop_var_scope_d3c9f1a5"
content = '''The loop_var_decl introduces a new variable scoped to the for-loop body, following C++ range-for semantics'''
formal_spec = '''scope(loop_var_decl) == for_loop_body && lifetime(loop_var_decl) == for_loop_iterations'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_FOR_RANGE_T_AUTO"
header = "ilp_for/detail/macros_simple.hpp"
signature = '''ILP_FOR_RANGE_T_AUTO(ret_type, loop_var_decl, range, loop_type, element_type)'''
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed by C++ language semantics'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4']
reviewed = true

[[axioms]]
id = "ilp_for_range_t_auto_range_type_constraint_a2b8e4f7"
content = '''The range argument must be a valid range-expression: either an array, or an object with begin() and end() methods, or compatible with std::begin/std::end'''
formal_spec = '''is_array(range) || (has_method(range, begin) && has_method(range, end)) || (adl_findable(begin, range) && adl_findable(end, range))'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_FOR_RANGE_T_AUTO"
header = "ilp_for/detail/macros_simple.hpp"
signature = '''ILP_FOR_RANGE_T_AUTO(ret_type, loop_var_decl, range, loop_type, element_type)'''
axiom_type = "constraint"
on_violation = '''Compilation error: invalid range-based for loop'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4', 'for_loop_range_untyped_impl_constraint_array_bounds_remainder_b8c9d0e1', 'for_loop_range_typed_impl_constraint_array_access_inner_n7o8p9q0', 'for_loop_range_typed_impl_constraint_array_access_remainder_r1s2t3u4']
reviewed = true

[[axioms]]
id = "ilp_for_range_t_auto_unused_params_b7d3a9c6"
content = '''The ret_type, loop_type, and element_type parameters are accepted but ignored in the macro expansion, making them vestigial and potentially misleading'''
formal_spec = '''!appears_in_expansion(ret_type) && !appears_in_expansion(loop_type) && !appears_in_expansion(element_type)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_FOR_RANGE_T_AUTO"
header = "ilp_for/detail/macros_simple.hpp"
signature = '''ILP_FOR_RANGE_T_AUTO(ret_type, loop_var_decl, range, loop_type, element_type)'''
axiom_type = "anti_pattern"
on_violation = '''No runtime violation - but misleading API that suggests type control where none exists'''
reviewed = true

[[axioms]]
id = "ilp_for_range_t_auto_no_side_effects_expansion_c5f2e8d1"
content = '''Macro expansion performs simple textual substitution with no side effects at preprocessing time'''
formal_spec = '''noSideEffects(ILP_FOR_RANGE_T_AUTO) && evaluationTime(ILP_FOR_RANGE_T_AUTO) == runtime'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_FOR_RANGE_T_AUTO"
header = "ilp_for/detail/macros_simple.hpp"
signature = '''ILP_FOR_RANGE_T_AUTO(ret_type, loop_var_decl, range, loop_type, element_type)'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by preprocessor semantics'''
depends_on = ['ilp_n_transform_8_effect_no_side_effects', 'ilp_cpu_profile_macro_context_independence']
reviewed = true

[[axioms]]
id = "ilp_for_range_t_auto_loop_var_type_deduced_f9a3c7e2"
content = '''The type of the loop variable is deduced from the loop_var_decl, which may include auto, const auto&, auto&&, or explicit type specifications'''
formal_spec = '''type(loop_var) == deduce_from_declaration(loop_var_decl, range)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_FOR_RANGE_T_AUTO"
header = "ilp_for/detail/macros_simple.hpp"
signature = '''ILP_FOR_RANGE_T_AUTO(ret_type, loop_var_decl, range, loop_type, element_type)'''
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed by C++ type deduction rules'''
reviewed = true

[[axioms]]
id = "ilp_for_range_t_auto_complexity_linear_d8b4a1c3"
content = '''The macro expands to a standard range-for loop with complexity O(n) where n is the size of the range, plus the complexity of the loop body'''
formal_spec = '''time_complexity(ILP_FOR_RANGE_T_AUTO) == O(size(range)) + O(loop_body)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_FOR_RANGE_T_AUTO"
header = "ilp_for/detail/macros_simple.hpp"
signature = '''ILP_FOR_RANGE_T_AUTO(ret_type, loop_var_decl, range, loop_type, element_type)'''
axiom_type = "complexity"
on_violation = '''N/A - informational'''
depends_on = ['for_loop_range_impl_precond_range_valid_b3c4d5e6', 'for_loop_range_typed_impl_effect_forwards_range_p5q6r7s8', 'for_loop_range_typed_auto_precond_range_valid_a1b2c3d4']
reviewed = true

[[axioms]]
id = "ilp_end_macro_empty_expansion"
content = '''ILP_END expands to nothing (empty expansion), acting as a syntactic marker'''
formal_spec = '''expansion(ILP_END) = ε'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_END"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
signature = '''ILP_END'''
axiom_type = "postcondition"
on_violation = '''N/A - macro always expands to empty string'''
reviewed = true

[[axioms]]
id = "ilp_end_macro_precondition_paired"
content = '''ILP_END should be paired with a corresponding ILP_BEGIN or similar opening macro to form a syntactic block'''
formal_spec = '''∃ ILP_BEGIN: lexically_precedes(ILP_BEGIN, ILP_END) ∧ properly_nested(ILP_BEGIN, ILP_END)'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "ILP_END"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
signature = '''ILP_END'''
axiom_type = "precondition"
on_violation = '''compilation error or incorrect program structure if unpaired'''
reviewed = true

[[axioms]]
id = "ilp_end_macro_anti_pattern_standalone"
content = '''Using ILP_END without a corresponding opening macro creates unbalanced syntactic structure'''
formal_spec = '''¬∃ ILP_BEGIN: lexically_precedes(ILP_BEGIN, ILP_END) ⇒ malformed_structure'''
layer = "library"
confidence = 0.85
source_file = ""
source_module = ""
function = "ILP_END"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
signature = '''ILP_END'''
axiom_type = "anti_pattern"
on_violation = '''likely compilation error or unintended program behavior'''
reviewed = true

[[axioms]]
id = "ilp_end_macro_effect_no_side_effects"
content = '''ILP_END has no side effects as it expands to nothing'''
formal_spec = '''side_effects(ILP_END) = ∅'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_END"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
signature = '''ILP_END'''
axiom_type = "effect"
on_violation = '''N/A - no side effects possible'''
reviewed = true

[[axioms]]
id = "ILP_END_RETURN_macro_empty_expansion"
content = '''ILP_END_RETURN expands to empty text, producing no tokens in the preprocessing output'''
formal_spec = '''expansion(ILP_END_RETURN) = ε'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_END_RETURN"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
signature = '''ILP_END_RETURN'''
axiom_type = "effect"
on_violation = '''N/A - macro always expands to nothing'''
reviewed = true

[[axioms]]
id = "ILP_END_RETURN_macro_statement_context"
content = '''ILP_END_RETURN should only be used in contexts where an empty statement or removal of text is syntactically valid'''
formal_spec = '''context_allows_empty_expansion(ILP_END_RETURN) = true'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "ILP_END_RETURN"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
signature = '''ILP_END_RETURN'''
axiom_type = "precondition"
on_violation = '''Compilation error if used in context requiring tokens (e.g., as function argument)'''
reviewed = true

[[axioms]]
id = "ILP_END_RETURN_macro_marker_semantics"
content = '''ILP_END_RETURN serves as a syntactic marker in macro-based control flow, likely paired with ILP_BEGIN or similar constructs'''
formal_spec = '''∃ paired_macro : paired_with(ILP_END_RETURN, paired_macro)'''
layer = "library"
confidence = 0.85
source_file = ""
source_module = ""
function = "ILP_END_RETURN"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
signature = '''ILP_END_RETURN'''
axiom_type = "constraint"
on_violation = '''Correct behavior - macro still expands to nothing, but may indicate missing paired construct'''
depends_on = ['cpp20_dcl_init_list_copy_list_init_explicit_ctor_f2a3b4c5', 'cpp20_basic_life_vacuous_initialization_def_7c4e5d6a', 'cpp20_dcl_init_list_class_constructor_narrowing_d5e6f7a8']
reviewed = true

[[axioms]]
id = "ILP_END_RETURN_macro_no_side_effects"
content = '''Expansion of ILP_END_RETURN produces no side effects, no code generation, and does not affect program semantics beyond its removal'''
formal_spec = '''side_effects(ILP_END_RETURN) = ∅ ∧ runtime_behavior(with_ILP_END_RETURN) ≡ runtime_behavior(without_ILP_END_RETURN)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_END_RETURN"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
signature = '''ILP_END_RETURN'''
axiom_type = "postcondition"
on_violation = '''N/A - macro has no operational semantics'''
reviewed = true

[[axioms]]
id = "ilp_continue_precondition_loop_context"
content = '''ILP_CONTINUE must be used within a loop context (for, while, do-while)'''
formal_spec = '''context ∈ {for_loop, while_loop, do_while_loop}'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_CONTINUE"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
signature = '''ILP_CONTINUE'''
axiom_type = "precondition"
on_violation = '''compilation error: 'continue' statement not in loop statement'''
reviewed = true

[[axioms]]
id = "ilp_continue_effect_next_iteration"
content = '''ILP_CONTINUE causes immediate jump to the next iteration of the enclosing loop, skipping remaining statements in the current iteration'''
formal_spec = '''control_flow_transfers_to(next_iteration(enclosing_loop)) ∧ statements_after_continue_not_executed'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_CONTINUE"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
signature = '''ILP_CONTINUE'''
axiom_type = "effect"
on_violation = '''N/A - macro expands to continue keyword'''
reviewed = true

[[axioms]]
id = "ilp_continue_postcondition_no_return"
content = '''Statements following ILP_CONTINUE in the same block are unreachable'''
formal_spec = '''∀ stmt : stmt.position > ILP_CONTINUE.position ∧ stmt.block == ILP_CONTINUE.block → unreachable(stmt)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_CONTINUE"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
signature = '''ILP_CONTINUE'''
axiom_type = "postcondition"
on_violation = '''N/A - subsequent statements not executed'''
reviewed = true

[[axioms]]
id = "ilp_continue_anti_pattern_switch"
content = '''ILP_CONTINUE should not be used in a switch statement without an enclosing loop (use break instead)'''
formal_spec = '''¬(context == switch_statement ∧ ¬has_enclosing_loop)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_CONTINUE"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
signature = '''ILP_CONTINUE'''
axiom_type = "anti_pattern"
on_violation = '''compilation error: 'continue' statement not in loop statement'''
reviewed = true

[[axioms]]
id = "ilp_continue_complexity_constant"
content = '''ILP_CONTINUE has O(1) time complexity - it is a simple control flow transfer'''
formal_spec = '''time_complexity(ILP_CONTINUE) = O(1)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_CONTINUE"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
signature = '''ILP_CONTINUE'''
axiom_type = "complexity"
on_violation = '''N/A'''
reviewed = true

[[axioms]]
id = "ilp_break.precondition.loop_context"
content = '''ILP_BREAK must be used within a loop context (for, while, do-while) or switch statement where break is valid'''
formal_spec = '''context ∈ {loop_body, switch_case}'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_BREAK"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
signature = '''ILP_BREAK'''
axiom_type = "precondition"
on_violation = '''Compilation error: break statement not within loop or switch'''
depends_on = ['ilp_continue_anti_pattern_switch']
reviewed = true

[[axioms]]
id = "ilp_break.effect.loop_termination"
content = '''Expands to a break statement that immediately exits the innermost enclosing loop or switch statement'''
formal_spec = '''ILP_BREAK ≡ break ⟹ control_flow_exits_innermost_loop'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_BREAK"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
signature = '''ILP_BREAK'''
axiom_type = "effect"
on_violation = '''N/A - direct textual substitution'''
depends_on = ['ilp_continue_anti_pattern_switch']
reviewed = true

[[axioms]]
id = "ilp_break.postcondition.no_evaluation"
content = '''After ILP_BREAK, no subsequent statements in the current loop/switch iteration are executed'''
formal_spec = '''∀stmt: after(ILP_BREAK, stmt) ∧ same_scope(ILP_BREAK, stmt) ⟹ ¬executed(stmt)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_BREAK"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
signature = '''ILP_BREAK'''
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed by break semantics'''
reviewed = true

[[axioms]]
id = "ilp_break.anti_pattern.nested_context"
content = '''ILP_BREAK only exits the innermost loop/switch; to exit outer loops, different mechanisms are needed'''
formal_spec = '''nested_depth(loop) > 1 ⟹ ILP_BREAK exits only innermost'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_BREAK"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
signature = '''ILP_BREAK'''
axiom_type = "anti_pattern"
on_violation = '''Logic error: outer loops continue execution when only inner loop should be exited'''
reviewed = true

[[axioms]]
id = "ilp_break.complexity.constant"
content = '''ILP_BREAK has O(1) time and space complexity - simple control flow transfer'''
formal_spec = '''time_complexity(ILP_BREAK) = O(1) ∧ space_complexity(ILP_BREAK) = O(1)'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_BREAK"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
signature = '''ILP_BREAK'''
axiom_type = "complexity"
on_violation = '''N/A - inherent property'''
reviewed = true

[[axioms]]
id = "ilp_return_macro_precond_in_function_scope"
content = '''The macro must be used within a function scope where 'return' is valid'''
formal_spec = '''∃ enclosing_function: ILP_RETURN(x) appears in enclosing_function.body'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_RETURN"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
signature = '''ILP_RETURN(x)'''
axiom_type = "precondition"
on_violation = '''Compilation error: return statement not within function body'''
reviewed = true

[[axioms]]
id = "ilp_return_macro_precond_type_compatible"
content = '''The expression x must be convertible to the enclosing function's return type'''
formal_spec = '''typeof(x) is_convertible_to enclosing_function.return_type'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_RETURN"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
signature = '''ILP_RETURN(x)'''
axiom_type = "precondition"
on_violation = '''Compilation error: cannot convert return expression type'''
reviewed = true

[[axioms]]
id = "ilp_return_macro_effect_single_evaluation"
content = '''The argument x is evaluated exactly once during the return statement execution'''
formal_spec = '''eval_count(x) == 1'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_RETURN"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
signature = '''ILP_RETURN(x)'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by language semantics'''
depends_on = ['cpp20_except_ctor_return_obj_destroy_on_throw_c9e5f0d4']
reviewed = true

[[axioms]]
id = "ilp_return_macro_effect_no_preprocessing_side_effects"
content = '''Macro expansion performs simple textual substitution with no side effects at preprocessing time'''
formal_spec = '''expansion_side_effects(ILP_RETURN) == ∅ && evaluationTime(ILP_RETURN) == runtime'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_RETURN"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
signature = '''ILP_RETURN(x)'''
axiom_type = "effect"
on_violation = '''N/A - guaranteed by preprocessor semantics'''
depends_on = ['ilp_cpu_profile_macro_context_independence', 'ilp_n_transform_8_effect_no_side_effects', 'ilp_n_divide_4f_macro_effect_no_side_effects']
reviewed = true

[[axioms]]
id = "ilp_return_macro_postcond_control_transfer"
content = '''Execution control transfers to the caller of the enclosing function with the value of x'''
formal_spec = '''∀ caller: after ILP_RETURN(x), control_flow_at(caller) && return_value == x'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_RETURN"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
signature = '''ILP_RETURN(x)'''
axiom_type = "postcondition"
on_violation = '''N/A - guaranteed by return statement semantics'''
reviewed = true

[[axioms]]
id = "ilp_return_macro_anti_pattern_complex_expression"
content = '''While safe, using ILP_RETURN instead of bare 'return' provides no benefit and reduces code clarity'''
formal_spec = '''readability(ILP_RETURN(x)) < readability(return x)'''
layer = "library"
confidence = 0.9
source_file = ""
source_module = ""
function = "ILP_RETURN"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
signature = '''ILP_RETURN(x)'''
axiom_type = "anti_pattern"
on_violation = '''Reduced code maintainability'''
reviewed = true

[[axioms]]
id = "ilp_return_macro_constraint_no_parenthesization_needed"
content = '''No argument parenthesization is needed because 'return' statement handles arbitrary expressions safely'''
formal_spec = '''∀ expr: ILP_RETURN(expr) ≡ return expr, regardless of expr operator precedence'''
layer = "library"
confidence = 1.0
source_file = ""
source_module = ""
function = "ILP_RETURN"
header = "/home/mvarendorff/Documents/Code/cpp/ilp_for/ilp_for/detail/macros_simple.hpp"
signature = '''ILP_RETURN(x)'''
axiom_type = "constraint"
on_violation = '''N/A - return statement semantics protect against precedence issues'''
reviewed = true
