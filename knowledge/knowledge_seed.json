[
  {
    "content": "ILP (Instruction-Level Parallelism) is a CPU's ability to execute multiple instructions simultaneously through superscalar execution. Modern CPUs have multiple execution ports (Skylake has 8) that can operate in parallel. To saturate these ports, code needs independent operations that don't wait on each other's results. Loop-carried dependencies (where each iteration depends on the previous result) limit ILP. The optimal unroll factor N follows N ≈ Latency × Throughput to keep enough operations in flight to hide latency.",
    "source": "docs",
    "validated_by": "human",
    "confidence": 1.0,
    "related_symbols": [
      "ILP_FOR",
      "optimal_N",
      "LoopType"
    ],
    "tags": [
      "concept",
      "fundamentals",
      "cpu-architecture"
    ],
    "created_at": "2025-12-23T15:00:00.000000",
    "category": "semantics"
  },
  {
    "content": "Do NOT use ILP_FOR for simple loops without early exit. Standard loops with #pragma unroll or auto-vectorization are often equivalent or better. ILP_FOR is specifically for loops with break/continue/return.",
    "source": "conversation",
    "validated_by": "human",
    "confidence": 0.9,
    "related_symbols": [
      "ILP_FOR"
    ],
    "tags": [
      "when-not-to-use",
      "performance"
    ],
    "created_at": "2025-12-22T21:40:50.056793",
    "category": "antipatterns"
  },
  {
    "content": "Target specific CPU architectures with -DILP_CPU_SKYLAKE, -DILP_CPU_ALDERLAKE, -DILP_CPU_APPLE_M1, or -DILP_CPU_ZEN5. Without this, _AUTO macros use default unroll factors. Supports uppercase and lowercase variants (ILP_CPU_skylake).",
    "source": "docs",
    "validated_by": "human",
    "confidence": 0.9,
    "related_symbols": [
      "ILP_CPU_SKYLAKE",
      "ILP_CPU_ZEN5",
      "ILP_CPU_APPLE_M1",
      "optimal_N"
    ],
    "tags": [
      "compilation",
      "architecture",
      "tuning"
    ],
    "created_at": "2025-12-22T21:49:23.987306",
    "category": "compiler"
  },
  {
    "content": "Use -DILP_MODE_SIMPLE for debugging. This turns all ILP macros into simple for loops with the same semantics: ILP_FOR becomes for loop, ILP_BREAK becomes break, ILP_CONTINUE becomes continue, ILP_RETURN(x) becomes return x.",
    "source": "docs",
    "validated_by": "human",
    "confidence": 0.9,
    "related_symbols": [
      "ILP_MODE_SIMPLE",
      "ILP_BREAK",
      "ILP_CONTINUE",
      "ILP_RETURN"
    ],
    "tags": [
      "debugging",
      "compilation",
      "simple-mode"
    ],
    "created_at": "2025-12-22T21:52:32.467891",
    "category": "compiler"
  },
  {
    "content": "Override SBO buffer size with -DILP_SBO_SIZE=16 at compile time. Default is sizeof(std::intmax_t), typically 8 bytes. Increase for return types larger than 8 bytes when you want to avoid using ILP_FOR_T explicitly.",
    "source": "docs",
    "validated_by": "human",
    "confidence": 0.9,
    "related_symbols": [
      "ILP_SBO_SIZE"
    ],
    "tags": [],
    "created_at": "2025-12-22T22:16:45.265222",
    "category": "compiler"
  },
  {
    "content": "ILP_END_RETURN must be used instead of ILP_END when ILP_RETURN appears in the loop body. Using ILP_END will cause compilation errors or undefined behavior.",
    "source": "conversation",
    "validated_by": "human",
    "confidence": 0.9,
    "related_symbols": [
      "ILP_RETURN",
      "ILP_END",
      "ILP_END_RETURN"
    ],
    "tags": [
      "macro",
      "return",
      "common-mistake"
    ],
    "created_at": "2025-12-22T21:39:00.402442",
    "category": "gotchas"
  },
  {
    "content": "ILP_FOR and ILP_FOR_AUTO use a small buffer optimization (SBO) for return values. Buffer size is sizeof(std::intmax_t), typically 8 bytes on 64-bit. Works for types that are: \u2264 SBO size, \u2264 SBO alignment, and trivially destructible. Covers int, size_t, pointers, simple structs. Violations caught at compile time via static_assert. For larger/complex types, use ILP_FOR_T with explicit return type.",
    "source": "conversation",
    "validated_by": "human",
    "confidence": 0.9,
    "related_symbols": [
      "ILP_FOR",
      "ILP_FOR_T",
      "ILP_FOR_AUTO",
      "ILP_RETURN"
    ],
    "tags": [
      "return-type",
      "sbo",
      "large-types"
    ],
    "created_at": "2025-12-22T21:43:04.611839",
    "category": "gotchas"
  },
  {
    "content": "ILP_BREAK and ILP_CONTINUE cannot be used inside nested for/while loops within the ILP_FOR body. They use return from the body lambda, so they would break/continue from the wrong scope. Only use them at the ILP_FOR body level, not inside inner loops.",
    "source": "docs",
    "validated_by": "human",
    "confidence": 0.9,
    "related_symbols": [
      "ILP_BREAK",
      "ILP_CONTINUE"
    ],
    "tags": [],
    "created_at": "2025-12-22T22:18:56.654390",
    "category": "gotchas"
  },
  {
    "content": "C++20 is required. ILP_FOR is header-only - just #include <ilp_for.hpp>. No linking required.",
    "source": "docs",
    "validated_by": "human",
    "confidence": 1.0,
    "related_symbols": [
      "ilp_for.hpp"
    ],
    "tags": [],
    "created_at": "2025-12-22T22:19:42.332989",
    "category": "gotchas"
  },
  {
    "content": "ILP_FOR is portable across GCC, Clang, and MSVC. The macro uses an if-statement + lambda pattern instead of GCC-only statement expressions. Requires C++20. Header-only with no dependencies beyond the standard library.",
    "source": "docs",
    "validated_by": "human",
    "confidence": 1.0,
    "related_symbols": [
      "ILP_FOR",
      "portability"
    ],
    "tags": [
      "portability",
      "compiler-support"
    ],
    "created_at": "2025-12-23T16:00:00.000000",
    "category": "compiler"
  },
  {
    "content": "Code bloat: For loops WITH early exit, ILP_FOR expands code (unrolled iterations + exit tracking logic). For loops WITHOUT early exit, compilers produce identical SIMD assembly to standard loops - no bloat. Only use ILP_FOR when you need early exit.",
    "source": "docs",
    "validated_by": "human",
    "confidence": 0.9,
    "related_symbols": [
      "ILP_FOR",
      "code-size"
    ],
    "tags": [
      "code-bloat",
      "binary-size"
    ],
    "created_at": "2025-12-23T16:00:00.000000",
    "category": "performance"
  },
  {
    "content": "ILP_FOR uses exclusive end like Python range(): ILP_FOR(auto i, 0, 10, 4) iterates i=0,1,...,9 (10 iterations). NOT like C-style for(i=0; i<=10; i++) which would be 11 iterations. Off-by-one errors are common when users expect inclusive end.",
    "source": "test",
    "validated_by": "human",
    "confidence": 1.0,
    "related_symbols": [
      "ILP_FOR"
    ],
    "tags": [],
    "created_at": "2025-12-22T22:29:17.755360",
    "category": "gotchas"
  },
  {
    "content": "Unroll factor N > 16 triggers a deprecation warning at compile time: 'N > 16 is likely counterproductive: exceeds CPU execution port throughput and causes instruction cache bloat. Typical optimal values are 4-8.' Use _AUTO macros to auto-select optimal N.",
    "source": "test",
    "validated_by": "human",
    "confidence": 1.0,
    "related_symbols": [
      "ILP_FOR",
      "optimal_N"
    ],
    "tags": [],
    "created_at": "2025-12-22T22:30:10.560446",
    "category": "gotchas"
  },
  {
    "content": "Loop variable is read-only: you cannot modify the loop variable i inside ILP_FOR. If you need to modify, copy to a local: auto local_i = i; local_i *= 2; The original iteration variable continues unchanged.",
    "source": "test",
    "validated_by": "human",
    "confidence": 1.0,
    "related_symbols": [
      "ILP_FOR"
    ],
    "tags": [],
    "created_at": "2025-12-22T22:30:35.090710",
    "category": "gotchas"
  },
  {
    "content": "ILP_FOR_RANGE requires an lvalue container, not a temporary. Store in a variable first: std::vector<int> v = {1,2,3}; ILP_FOR_RANGE(auto&& val, v, 4) {...} - the 'v' must be a named variable, not an inline initializer.",
    "source": "test",
    "validated_by": "human",
    "confidence": 0.9,
    "related_symbols": [
      "ILP_FOR_RANGE"
    ],
    "tags": [],
    "created_at": "2025-12-22T22:31:44.292189",
    "category": "gotchas"
  },
  {
    "content": "ILP_FOR_RANGE does not provide index access. If you need both index and value, either use ILP_FOR with arr[i], or track index manually: int idx = 0; ILP_FOR_RANGE(auto&& val, data, 4) { use(idx, val); idx++; } ILP_END;",
    "source": "test",
    "validated_by": "human",
    "confidence": 1.0,
    "related_symbols": [
      "ILP_FOR_RANGE",
      "ILP_FOR"
    ],
    "tags": [],
    "created_at": "2025-12-22T22:32:23.680852",
    "category": "gotchas"
  },
  {
    "content": "ILP_FOR provides ~1.5x speedup over #pragma unroll for early exit loops by avoiding per-iteration bounds checks. The main loop processes N elements with one bounds check, remainder loop handles leftovers.",
    "source": "docs",
    "validated_by": "human",
    "confidence": 0.9,
    "related_symbols": [
      "ILP_FOR"
    ],
    "tags": [
      "speedup",
      "bounds-check",
      "pragma"
    ],
    "created_at": "2025-12-22T21:54:34.849858",
    "category": "performance"
  },
  {
    "content": "CPU profile headers in cpu_profiles/ contain instruction timing data. Columns: Latency (L) = cycles from input to output, RThr = reciprocal throughput (cycles between new ops), TPC = 1/RThr, L\u00d7TPC = optimal unroll factor. Formula: optimal_N = Latency \u00d7 TPC. Create custom profiles from uops.info or Agner Fog's tables.",
    "source": "docs",
    "validated_by": "human",
    "confidence": 0.9,
    "related_symbols": [
      "cpu_profiles",
      "optimal_N",
      "Latency",
      "TPC"
    ],
    "tags": [],
    "created_at": "2025-12-22T22:17:57.959775",
    "category": "performance"
  },
  {
    "content": "#pragma unroll is insufficient for early exit loops because SCEV (Scalar Evolution) cannot determine trip count for loops with break. Compilers insert bounds checks after EACH unrolled element, negating the unroll benefit. ILP_FOR uses main loop + remainder pattern that checks bounds only once per block, giving ~1.5x speedup. See docs/PRAGMA_UNROLL.md for assembly evidence.",
    "source": "docs",
    "validated_by": "human",
    "confidence": 0.9,
    "related_symbols": [
      "pragma_unroll",
      "SCEV"
    ],
    "tags": [],
    "created_at": "2025-12-22T22:18:27.440032",
    "category": "performance"
  },
  {
    "content": "Default optimal_N values by type: Sum (int32/64: 4, float/double: 8), DotProduct (float/double: 8), Search (all: 4), MinMax (int: 4, float/double: 8), Multiply (all: 8), Bitwise/Shift (int only: 8), Copy/Transform (all: 4), Divide/Sqrt (float/double: 8). Use -DILP_CPU_* flags for architecture-specific values.",
    "source": "docs",
    "validated_by": "human",
    "confidence": 0.9,
    "related_symbols": [
      "optimal_N",
      "LoopType"
    ],
    "tags": [],
    "created_at": "2025-12-22T22:20:26.265829",
    "category": "performance"
  },
  {
    "content": "Assembly analysis: #pragma unroll generates ~6 instructions per element (load, compare, bounds check, conditional branch \u00d7 2). ILP_FOR generates ~4 instructions per element (load, compare, conditional branch only). The bounds check (cmp xN, xM; b.eq) appears after EACH element with pragma, but only once per block with ILP_FOR. This accounts for the ~1.5x speedup.",
    "source": "docs",
    "validated_by": "human",
    "confidence": 0.9,
    "related_symbols": [
      "pragma_unroll",
      "assembly"
    ],
    "tags": [],
    "created_at": "2025-12-22T22:23:31.032162",
    "category": "performance"
  },
  {
    "content": "ILP_FOR assembly structure on x86-64: main loop has load+compare for each of N elements in sequence, then a single bounds check (cmp rax, rsi; jbe loop) at the end of the block. All N element comparisons execute before the bounds check, allowing better instruction-level parallelism. Pattern: cmp [rdi+4*rax], edx; ja exit (\u00d7N times), then cmp rax, rsi; jbe loop.",
    "source": "docs",
    "validated_by": "human",
    "confidence": 0.9,
    "related_symbols": [
      "ILP_FOR",
      "x86-64",
      "assembly"
    ],
    "tags": [],
    "created_at": "2025-12-22T22:23:56.405079",
    "category": "performance"
  },
  {
    "content": "ARM64 assembly with ILP_FOR: uses ldur/ldr for loads, cmp for compare, b.hi/b.ls for conditional branches. Same pattern as x86-64: all N element loads and compares execute before the single bounds check. Pattern: ldur wN, [xM, #offset]; cmp wN, threshold; b.hi exit (\u00d7N times), then cmp counter, limit; b.ls loop.",
    "source": "docs",
    "validated_by": "human",
    "confidence": 0.9,
    "related_symbols": [
      "ILP_FOR",
      "ARM64",
      "assembly"
    ],
    "tags": [],
    "created_at": "2025-12-22T22:24:20.027914",
    "category": "performance"
  },
  {
    "content": "ILP_FOR generates assembly equivalent to hand-rolled main loop + remainder pattern. Both use: (1) main loop processing N elements with single bounds check, (2) remainder loop processing leftover elements one at a time. The macro handles the error-prone unrolling automatically while producing the same optimized code.",
    "source": "docs",
    "validated_by": "human",
    "confidence": 0.9,
    "related_symbols": [
      "ILP_FOR",
      "assembly"
    ],
    "tags": [],
    "created_at": "2025-12-22T22:25:03.802515",
    "category": "performance"
  },
  {
    "content": "For loops WITHOUT early exit, all approaches (simple loop, #pragma unroll, ILP_FOR) produce identical SIMD assembly. Compilers auto-vectorize to ld4.4s, cmhs.4s etc. Only use ILP_FOR when you have break/continue/return - it adds no benefit for simple loops.",
    "source": "docs",
    "validated_by": "human",
    "confidence": 0.9,
    "related_symbols": [
      "SIMD",
      "auto-vectorization"
    ],
    "tags": [],
    "created_at": "2025-12-22T22:25:26.829892",
    "category": "performance"
  },
  {
    "content": "ILP_FOR expands to a main loop processing N elements at a time with a single bounds check, plus a remainder loop handling leftover elements. This is NOT the same as #pragma unroll which checks bounds on every iteration.",
    "source": "conversation",
    "validated_by": "human",
    "confidence": 0.9,
    "related_symbols": [
      "ILP_FOR"
    ],
    "tags": [
      "expansion",
      "performance",
      "bounds-check"
    ],
    "created_at": "2025-12-22T21:40:04.033771",
    "category": "semantics"
  },
  {
    "content": "ILP_BREAK and ILP_CONTINUE use 'return' from the body lambda, not actual break/continue or goto. ILP_CONTINUE just returns, ILP_BREAK sets a control flag to false then returns. They work inside nested if/else. Cannot be used inside nested for/while loops since that would break from wrong scope.",
    "source": "conversation",
    "validated_by": "human",
    "confidence": 0.9,
    "related_symbols": [
      "ILP_BREAK",
      "ILP_CONTINUE"
    ],
    "tags": [
      "control-flow",
      "lambda",
      "nesting"
    ],
    "created_at": "2025-12-22T21:44:45.888301",
    "category": "semantics"
  },
  {
    "content": "Inverted range (start > end) produces zero iterations safely. ILP_FOR(auto i, 10, 0, 4) executes 0 times. Both signed and unsigned types behave the same - no undefined behavior, no crash, just zero iterations.",
    "source": "test",
    "validated_by": "human",
    "confidence": 1.0,
    "related_symbols": [
      "ILP_FOR"
    ],
    "tags": [],
    "created_at": "2025-12-22T22:26:16.131816",
    "category": "semantics"
  },
  {
    "content": "Iteration order is strictly sequential (0, 1, 2, ...) even though the loop is unrolled. Side effects happen in order. This is verified by tests that record iteration order to a vector and compare against expected sequence.",
    "source": "test",
    "validated_by": "human",
    "confidence": 1.0,
    "related_symbols": [
      "ILP_FOR"
    ],
    "tags": [],
    "created_at": "2025-12-22T22:27:01.543846",
    "category": "semantics"
  },
  {
    "content": "Remainder handling: when range size is not divisible by N, remaining elements are processed one at a time. For N=4 and range 0-9: main loop processes 0-7 (8 elements), remainder processes 8 (1 element). Works correctly even when N > range size (all elements go to remainder).",
    "source": "test",
    "validated_by": "human",
    "confidence": 1.0,
    "related_symbols": [
      "ILP_FOR"
    ],
    "tags": [],
    "created_at": "2025-12-22T22:27:28.724600",
    "category": "semantics"
  },
  {
    "content": "ILP_FOR captures outer variables by reference ([&] lambda capture). You can read and modify variables from outer scope inside the loop body. This is how accumulators like 'int sum = 0' work - sum is captured by reference and modified in each iteration.",
    "source": "test",
    "validated_by": "human",
    "confidence": 1.0,
    "related_symbols": [
      "ILP_FOR"
    ],
    "tags": [],
    "created_at": "2025-12-22T22:28:11.947032",
    "category": "semantics"
  },
  {
    "content": "Variable shadowing is safe: using the same variable name (e.g., 'i') in nested ILP_FOR loops or shadowing an outer variable is allowed. The outer variable remains unchanged after the loop. Each loop level has its own scope.",
    "source": "test",
    "validated_by": "human",
    "confidence": 1.0,
    "related_symbols": [
      "ILP_FOR"
    ],
    "tags": [],
    "created_at": "2025-12-22T22:28:46.114517",
    "category": "semantics"
  },
  {
    "content": "ILP_BREAK exits the loop, ILP_RETURN(x) exits the enclosing function and returns x. Common mistake: using ILP_BREAK when you meant ILP_RETURN, or vice versa. ILP_BREAK requires ILP_END, ILP_RETURN requires ILP_END_RETURN.",
    "source": "test",
    "validated_by": "human",
    "confidence": 1.0,
    "related_symbols": [
      "ILP_BREAK",
      "ILP_RETURN",
      "ILP_END",
      "ILP_END_RETURN"
    ],
    "tags": [],
    "created_at": "2025-12-22T22:32:40.835516",
    "category": "semantics"
  },
  {
    "content": "For loops with early exit (break/return), use LoopType::Search which optimizes for branch prediction. For accumulation without early exit, use LoopType::Sum.",
    "source": "conversation",
    "validated_by": "human",
    "confidence": 0.9,
    "related_symbols": [
      "ILP_FOR_AUTO",
      "LoopType"
    ],
    "tags": [
      "looptype",
      "optimization"
    ],
    "created_at": "2025-12-22T21:40:26.683329",
    "category": "usage_patterns"
  },
  {
    "content": "ILP_FOR syntax: ILP_FOR(var, start, end, N) { body } ILP_END; - the semicolon goes after ILP_END. When using ILP_RETURN in the body, you MUST use ILP_END_RETURN instead of ILP_END.",
    "source": "docs",
    "validated_by": "human",
    "confidence": 0.9,
    "related_symbols": [
      "ILP_FOR",
      "ILP_END",
      "ILP_END_RETURN"
    ],
    "tags": [
      "syntax",
      "semicolon",
      "syntax-gotcha"
    ],
    "created_at": "2025-12-22T21:50:41.887812",
    "category": "gotchas"
  },
  {
    "content": "Use ILP_FOR when your loop has early exit (break, continue, or return). For simple loops without early exit, prefer standard loops with #pragma unroll or auto-vectorization - they produce identical SIMD assembly. ILP_FOR adds no benefit for loops without control flow.",
    "source": "docs",
    "validated_by": "human",
    "confidence": 0.95,
    "related_symbols": [
      "ILP_FOR"
    ],
    "tags": [
      "when-to-use",
      "decision"
    ],
    "created_at": "2025-12-23T14:00:00.000000",
    "category": "usage_patterns"
  },
  {
    "content": "Use auto&& for ILP_FOR_RANGE to avoid copying elements: ILP_FOR_RANGE(auto&& val, container, N). Using 'auto val' copies each element which is slow for non-trivial types like std::string.",
    "source": "docs",
    "validated_by": "human",
    "confidence": 0.9,
    "related_symbols": [
      "ILP_FOR_RANGE",
      "ILP_FOR_RANGE_AUTO"
    ],
    "tags": [
      "range",
      "forwarding-reference",
      "performance"
    ],
    "created_at": "2025-12-22T21:51:54.595976",
    "category": "usage_patterns"
  },
  {
    "content": "LoopType selection for _AUTO macros: Search for early exit (break/return), Sum for acc+=val, DotProduct for acc+=a*b (FMA), MinMax for min/max reduction, Multiply for acc*=val, Bitwise for &|^, Shift for <<>>. If loop has early exit, always use Search regardless of other operations.",
    "source": "docs",
    "validated_by": "human",
    "confidence": 0.9,
    "related_symbols": [
      "LoopType",
      "ILP_FOR_AUTO"
    ],
    "tags": [
      "looptype",
      "selection",
      "optimization"
    ],
    "created_at": "2025-12-22T21:53:11.349716",
    "category": "usage_patterns"
  },
  {
    "content": "For debugging, compile with -DILP_MODE_SIMPLE -O0 -g to turn ILP macros into simple for loops. ILP_FOR becomes for(auto i : ilp::iota(start, end)), ILP_CONTINUE becomes continue, ILP_BREAK becomes break, ILP_RETURN(x) becomes return x, and ILP_END/ILP_END_RETURN become empty. Preserves loop semantics while enabling debugger stepping.",
    "source": "docs",
    "validated_by": "human",
    "confidence": 0.9,
    "related_symbols": [
      "ILP_MODE_SIMPLE"
    ],
    "tags": [],
    "created_at": "2025-12-22T22:15:41.647934",
    "category": "usage_patterns"
  },
  {
    "content": "Query optimal unroll factor directly with: constexpr auto N = ilp::optimal_N<ilp::LoopType::Sum, double>; This returns the architecture-specific optimal N for that LoopType and element type. Useful when you need the value at compile time for other purposes.",
    "source": "docs",
    "validated_by": "human",
    "confidence": 0.9,
    "related_symbols": [
      "optimal_N",
      "LoopType"
    ],
    "tags": [],
    "created_at": "2025-12-22T22:16:14.870076",
    "category": "usage_patterns"
  },
  {
    "content": "LoopType selection decision tree: Has early exit (break/return)? Use Search. Doing acc += a * b (FMA)? Use DotProduct. Doing acc += val? Use Sum. Doing acc *= val? Use Multiply. Doing min/max? Use MinMax. Doing bitwise ops? Use Bitwise. Unsure? Use Search as safe default. Early exit always dominates - use Search regardless of other operations if loop has ILP_BREAK or ILP_RETURN.",
    "source": "docs",
    "validated_by": "human",
    "confidence": 0.9,
    "related_symbols": [
      "LoopType",
      "Search",
      "DotProduct",
      "Sum",
      "Multiply",
      "MinMax",
      "Bitwise"
    ],
    "tags": [],
    "created_at": "2025-12-22T22:17:10.081548",
    "category": "usage_patterns"
  },
  {
    "content": "Use ilp-loop-analysis clang-tidy check to detect patterns and suggest correct LoopType automatically. Located in tools/clang-tidy/. It warns when using wrong LoopType (e.g., Add instead of Search for loops with early exit) and suggests both portable fix (correct LoopType) and architecture-specific fix (explicit N value).",
    "source": "docs",
    "validated_by": "human",
    "confidence": 0.9,
    "related_symbols": [
      "ilp-loop-analysis",
      "clang-tidy"
    ],
    "tags": [],
    "created_at": "2025-12-22T22:17:34.360667",
    "category": "usage_patterns"
  },
  {
    "content": "For index-based loops (ILP_FOR), use 'auto' for the loop variable since indices are just integers. For range-based loops (ILP_FOR_RANGE), use 'auto&&' to avoid copying elements. Example: ILP_FOR(auto i, 0, n, 4) vs ILP_FOR_RANGE(auto&& val, container, 4).",
    "source": "docs",
    "validated_by": "human",
    "confidence": 0.9,
    "related_symbols": [
      "ILP_FOR",
      "ILP_FOR_RANGE"
    ],
    "tags": [],
    "created_at": "2025-12-22T22:19:19.017813",
    "category": "usage_patterns"
  },
  {
    "content": "Mixed operations in loop WITHOUT early exit: pick LoopType for the bottleneck operation (slowest one on the critical path). acc += data[i] * weight[i] is FMA, use DotProduct. acc += data[i]; acc *= factor uses Multiply (slower). Mostly adds with occasional multiply use Sum. Mostly multiplies with occasional add use Multiply. IMPORTANT: If loop has ILP_BREAK or ILP_RETURN, always use Search regardless of other operations - early exit always dominates.",
    "source": "docs",
    "validated_by": "human",
    "confidence": 0.9,
    "related_symbols": [
      "LoopType",
      "DotProduct",
      "Sum",
      "Multiply",
      "Search",
      "ILP_BREAK",
      "ILP_RETURN"
    ],
    "tags": [],
    "created_at": "2025-12-22T22:20:02.889204",
    "category": "usage_patterns"
  },
  {
    "content": "When inspecting ILP_FOR assembly on Godbolt: look for (1) per-iteration bounds checks in pragma version (cmp + conditional branch after each element), (2) single bounds check at end of block in ILP version, (3) parallel comparisons vs sequential in register usage, (4) branch prediction patterns. Compiler settings: -std=c++2b -O3 -march=skylake (x86) or -mcpu=apple-m1 (ARM64).",
    "source": "docs",
    "validated_by": "human",
    "confidence": 0.9,
    "related_symbols": [
      "Godbolt",
      "assembly"
    ],
    "tags": [],
    "created_at": "2025-12-22T22:24:43.058105",
    "category": "usage_patterns"
  },
  {
    "content": "Nested ILP_FOR loops are fully supported up to 6+ levels deep. Each nested loop needs its own ILP_END. Inner loops can use ILP_BREAK/ILP_CONTINUE which only affects that inner loop. Different N values can be used at each nesting level. Triangular patterns (j depends on i) work correctly.",
    "source": "test",
    "validated_by": "human",
    "confidence": 1.0,
    "related_symbols": [
      "ILP_FOR",
      "ILP_END"
    ],
    "tags": [],
    "created_at": "2025-12-22T22:26:38.089006",
    "category": "usage_patterns"
  },
  {
    "content": "Triangular iteration pattern works: ILP_FOR(auto i, 0, n, 4) { ILP_FOR(auto j, 0, i, 4) { ... } ILP_END; } ILP_END; The inner loop end can depend on the outer loop variable. This correctly handles variable-length inner loops.",
    "source": "test",
    "validated_by": "human",
    "confidence": 1.0,
    "related_symbols": [
      "ILP_FOR"
    ],
    "tags": [],
    "created_at": "2025-12-22T22:29:51.066383",
    "category": "usage_patterns"
  },
  {
    "content": "Empty loop body is valid and doesn't crash. ILP_FOR(auto i, 0, 100, 4) { (void)i; } ILP_END; - this just iterates without doing anything. Useful placeholder during development.",
    "source": "test",
    "validated_by": "human",
    "confidence": 1.0,
    "related_symbols": [
      "ILP_FOR"
    ],
    "tags": [],
    "created_at": "2025-12-22T22:30:52.149576",
    "category": "usage_patterns"
  },
  {
    "content": "Negative ranges work correctly: ILP_FOR(auto i, -5, 5, 4) iterates through -5,-4,-3,-2,-1,0,1,2,3,4. The crossing from negative to positive is handled safely with signed integer types.",
    "source": "test",
    "validated_by": "human",
    "confidence": 1.0,
    "related_symbols": [
      "ILP_FOR"
    ],
    "tags": [],
    "created_at": "2025-12-22T22:31:07.461211",
    "category": "usage_patterns"
  },
  {
    "content": "Raw arrays work with index-based ILP_FOR: int arr[] = {1,2,3,4,5}; ILP_FOR(auto i, 0, 5, 4) { sum += arr[i]; } ILP_END; - use size_t or int for the index type matching the array access pattern.",
    "source": "test",
    "validated_by": "human",
    "confidence": 1.0,
    "related_symbols": [
      "ILP_FOR"
    ],
    "tags": [],
    "created_at": "2025-12-22T22:32:05.526070",
    "category": "usage_patterns"
  },
  {
    "content": "Complete working example of ILP_FOR with early exit:\n\nint count_until_negative(const std::vector<int>& data) {\n    int count = 0;\n    ILP_FOR(auto i, 0, data.size(), 4) {\n        if (data[i] < 0) {\n            ILP_BREAK;\n        }\n        count++;\n    } ILP_END;\n    return count;\n}\n\nThis example shows ILP_FOR with ILP_BREAK for early exit. Loop variable i goes from 0 to data.size(). Body accesses elements with data[i]. ILP_END ends the loop with semicolon. Loop processes 4 elements per iteration.",
    "source": "docs",
    "validated_by": "human",
    "confidence": 1.0,
    "related_symbols": [
      "ILP_FOR",
      "ILP_BREAK",
      "ILP_END"
    ],
    "tags": [
      "example",
      "early-exit",
      "vector"
    ],
    "created_at": "2025-12-23T12:00:00.000000",
    "category": "usage_patterns"
  },
  {
    "content": "Vector iteration patterns with ILP_FOR:\n\n// Process all elements\nvoid process_vector(const std::vector<int>& data) {\n    ILP_FOR(auto i, 0, data.size(), 4) {\n        int value = data[i];  // Access element at index i\n        // Process value...\n    } ILP_END;\n}\n\n// Early exit with return\nint find_first_match(const std::vector<int>& data, int target) {\n    ILP_FOR(auto i, 0, data.size(), 4) {\n        if (data[i] == target) {\n            ILP_RETURN(i);  // Found it, return index\n        }\n    } ILP_END_RETURN;\n    return -1;  // Not found\n}\n\nCommon pattern: ILP_FOR(auto i, 0, vec.size(), N). Use vec[i] to access elements. For early exit with return value, use ILP_RETURN and ILP_END_RETURN.",
    "source": "docs",
    "validated_by": "human",
    "confidence": 1.0,
    "related_symbols": [
      "ILP_FOR",
      "ILP_RETURN",
      "ILP_END_RETURN"
    ],
    "tags": [
      "example",
      "vector",
      "pattern"
    ],
    "created_at": "2025-12-23T12:01:00.000000",
    "category": "usage_patterns"
  },
  {
    "content": "ILP_BREAK usage pattern with flag variable:\n\nbool contains_value(const std::vector<int>& data, int target) {\n    bool found = false;\n    ILP_FOR(auto i, 0, data.size(), 4) {\n        if (data[i] == target) {\n            found = true;\n            ILP_BREAK;  // Exit loop early\n        }\n    } ILP_END;  // Use ILP_END with ILP_BREAK\n    return found;\n}\n\nILP_BREAK exits the loop early, similar to regular break. Must use ILP_END (not ILP_END_RETURN) after loop body. Commonly used with a flag variable set before breaking.",
    "source": "docs",
    "validated_by": "human",
    "confidence": 1.0,
    "related_symbols": [
      "ILP_BREAK",
      "ILP_END"
    ],
    "tags": [
      "example",
      "early-exit",
      "search"
    ],
    "created_at": "2025-12-23T12:02:00.000000",
    "category": "usage_patterns"
  },
  {
    "content": "Minimal complete ILP_FOR program:\n\n#include \"ilp_for/ilp_for.hpp\"\n#include <vector>\n#include <iostream>\n\nint main() {\n    std::vector<int> data = {10, 20, 30, 40, 50};\n\n    // Sum all elements\n    int sum = 0;\n    ILP_FOR(auto i, 0, data.size(), 4) {\n        sum += data[i];\n    } ILP_END;\n\n    std::cout << \"Sum: \" << sum << std::endl;\n    return 0;\n}\n\n// Compile: g++ -std=c++20 -O3 -I/path/to/ilp_for main.cpp\n\nInclude ilp_for.hpp, use ILP_FOR(variable, start, end, N) for loop, end with ILP_END;. Loop variable i accesses elements. Compile with C++20 and optimization enabled.",
    "source": "docs",
    "validated_by": "human",
    "confidence": 1.0,
    "related_symbols": [
      "ILP_FOR",
      "ILP_END"
    ],
    "tags": [
      "example",
      "hello-world",
      "complete"
    ],
    "created_at": "2025-12-23T12:03:00.000000",
    "category": "usage_patterns"
  },
  {
    "content": "ILP_FOR_RANGE example with auto&&:\n\n// Process elements without indices\nvoid process_strings(const std::vector<std::string>& items) {\n    ILP_FOR_RANGE(auto&& item, items, 4) {\n        // item is a reference to each element\n        std::cout << item.size() << std::endl;\n    } ILP_END;\n}\n\n// Modify elements in place\nvoid uppercase_all(std::vector<std::string>& items) {\n    ILP_FOR_RANGE(auto&& item, items, 4) {\n        for (char& c : item) c = std::toupper(c);\n    } ILP_END;\n}\n\nILP_FOR_RANGE(auto&& variable, container, N) iterates over elements directly without indices. Use auto&& to avoid copying (critical for expensive types like std::string). Loop variable is a reference to each element. Container must be an lvalue (named variable), not a temporary. Terminates with ILP_END.",
    "source": "docs",
    "validated_by": "human",
    "confidence": 1.0,
    "related_symbols": [
      "ILP_FOR_RANGE",
      "ILP_END"
    ],
    "tags": [
      "example",
      "range",
      "auto&&"
    ],
    "created_at": "2025-12-23T12:04:00.000000",
    "category": "usage_patterns"
  },
  {
    "content": "ILP_FOR_AUTO example with CPU-specific optimization:\n\n#include \"ilp_for/ilp_for.hpp\"\n#include \"ilp_for/loop_types.hpp\"\n\n// Compile with: -DILP_CPU_SKYLAKE or -DILP_CPU_ZEN5 or -DILP_CPU_APPLE_M1\n\nint find_value(const std::vector<int>& data, int target) {\n    ILP_FOR_AUTO(auto i, 0, data.size(), LoopType::Search, int) {\n        if (data[i] == target) {\n            ILP_RETURN(i);\n        }\n    } ILP_END_RETURN;\n    return -1;\n}\n\nILP_FOR_AUTO chooses optimal unroll factor N automatically based on CPU target defined at compile time (-DILP_CPU_SKYLAKE, etc.). Requires specifying LoopType (Search, DotProduct, Reduction, etc.) and return type. Without CPU target, uses conservative defaults. Best for portable code that should optimize for different architectures.",
    "source": "docs",
    "validated_by": "human",
    "confidence": 1.0,
    "related_symbols": [
      "ILP_FOR_AUTO",
      "ILP_END_RETURN",
      "LoopType"
    ],
    "tags": [
      "example",
      "auto",
      "cpu-targeting"
    ],
    "created_at": "2025-12-23T12:05:00.000000",
    "category": "usage_patterns"
  },
  {
    "content": "ILP_FOR_T example for large return types:\n\n// Return large struct (> 8 bytes)\nstruct LargeResult {\n    int index;\n    double value;\n    std::string name;  // > SBO size\n};\n\nLargeResult find_best(const std::vector<double>& scores, const std::vector<std::string>& names) {\n    double best_score = -1.0;\n    LargeResult result{-1, 0.0, \"\"};\n\n    ILP_FOR_T(LargeResult, auto i, 0, scores.size(), 4) {\n        if (scores[i] > best_score) {\n            best_score = scores[i];\n            result = {(int)i, scores[i], names[i]};\n        }\n    } ILP_END_RETURN;\n    return result;\n}\n\nILP_FOR_T(ReturnType, variable, start, end, N) is needed when return type exceeds SBO size (typically 8 bytes). First parameter specifies return type explicitly. Use with ILP_END_RETURN. For types <= 8 bytes, use regular ILP_FOR. Alternative: increase -DILP_SBO_SIZE at compile time.",
    "source": "docs",
    "validated_by": "human",
    "confidence": 1.0,
    "related_symbols": [
      "ILP_FOR_T",
      "ILP_END_RETURN",
      "ILP_RETURN"
    ],
    "tags": [
      "example",
      "large-return-type",
      "SBO"
    ],
    "created_at": "2025-12-23T12:06:00.000000",
    "category": "usage_patterns"
  },
  {
    "content": "ILP_FOR uses an if-statement with an immediately-invoked lambda to capture the user's loop body. The user's { body } becomes the inner lambda argument to for_loop<N>(), which is why the semicolon must go after ILP_END, not after the closing brace. Putting a semicolon after } would break the lambda call syntax. This design allows for-loop-like syntax while supporting early exit.",
    "source": "implementation",
    "validated_by": "human",
    "confidence": 1.0,
    "related_symbols": [
      "ILP_FOR",
      "ILP_END",
      "syntax"
    ],
    "tags": [],
    "created_at": "2025-12-23T00:00:00.000000",
    "category": "semantics"
  },
  {
    "content": "The if/else pattern used by ILP_FOR is the most portable way to achieve for-loop syntax with early exit in C++. Alternative designs were evaluated: for-loop wrapper (cannot capture user code as callable), callback pattern (requires explicit returns, loses for-loop appearance), statement expressions (supported by GCC and Clang but not MSVC, limiting portability to all three major compilers). The if-statement + lambda approach works across all C++20 compilers including GCC, Clang, and MSVC.",
    "source": "implementation",
    "validated_by": "human",
    "confidence": 1.0,
    "related_symbols": [
      "ILP_FOR",
      "portability",
      "design"
    ],
    "tags": [],
    "created_at": "2025-12-23T00:00:00.000000",
    "category": "semantics"
  },
  {
    "content": "Compile-time errors you'll see: (1) 'Unroll factor N must be at least 1' - using N < 1. (2) 'Return type exceeds SBO size. Use ILP_FOR_T(type, ...) instead.' - ILP_RETURN with type > 8 bytes. (3) 'Return type alignment exceeds SBO size' - overaligned types. (4) 'SmallStorage only supports trivially-destructible types' - using std::string or types with destructors in ILP_RETURN.",
    "source": "implementation",
    "validated_by": "human",
    "confidence": 1.0,
    "related_symbols": [
      "ILP_RETURN",
      "ILP_FOR_T",
      "SmallStorage"
    ],
    "tags": [
      "error-messages",
      "static_assert",
      "troubleshooting"
    ],
    "created_at": "2025-12-24T00:00:00.000000",
    "category": "compiler"
  },
  {
    "content": "Runtime error: '*** ILP_FOR ERROR *** ILP_RETURN was called but ILP_END was used instead of ILP_END_RETURN. The return value would be silently discarded.' This calls std::abort() - program terminates. Fix: change ILP_END to ILP_END_RETURN when using ILP_RETURN in the loop body.",
    "source": "implementation",
    "validated_by": "human",
    "confidence": 1.0,
    "related_symbols": [
      "ILP_RETURN",
      "ILP_END",
      "ILP_END_RETURN"
    ],
    "tags": [
      "error-messages",
      "runtime",
      "troubleshooting"
    ],
    "created_at": "2025-12-24T00:00:00.000000",
    "category": "compiler"
  },
  {
    "content": "Exception safety: Basic guarantee only. Exceptions thrown in loop body propagate normally through the lambda - loop terminates immediately, no remainder iterations run. Loop state (iteration count) may be partial. Strong guarantee NOT provided. noexcept is NOT used on loop body invocation.",
    "source": "implementation",
    "validated_by": "human",
    "confidence": 0.9,
    "related_symbols": [
      "ILP_FOR",
      "ILP_FOR_RANGE"
    ],
    "tags": [
      "exceptions",
      "safety",
      "error-handling"
    ],
    "created_at": "2025-12-24T00:00:00.000000",
    "category": "gotchas"
  },
  {
    "content": "Thread safety: ILP_FOR has no shared mutable state - multiple threads can safely use ILP_FOR simultaneously on different data. Each loop invocation is independent. However, the loop body must be thread-safe if accessing shared data. No OpenMP integration - this is single-threaded loop optimization only.",
    "source": "implementation",
    "validated_by": "human",
    "confidence": 0.9,
    "related_symbols": [
      "ILP_FOR"
    ],
    "tags": [
      "threads",
      "concurrency",
      "safety"
    ],
    "created_at": "2025-12-24T00:00:00.000000",
    "category": "gotchas"
  },
  {
    "content": "ILP_FOR_AUTO(loop_var, start, end, loop_type, element_type) auto-selects optimal N based on LoopType and element_type. Example: ILP_FOR_AUTO(auto i, 0, n, Search, int) { if (arr[i] == target) ILP_BREAK; } ILP_END; The element_type should match what you're operating on (int, double, etc). LoopType guides N selection (Search=4, Sum=4-8, DotProduct=8).",
    "source": "docs",
    "validated_by": "human",
    "confidence": 0.9,
    "related_symbols": [
      "ILP_FOR_AUTO",
      "LoopType",
      "optimal_N"
    ],
    "tags": [
      "auto",
      "syntax",
      "optimal-N"
    ],
    "created_at": "2025-12-24T00:00:00.000000",
    "category": "usage_patterns"
  },
  {
    "content": "ILP_FOR_RANGE_AUTO(loop_var, container, loop_type, element_type) iterates over a container with auto-selected N. Example: ILP_FOR_RANGE_AUTO(auto&& val, vec, Search, int) { if (val < 0) ILP_BREAK; } ILP_END; Use auto&& for the loop variable to avoid copies. element_type should match container's value_type.",
    "source": "docs",
    "validated_by": "human",
    "confidence": 0.9,
    "related_symbols": [
      "ILP_FOR_RANGE_AUTO",
      "LoopType"
    ],
    "tags": [
      "auto",
      "range",
      "syntax"
    ],
    "created_at": "2025-12-24T00:00:00.000000",
    "category": "usage_patterns"
  },
  {
    "content": "ILP_FOR_T_AUTO(ret_type, loop_var, start, end, loop_type, element_type) combines explicit return type with auto N selection. Use when: (1) return type > 8 bytes AND (2) you want architecture-optimized N. Example: ILP_FOR_T_AUTO(MyStruct, auto i, 0, n, Search, int) { if (cond) ILP_RETURN(result); } ILP_END_RETURN;",
    "source": "docs",
    "validated_by": "human",
    "confidence": 0.9,
    "related_symbols": [
      "ILP_FOR_T_AUTO",
      "ILP_FOR_RANGE_T_AUTO",
      "ILP_RETURN"
    ],
    "tags": [
      "auto",
      "large-return-type",
      "syntax"
    ],
    "created_at": "2025-12-24T00:00:00.000000",
    "category": "usage_patterns"
  },
  {
    "content": "Migration guide - standard loop to ILP_FOR: (1) for(int i=0; i<n; i++) becomes ILP_FOR(auto i, 0, n, 4). (2) break becomes ILP_BREAK. (3) continue becomes ILP_CONTINUE. (4) return x becomes ILP_RETURN(x). (5) Add ILP_END after body (or ILP_END_RETURN if using ILP_RETURN). (6) Semicolon goes after ILP_END, not after closing brace. (7) Keep loop body unchanged otherwise.",
    "source": "docs",
    "validated_by": "human",
    "confidence": 1.0,
    "related_symbols": [
      "ILP_FOR",
      "ILP_BREAK",
      "ILP_CONTINUE",
      "ILP_RETURN",
      "ILP_END"
    ],
    "tags": [
      "migration",
      "conversion",
      "how-to"
    ],
    "created_at": "2025-12-24T00:00:00.000000",
    "category": "usage_patterns"
  },
  {
    "content": "Namespace structure: Public API in ilp:: namespace. Internal details in ilp::detail::. CPU profiles in ilp::cpu::. All macros prefixed with ILP_ (public) or __ilp_ (internal). No global namespace pollution. All headers use #pragma once. Library is header-only, single include: #include <ilp_for.hpp>",
    "source": "implementation",
    "validated_by": "human",
    "confidence": 1.0,
    "related_symbols": [
      "ilp",
      "ilp_for.hpp"
    ],
    "tags": [
      "namespace",
      "hygiene",
      "headers"
    ],
    "created_at": "2025-12-24T00:00:00.000000",
    "category": "semantics"
  },
  {
    "content": "How to benchmark ILP_FOR: (1) Warm the cache - run loop once before timing. (2) Use volatile or benchmark::DoNotOptimize to prevent dead code elimination. (3) Test with realistic data sizes (10K+ elements). (4) Compare against simple loop AND #pragma unroll. (5) Check assembly on Godbolt with -O3 -march=native. (6) Run benchmarks/bench_reduce.cpp for reference.",
    "source": "docs",
    "validated_by": "human",
    "confidence": 0.9,
    "related_symbols": [
      "bench_reduce"
    ],
    "tags": [
      "benchmarking",
      "profiling",
      "methodology"
    ],
    "created_at": "2025-12-24T00:00:00.000000",
    "category": "performance"
  },
  {
    "content": "Troubleshooting 'ILP_FOR is not faster': (1) Does loop have break/return? If no, don't use ILP_FOR. (2) Is N > 16? Reduce to 4-8. (3) Is array tiny (<100 elements)? Overhead may dominate. (4) Is body branch-heavy? ILP helps less. (5) Check assembly - is it actually unrolling? (6) Try -DILP_CPU_SKYLAKE etc for your arch. (7) Compare with -DILP_MODE_SIMPLE to isolate.",
    "source": "docs",
    "validated_by": "human",
    "confidence": 0.9,
    "related_symbols": [
      "ILP_FOR",
      "ILP_MODE_SIMPLE"
    ],
    "tags": [
      "troubleshooting",
      "debugging",
      "slow"
    ],
    "created_at": "2025-12-24T00:00:00.000000",
    "category": "performance"
  },
  {
    "content": "In-flight iteration semantics: When ILP_BREAK is called, remaining iterations in the current unrolled block do NOT execute. The implementation checks ctrl.ok after EACH iteration within the inner loop, not at block boundaries. Example: with N=4, if ILP_BREAK at i=5, iterations 6,7 never run. This matches standard break semantics exactly - no speculative execution.",
    "source": "implementation",
    "validated_by": "human",
    "confidence": 1.0,
    "related_symbols": [
      "ILP_BREAK",
      "ILP_CONTINUE",
      "ForCtrl"
    ],
    "tags": [
      "semantics",
      "control-flow",
      "early-exit"
    ],
    "created_at": "2025-12-24T00:00:00.000000",
    "category": "semantics"
  },
  {
    "content": "Cannot use goto to exit ILP_FOR loops. The loop body is a lambda function, and goto cannot cross lambda scope boundaries in C++. Use ILP_BREAK (exit loop), ILP_CONTINUE (skip iteration), or ILP_RETURN(x) (exit enclosing function) instead.",
    "source": "implementation",
    "validated_by": "human",
    "confidence": 1.0,
    "related_symbols": [
      "ILP_FOR",
      "ILP_BREAK",
      "ILP_CONTINUE",
      "ILP_RETURN"
    ],
    "tags": [
      "goto",
      "lambda",
      "control-flow"
    ],
    "created_at": "2025-12-24T00:00:00.000000",
    "category": "gotchas"
  },
  {
    "content": "Benchmark results (Apple M2, Clang 19, -O3): ILP_BREAK patterns: 1.29-1.36x speedup over simple loop. ILP_RETURN patterns: 1.66-1.80x speedup (best case - parallel comparison before return). No advantage for accumulation without early exit (compiler auto-vectorizes). std::find_if matches ILP_FOR (<1% difference). See benchmarks/results/ for detailed data.",
    "source": "benchmark",
    "validated_by": "human",
    "confidence": 0.9,
    "related_symbols": [
      "ILP_FOR",
      "ILP_BREAK",
      "ILP_RETURN"
    ],
    "tags": [
      "benchmark",
      "speedup",
      "M2",
      "performance"
    ],
    "created_at": "2025-12-24T00:00:00.000000",
    "category": "performance"
  },
  {
    "content": "ILP_FOR benefits are computation-driven (instruction parallelism), not memory-driven. Sequential memory access is already optimal - no prefetch hints needed. The 4x unroll fits within typical hardware prefetch distance. Strided or random access patterns don't benefit differently from ILP_FOR vs simple loops.",
    "source": "docs",
    "validated_by": "human",
    "confidence": 0.9,
    "related_symbols": [
      "ILP_FOR"
    ],
    "tags": [
      "cache",
      "memory",
      "prefetch"
    ],
    "created_at": "2025-12-24T00:00:00.000000",
    "category": "performance"
  },
  {
    "content": "Complete list of ILP_FOR macro variants (8 total):\n\n• ILP_FOR(var, start, end, N) — index loop with explicit N\n• ILP_FOR_T(type, var, start, end, N) — with explicit return type\n• ILP_FOR_AUTO(var, start, end, LoopType, ElemType) — auto N selection\n• ILP_FOR_T_AUTO(type, var, start, end, LoopType, ElemType) — both auto N and explicit return type\n• ILP_FOR_RANGE(var, container, N) — range-based with explicit N\n• ILP_FOR_RANGE_T(type, var, container, N) — range with explicit return type\n• ILP_FOR_RANGE_AUTO(var, container, LoopType, ElemType) — range with auto N\n• ILP_FOR_RANGE_T_AUTO(type, var, container, LoopType, ElemType) — range with both",
    "source": "docs",
    "validated_by": "human",
    "confidence": 1.0,
    "related_symbols": [
      "ILP_FOR",
      "ILP_FOR_T",
      "ILP_FOR_AUTO",
      "ILP_FOR_T_AUTO",
      "ILP_FOR_RANGE",
      "ILP_FOR_RANGE_T",
      "ILP_FOR_RANGE_AUTO",
      "ILP_FOR_RANGE_T_AUTO"
    ],
    "tags": [
      "api",
      "reference",
      "complete-list"
    ],
    "created_at": "2025-12-24T00:00:00.000000",
    "category": "api_signatures"
  },
  {
    "content": "LoopType enum has 11 values: Sum (acc+=val), DotProduct (acc+=a*b with FMA), Search (early exit), Copy (dst=src), Transform (dst=f(src)), Multiply (acc*=val), Divide (val/const), Sqrt (sqrt(val)), MinMax (min/max reduction), Bitwise (& | ^), Shift (<< >>). Usage: ilp::LoopType::Search, ilp::LoopType::Sum, etc.",
    "source": "docs",
    "validated_by": "human",
    "confidence": 1.0,
    "related_symbols": [
      "LoopType",
      "Sum",
      "DotProduct",
      "Search",
      "Copy",
      "Transform",
      "Multiply",
      "Divide",
      "Sqrt",
      "MinMax",
      "Bitwise",
      "Shift"
    ],
    "tags": [
      "enum",
      "reference",
      "complete-list"
    ],
    "created_at": "2025-12-24T00:00:00.000000",
    "category": "api_signatures"
  },
  {
    "content": "Only two loop endings exist: ILP_END and ILP_END_RETURN. There is NO ILP_END_BREAK. Use ILP_END when loop uses ILP_BREAK or no early exit. Use ILP_END_RETURN when loop uses ILP_RETURN. Mismatch causes runtime abort with diagnostic message.",
    "source": "docs",
    "validated_by": "human",
    "confidence": 1.0,
    "related_symbols": [
      "ILP_END",
      "ILP_END_RETURN",
      "ILP_BREAK",
      "ILP_RETURN"
    ],
    "tags": [
      "ending",
      "macro",
      "common-mistake"
    ],
    "created_at": "2025-12-24T00:00:00.000000",
    "category": "gotchas"
  },
  {
    "content": "ILP_END_BREAK does not exist. When using ILP_BREAK, end the loop with ILP_END (not ILP_END_RETURN). ILP_END_RETURN is only for ILP_RETURN.",
    "source": "docs",
    "validated_by": "human",
    "confidence": 1.0,
    "related_symbols": [
      "ILP_END",
      "ILP_END_RETURN",
      "ILP_BREAK"
    ],
    "tags": [
      "clarification",
      "nonexistent",
      "common-mistake"
    ],
    "created_at": "2025-12-24T00:00:00.000000",
    "category": "gotchas"
  },
  {
    "content": "ILP_FOR is a C++ header-only macro library for optimizing loops with early exit (break/continue/return). It provides instruction-level parallelism by unrolling loops while correctly handling control flow. Key macros: ILP_FOR, ILP_FOR_RANGE, ILP_BREAK, ILP_CONTINUE, ILP_RETURN. Requires C++20. Use it when #pragma unroll fails for loops with break - ILP_FOR gives ~1.5x speedup by reducing bounds checks.",
    "source": "docs",
    "validated_by": "human",
    "confidence": 1.0,
    "related_symbols": [
      "ILP_FOR",
      "ILP_BREAK",
      "ILP_RETURN",
      "ILP_CONTINUE",
      "ILP_FOR_RANGE"
    ],
    "tags": [
      "overview",
      "introduction",
      "what-is",
      "summary",
      "getting-started"
    ],
    "created_at": "2025-12-24T00:00:00.000000",
    "category": "usage_patterns"
  },
  {
    "content": "Expert knowledge of ILP_FOR includes: (1) When to use it - only for loops with early exit, (2) Syntax - ILP_FOR(var, start, end, N) { body } ILP_END; with semicolon after ILP_END, (3) ILP_END vs ILP_END_RETURN - match to ILP_BREAK vs ILP_RETURN, (4) auto&& for range loops, (5) CPU targeting with -DILP_CPU_*, (6) Debug mode with -DILP_MODE_SIMPLE, (7) LoopType selection for _AUTO variants.",
    "source": "docs",
    "validated_by": "human",
    "confidence": 1.0,
    "related_symbols": [
      "ILP_FOR",
      "ILP_END",
      "ILP_END_RETURN",
      "ILP_BREAK",
      "ILP_RETURN"
    ],
    "tags": [
      "expert",
      "summary",
      "knowledge",
      "checklist",
      "mastery"
    ],
    "created_at": "2025-12-24T00:00:00.000000",
    "category": "usage_patterns"
  },
  {
    "content": "Introduction to ILP_FOR: A C++ macro library that optimizes loops containing break, continue, or return statements. Unlike #pragma unroll which checks bounds after every iteration, ILP_FOR batches N iterations with a single bounds check, achieving ~1.5x speedup. Basic usage: ILP_FOR(auto i, 0, size, 4) { if (condition) ILP_BREAK; } ILP_END; Header-only, requires C++20, works with GCC/Clang/MSVC.",
    "source": "docs",
    "validated_by": "human",
    "confidence": 1.0,
    "related_symbols": [
      "ILP_FOR",
      "ILP_BREAK",
      "ILP_END"
    ],
    "tags": [
      "introduction",
      "intro",
      "beginner",
      "tutorial",
      "basics"
    ],
    "created_at": "2025-12-24T00:00:00.000000",
    "category": "usage_patterns"
  }
]