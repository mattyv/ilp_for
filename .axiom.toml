# ILP_FOR Library Axioms and Pairings
# This file defines semantic relationships and domain knowledge for ILP_FOR.

[metadata]
layer = "ilp_for"
version = "1.0.0"

# =============================================================================
# Domain Knowledge Axioms
# These explain the "why" behind ILP_FOR - from docs/ILP.md and docs/PERFORMANCE.md
# =============================================================================

[[axioms]]
id = "ilp_for.purpose.ilp_optimization"
function = "ILP_FOR"
header = "ilp_for/ilp_for.hpp"
axiom_type = "effect"
content = "ILP_FOR unrolls loops by factor N, enabling CPU superscalar execution to run N independent operations in parallel across execution ports (Skylake has 8 ports)"
formal_spec = "throughput(ILP_FOR(body, N)) ~= N * throughput(for_loop(body)) when iterations are independent"
on_violation = "Falls back to sequential execution with no speedup"
confidence = 1.0

[[axioms]]
id = "ilp_for.purpose.early_exit"
function = "ILP_FOR"
header = "ilp_for/ilp_for.hpp"
axiom_type = "effect"
content = "ILP_FOR is optimized for loops with early exit (ILP_BREAK, ILP_RETURN). For pure accumulation without early exit, compilers can often auto-vectorize simple loops just as effectively."
formal_spec = "benefit(ILP_FOR) maximized when has_early_exit(body)"
confidence = 1.0

[[axioms]]
id = "ilp_for.guidance.choosing_n"
function = "ILP_FOR"
header = "ilp_for/ilp_for.hpp"
axiom_type = "constraint"
content = "N should match pipeline latency/throughput ratio. For FP ops with 4-cycle latency and 2/cycle throughput, N=8 saturates FP units. For integer ops (1-cycle latency, 4/cycle throughput), N=4 is sufficient."
formal_spec = "optimal_N = latency / throughput; N=4 typical for integer, N=8 for FP"
confidence = 0.95

[[axioms]]
id = "ilp_for.guidance.when_to_use"
function = "ILP_FOR"
header = "ilp_for/ilp_for.hpp"
axiom_type = "constraint"
content = "Use ILP_FOR for: (1) loops with early exit (ILP_BREAK, ILP_RETURN), (2) search operations where comparisons can run in parallel, (3) operations with dependency chains (min, max). Skip for simple sums without early exit."
formal_spec = "benefit(ILP_FOR) > 0 when has_early_exit(body) || has_dependency_chain(body)"
confidence = 1.0

[[axioms]]
id = "ilp_for.advantage.over_pragma_unroll"
function = "ILP_FOR"
header = "ilp_for/ilp_for.hpp"
axiom_type = "effect"
content = "Unlike #pragma unroll, ILP_FOR does not insert per-iteration bounds checks for early-exit loops. Pragma unroll fails because SCEV cannot determine trip count when break/return is present."
formal_spec = "ILP_FOR avoids bounds_check overhead that pragma_unroll incurs for early_exit loops"
confidence = 1.0

[[axioms]]
id = "ilp_for.benchmark.speedup"
function = "ILP_FOR"
header = "ilp_for/ilp_for.hpp"
axiom_type = "effect"
content = "Benchmarks on Apple M2 show 1.3x-2.4x speedup: ILP_BREAK 1.56x, ILP_RETURN 1.79x, ILP_CONTINUE 1.31x, ILP_FOR_RANGE with BREAK 2.35x"
formal_spec = "speedup in [1.3, 2.4] for early-exit patterns on ARM"
confidence = 1.0

# =============================================================================
# Loop Start/End Pairs (CONDITIONAL)
# Every ILP_FOR* macro MUST be closed with either ILP_END or ILP_END_RETURN:
#   - Use ILP_END when ILP_RETURN is NOT used in the loop body
#   - Use ILP_END_RETURN when ILP_RETURN IS used in the loop body
# Using the wrong closer will cause runtime errors or compilation errors.
# =============================================================================

[[pairing]]
opener = "ILP_FOR"
closer = "ILP_END"
required = true
evidence = "Loop structure: ILP_FOR opens a loop block that must be closed with ILP_END (when ILP_RETURN is not used in the body)"

[[pairing]]
opener = "ILP_FOR_T"
closer = "ILP_END"
required = true
evidence = "Loop structure: ILP_FOR_T (typed) opens a loop block that must be closed with ILP_END (when ILP_RETURN is not used in the body)"

[[pairing]]
opener = "ILP_FOR_AUTO"
closer = "ILP_END"
required = true
evidence = "Loop structure: ILP_FOR_AUTO opens a loop block that must be closed with ILP_END (when ILP_RETURN is not used in the body)"

[[pairing]]
opener = "ILP_FOR_T_AUTO"
closer = "ILP_END"
required = true
evidence = "Loop structure: ILP_FOR_T_AUTO opens a loop block that must be closed with ILP_END (when ILP_RETURN is not used in the body)"

[[pairing]]
opener = "ILP_FOR_RANGE"
closer = "ILP_END"
required = true
evidence = "Loop structure: ILP_FOR_RANGE opens a loop block that must be closed with ILP_END (when ILP_RETURN is not used in the body)"

[[pairing]]
opener = "ILP_FOR_RANGE_T"
closer = "ILP_END"
required = true
evidence = "Loop structure: ILP_FOR_RANGE_T opens a loop block that must be closed with ILP_END (when ILP_RETURN is not used in the body)"

[[pairing]]
opener = "ILP_FOR_RANGE_AUTO"
closer = "ILP_END"
required = true
evidence = "Loop structure: ILP_FOR_RANGE_AUTO opens a loop block that must be closed with ILP_END (when ILP_RETURN is not used in the body)"

[[pairing]]
opener = "ILP_FOR_RANGE_T_AUTO"
closer = "ILP_END"
required = true
evidence = "Loop structure: ILP_FOR_RANGE_T_AUTO opens a loop block that must be closed with ILP_END (when ILP_RETURN is not used in the body)"

# =============================================================================
# Loop Start with Early Return Pairs
# When ILP_RETURN is used in the loop body, ILP_END_RETURN MUST be used instead of ILP_END.
# Using ILP_END when ILP_RETURN is present will cause a runtime error.
# =============================================================================

[[pairing]]
opener = "ILP_FOR"
closer = "ILP_END_RETURN"
required = true
evidence = "Loop structure: ILP_FOR must use ILP_END_RETURN when ILP_RETURN is used in the loop body (required when returning from enclosing function)"

[[pairing]]
opener = "ILP_FOR_T"
closer = "ILP_END_RETURN"
required = true
evidence = "Loop structure: ILP_FOR_T must use ILP_END_RETURN when ILP_RETURN is used in the loop body (required when returning from enclosing function)"

[[pairing]]
opener = "ILP_FOR_AUTO"
closer = "ILP_END_RETURN"
required = true
evidence = "Loop structure: ILP_FOR_AUTO must use ILP_END_RETURN when ILP_RETURN is used in the loop body (required when returning from enclosing function)"

[[pairing]]
opener = "ILP_FOR_T_AUTO"
closer = "ILP_END_RETURN"
required = true
evidence = "Loop structure: ILP_FOR_T_AUTO must use ILP_END_RETURN when ILP_RETURN is used in the loop body (required when returning from enclosing function)"

[[pairing]]
opener = "ILP_FOR_RANGE"
closer = "ILP_END_RETURN"
required = true
evidence = "Loop structure: ILP_FOR_RANGE must use ILP_END_RETURN when ILP_RETURN is used in the loop body (required when returning from enclosing function)"

[[pairing]]
opener = "ILP_FOR_RANGE_T"
closer = "ILP_END_RETURN"
required = true
evidence = "Loop structure: ILP_FOR_RANGE_T must use ILP_END_RETURN when ILP_RETURN is used in the loop body (required when returning from enclosing function)"

[[pairing]]
opener = "ILP_FOR_RANGE_AUTO"
closer = "ILP_END_RETURN"
required = true
evidence = "Loop structure: ILP_FOR_RANGE_AUTO must use ILP_END_RETURN when ILP_RETURN is used in the loop body (required when returning from enclosing function)"

[[pairing]]
opener = "ILP_FOR_RANGE_T_AUTO"
closer = "ILP_END_RETURN"
required = true
evidence = "Loop structure: ILP_FOR_RANGE_T_AUTO must use ILP_END_RETURN when ILP_RETURN is used in the loop body (required when returning from enclosing function)"

# =============================================================================
# Control Flow Pairing
# ILP_RETURN must be paired with ILP_END_RETURN (not ILP_END)
# =============================================================================

[[pairing]]
opener = "ILP_RETURN"
closer = "ILP_END_RETURN"
required = true
evidence = "Control flow: When ILP_RETURN is used anywhere in the loop body, the loop MUST be closed with ILP_END_RETURN instead of ILP_END. Using ILP_END with ILP_RETURN will trigger ilp::detail::ilp_end_with_return_error() at runtime."

# =============================================================================
# Idiom Templates
# Common usage patterns showing correct composition
# =============================================================================

[[idiom]]
name = "ilp_for_basic"
participants = ["ILP_FOR", "ILP_END"]
template = '''
ILP_FOR(int, i, 0, n, N) {
    // loop body - processes N iterations in parallel
} ILP_END
'''

[[idiom]]
name = "ilp_for_typed"
participants = ["ILP_FOR_T", "ILP_END"]
template = '''
ILP_FOR_T(size_t, i, start, end, N) {
    // loop body with explicit type for iterator
} ILP_END
'''

[[idiom]]
name = "ilp_for_auto"
participants = ["ILP_FOR_AUTO", "ILP_END"]
template = '''
ILP_FOR_AUTO(i, 0, n, N) {
    // loop body with auto-deduced iterator type
} ILP_END
'''

[[idiom]]
name = "ilp_for_range"
participants = ["ILP_FOR_RANGE", "ILP_END"]
template = '''
ILP_FOR_RANGE(int, elem, container, N) {
    // iterate over container elements
} ILP_END
'''

[[idiom]]
name = "ilp_for_early_return"
participants = ["ILP_FOR", "ILP_RETURN", "ILP_END_RETURN"]
template = '''
ILP_FOR(int, i, 0, n, N) {
    if (condition) {
        ILP_RETURN(value);  // early return from loop
    }
} ILP_END_RETURN
'''

[[idiom]]
name = "ilp_for_break_continue"
participants = ["ILP_FOR", "ILP_BREAK", "ILP_CONTINUE", "ILP_END"]
template = '''
ILP_FOR(int, i, 0, n, N) {
    if (skip_condition) {
        ILP_CONTINUE;  // skip to next iteration
    }
    if (stop_condition) {
        ILP_BREAK;  // exit loop early
    }
} ILP_END
'''
