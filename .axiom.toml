# ILP_FOR Library Axioms and Pairings

[metadata]
layer = "ilp_for"
version = "1.0.0"

# =============================================================================
# Domain Knowledge Axioms
# =============================================================================

[[axioms]]
id = "ilp_for.purpose.ilp_optimization"
function = "ILP_FOR"
header = "ilp_for/ilp_for.hpp"
axiom_type = "effect"
content = "Unrolls loops by factor N for CPU superscalar execution across multiple execution ports."
formal_spec = "throughput ~= N * sequential when iterations are independent"
confidence = 1.0

[[axioms]]
id = "ilp_for.purpose.early_exit"
function = "ILP_FOR"
header = "ilp_for/ilp_for.hpp"
axiom_type = "effect"
content = "Optimized for early exit (ILP_BREAK, ILP_RETURN). For pure accumulation, compilers auto-vectorize."
formal_spec = "benefit maximized when has_early_exit(body)"
confidence = 1.0

[[axioms]]
id = "ilp_for.guidance.choosing_n"
function = "ILP_FOR"
header = "ilp_for/ilp_for.hpp"
axiom_type = "constraint"
content = "N = latency/throughput. N=4 for integer, N=8 for FP."
formal_spec = "optimal_N = pipeline_latency / throughput"
confidence = 0.95

[[axioms]]
id = "ilp_for.guidance.when_to_use"
function = "ILP_FOR"
header = "ilp_for/ilp_for.hpp"
axiom_type = "constraint"
content = "Use for: early exit loops, parallel searches. For reductions, need N accumulators."
formal_spec = "benefit > 0 when has_early_exit || has_independent_iterations"
confidence = 1.0
depends_on = ["ilp_for.guidance.dependency_chains"]

[[axioms]]
id = "ilp_for.guidance.dependency_chains"
function = "ILP_FOR"
header = "ilp_for/ilp_for.hpp"
axiom_type = "constraint"
content = "Single accumulator = sequential. For N-way unroll, use N accumulators merged after loop."
formal_spec = "sum += x[i] is sequential; sum0..sumN += x[i+0..N] enables ILP"
confidence = 1.0

[[axioms]]
id = "ilp_for.advantage.over_pragma_unroll"
function = "ILP_FOR"
header = "ilp_for/ilp_for.hpp"
axiom_type = "effect"
content = "Unlike #pragma unroll, no per-iteration bounds checks for early-exit loops."
formal_spec = "avoids bounds_check overhead from SCEV limitations"
confidence = 1.0

[[axioms]]
id = "ilp_for.benchmark.speedup"
function = "ILP_FOR"
header = "ilp_for/ilp_for.hpp"
axiom_type = "effect"
content = "Apple M2: ILP_BREAK 1.56x, ILP_RETURN 1.79x, ILP_CONTINUE 1.31x, ILP_FOR_RANGE+BREAK 2.35x"
formal_spec = "speedup in [1.3, 2.4] on ARM"
confidence = 1.0

# =============================================================================
# Syntactic Gotchas
# =============================================================================

[[axioms]]
id = "ilp_for.syntax.loop_var_decl"
function = "ILP_FOR"
header = "ilp_for/ilp_for.hpp"
axiom_type = "precondition"
content = "loop_var_decl is ONE argument: 'int i' not 'int, i'. Applies to all ILP_FOR variants."
formal_spec = "loop_var_decl = type + varname as single token"
on_violation = "macro passed N+1 arguments"
confidence = 1.0
depends_on = ["ilp_for.purpose.ilp_optimization"]

[[axioms]]
id = "ilp_for.syntax.no_comma_in_type"
function = "ILP_FOR_T"
header = "ilp_for/ilp_for.hpp"
axiom_type = "precondition"
content = "Type argument cannot contain commas (preprocessor). Use typedef for complex types."
formal_spec = "type_arg must be single token"
on_violation = "macro argument count mismatch"
confidence = 1.0
depends_on = ["ilp_for.purpose.ilp_optimization"]

[[axioms]]
id = "ilp_for.syntax.type_matching"
function = "ILP_FOR_AUTO"
header = "ilp_for/ilp_for.hpp"
axiom_type = "precondition"
content = "Start/end must match types. Cast literals: size_t(0) not 0."
formal_spec = "decltype(start) == decltype(end)"
on_violation = "template argument deduction failed"
confidence = 1.0
depends_on = ["ilp_for.guidance.prefer_auto_variants"]

[[axioms]]
id = "ilp_for.syntax.semicolons"
function = "ILP_BREAK"
header = "ilp_for/ilp_for.hpp"
axiom_type = "precondition"
content = "ILP_BREAK, ILP_CONTINUE, ILP_END, ILP_END_RETURN require trailing semicolons."
formal_spec = "statement-like macros require ;"
confidence = 1.0
depends_on = ["ilp_for.purpose.early_exit"]

[[axioms]]
id = "ilp_for.guidance.prefer_auto_variants"
function = "ILP_FOR_AUTO"
header = "ilp_for/ilp_for.hpp"
axiom_type = "constraint"
content = "Prefer _AUTO variants - loop_type (Search, Sum, DotProduct) auto-selects N per-CPU."
formal_spec = "portability(ILP_FOR_AUTO) > portability(ILP_FOR)"
confidence = 1.0
depends_on = ["ilp_for.guidance.choosing_n"]

# =============================================================================
# Loop Start/End Pairs
# =============================================================================

[[pairing]]
opener = "ILP_FOR"
closer = "ILP_END"
required = true
evidence = "Close with ILP_END when no ILP_RETURN in body"

[[pairing]]
opener = "ILP_FOR_T"
closer = "ILP_END"
required = true
evidence = "Close with ILP_END when no ILP_RETURN in body"

[[pairing]]
opener = "ILP_FOR_AUTO"
closer = "ILP_END"
required = true
evidence = "Close with ILP_END when no ILP_RETURN in body"

[[pairing]]
opener = "ILP_FOR_T_AUTO"
closer = "ILP_END"
required = true
evidence = "Close with ILP_END when no ILP_RETURN in body"

[[pairing]]
opener = "ILP_FOR_RANGE"
closer = "ILP_END"
required = true
evidence = "Close with ILP_END when no ILP_RETURN in body"

[[pairing]]
opener = "ILP_FOR_RANGE_T"
closer = "ILP_END"
required = true
evidence = "Close with ILP_END when no ILP_RETURN in body"

[[pairing]]
opener = "ILP_FOR_RANGE_AUTO"
closer = "ILP_END"
required = true
evidence = "Close with ILP_END when no ILP_RETURN in body"

[[pairing]]
opener = "ILP_FOR_RANGE_T_AUTO"
closer = "ILP_END"
required = true
evidence = "Close with ILP_END when no ILP_RETURN in body"

# When ILP_RETURN is used, MUST use ILP_END_RETURN

[[pairing]]
opener = "ILP_FOR"
closer = "ILP_END_RETURN"
required = true
evidence = "Close with ILP_END_RETURN when ILP_RETURN is used"

[[pairing]]
opener = "ILP_FOR_T"
closer = "ILP_END_RETURN"
required = true
evidence = "Close with ILP_END_RETURN when ILP_RETURN is used"

[[pairing]]
opener = "ILP_FOR_AUTO"
closer = "ILP_END_RETURN"
required = true
evidence = "Close with ILP_END_RETURN when ILP_RETURN is used"

[[pairing]]
opener = "ILP_FOR_T_AUTO"
closer = "ILP_END_RETURN"
required = true
evidence = "Close with ILP_END_RETURN when ILP_RETURN is used"

[[pairing]]
opener = "ILP_FOR_RANGE"
closer = "ILP_END_RETURN"
required = true
evidence = "Close with ILP_END_RETURN when ILP_RETURN is used"

[[pairing]]
opener = "ILP_FOR_RANGE_T"
closer = "ILP_END_RETURN"
required = true
evidence = "Close with ILP_END_RETURN when ILP_RETURN is used"

[[pairing]]
opener = "ILP_FOR_RANGE_AUTO"
closer = "ILP_END_RETURN"
required = true
evidence = "Close with ILP_END_RETURN when ILP_RETURN is used"

[[pairing]]
opener = "ILP_FOR_RANGE_T_AUTO"
closer = "ILP_END_RETURN"
required = true
evidence = "Close with ILP_END_RETURN when ILP_RETURN is used"

[[pairing]]
opener = "ILP_RETURN"
closer = "ILP_END_RETURN"
required = true
evidence = "ILP_RETURN requires ILP_END_RETURN (not ILP_END) or runtime error"

# =============================================================================
# Idiom Templates - Canonical usage patterns
# =============================================================================

[[idiom]]
name = "ilp_for_basic"
participants = ["ILP_FOR", "ILP_END"]
template = '''
ILP_FOR(int i, 0, n, 4) {
    // body
} ILP_END;
'''

[[idiom]]
name = "ilp_for_typed"
participants = ["ILP_FOR_T", "ILP_END"]
template = '''
ILP_FOR_T(size_t, size_t i, 0, n, 4) {
    // body with explicit return type
} ILP_END;
'''

[[idiom]]
name = "ilp_for_auto"
participants = ["ILP_FOR_AUTO", "ILP_END"]
template = '''
// loop_type: Search, Sum, DotProduct, MinMax, etc.
ILP_FOR_AUTO(auto i, size_t(0), vec.size(), Search, size_t) {
    // body
} ILP_END;
'''

[[idiom]]
name = "ilp_for_range"
participants = ["ILP_FOR_RANGE", "ILP_END"]
template = '''
ILP_FOR_RANGE(auto& elem, container, 4) {
    // body
} ILP_END;
'''

[[idiom]]
name = "ilp_for_early_return"
participants = ["ILP_FOR", "ILP_RETURN", "ILP_END_RETURN"]
template = '''
ILP_FOR(int i, 0, n, 4) {
    if (found) ILP_RETURN(value);
} ILP_END_RETURN;  // NOT ILP_END!
'''

[[idiom]]
name = "ilp_for_break_continue"
participants = ["ILP_FOR", "ILP_BREAK", "ILP_CONTINUE", "ILP_END"]
template = '''
ILP_FOR(int i, 0, n, 4) {
    if (skip) ILP_CONTINUE;
    if (done) ILP_BREAK;
} ILP_END;
'''
